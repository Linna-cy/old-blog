{"posts":[{"title":"软件设计师——计算机系统","content":"计算机的基本单位 位（比特），最小数据单位 bit、b 字节，最小存储单位 byte、B 1B = 8b 千字节 KB 1KB = 1024B 兆字节 MB 1MB = 1024KB 吉字节 GB 1GB = 1024MB 太字节 TB 1TB = 1024GB 计算机系统 计算机系统由硬件和软件组成。 计算机基本硬件系统： 运算器 控制器 存储器 输入设备 输出设备 中央处理单元 运算器、控制器等部件被集成在一起统称中央处理单元（CPU）。CPU是硬件系统的核心，用于数据的加工处理，能完成各种算术、逻辑运算及控制功能。 中央处理单元（CPU）负责获取程序指令、对指令进行译码并加以执行。 CPU的功能： 程序控制：通过执行指令来控制程序的执行顺序 操作控制：CPU产生每条指令的（若干）操作信号并将操作信号送往对应的部件，控制相应的部件按指令的功能要求进行操作。 时间控制：对各种操作进行时间上的控制，即指令执行过程中操作信号的出现时间、持续时间及出现的时间顺序都需要进行严格控制。 数据处理：通过对数据进行算术运算及逻辑运算等方式进行加工处理，数据加工处理的结果被人们所利用。 对数据的加工处理也是CPU最根本的任务。 对系统内部和外部的中断（异常）做出响应，进行相应的处理。 CPU的组成： 运算器 控制器 寄存器组 内部总线 运算器 运算器组成部件： 算术逻辑单元（ALU）：重要组成部件。负责处理数据，实现对数据的算术运算和逻辑运算。 累加寄存器（AC，累加器）：是一个通用寄存器。存放操作数或者结果。 其功能是当运算器的算术逻辑单元执行算术或逻辑运算时，为ALU提供一个工作区。例如，在执行一个减法运算前，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中。 运算的结果是放在累加器中的，运算器中至少要有一个累加寄存器。 数据缓冲寄存器（DR）：暂存由内存读/写的一条指令或一个数据字，将不同时间段内读/写的数据隔离开来。 DR的主要作用为： 作为CPU和内存、外部设备之间数据传送的中转站； 作为CPU和内存、外围设备之间在操作速度上的缓冲； 在单累加器结构的运算器中，数据缓冲寄存器还可兼作为操作数寄存器。 状态条件寄存器（PSW）：保存了当前指令执行完成之后的状态（标志通常分别由1位触发器保存）。通常，一个算术操作产生一个运算结果，而一个逻辑操作产生一个判决。 控制器 控制器用于控制整个CPU的工作，它决定了计算机运行过程的 自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。 指令控制逻辑要完取指令、分析指令和执行指令的操作，其过程分为取指令、指令译码、按指令操作码执行、形成下一条指令地址等步骤。 指令寄存器（IR）：暂存要执行的指令，该指令从内存中获取（通过缓冲寄存器）。 当CPU执行一条指令时： 把指令从内存储器取到缓冲寄存器中。 送入IR暂存。 指令译码器根据IR的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。 程序计数器（PC，指令计数器）：具有寄存信息和计数两种 在程序开始执行前，将程序的起始地址送入PC。 该地址在程序加载到内存时确定，因此PC的内容即是程序第一条指令的地址。 执行指令时，CPU自动修改PC的内容，以便使其保持的总是将要执行的下一条指令的地址。 由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单地对PC加1。 执行转移指令时，后继指令的地址根据当前指令的地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移的地址得到。 地址寄存器（AR）：保存当前CPU所访问的内存单元的地址。 指令译码器(ID)。指令包含操作码和地址码两部分，而指令译码器就是对指令中的操作码字段进行分析解释，识别该指令规定的操作，向操作控制器发出具体的控制信号，控制各部件工作，完成所需的功能。 数据表示 原码 原码表示法又叫符号加绝对值表示法。最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。 原码特点： 0的表示不唯一（有正负0）； 加、减运算方式不统一； 需额外对符号位进行处理，不利于硬件设计； 当 a&lt;ba &lt; ba&lt;b 时，实现 a−ba-ba−b 比较困难。 反码 最高位为符号位，0表示正号，1表示负号，其余的n-1位表示数值的绝对值。正数的反码与原码相同，负数的反码则是除符号位以外其余各位按位取反。 补码 计算机中的补码是模2补码 概念：在一个模运算（Moduler Arithmetic）系统中，同余（Congruence Modulo）的数等价。 补码的定义：有 nnn 位时，[X]补=(2n+X)mod 2n(−2n−1≤X&lt;2n−1)[X]_补=(2^n+X)\\mod{2^n}\\quad (-2^{n-1}\\leq X&lt;2^{n-1})[X]补​=(2n+X)mod2n(−2n−1≤X&lt;2n−1)。 当 X&lt;0X&lt;0X&lt;0 时，补码有两种求法： 各位取反，末位加 1。 从第 2 个 1 开始往右各位取反。 当 X&gt;0X&gt;0X&gt;0 时，补码与原码相同。 补码的减法：Y−X=Y+[−X]补Y-X=Y+[-X]_补Y−X=Y+[−X]补​。 特殊的补码： [−2n−1]补=(2n−2n−1)mod 2n=(10…0)2 (n−1个0)[-2^{n-1}]_补=(2^n-2^{n-1})\\mod{2^n}=(10\\ldots0)_2\\ (n-1 个0)[−2n−1]补​=(2n−2n−1)mod2n=(10…0)2​ (n−1个0)。 这个数的最高位（符号位）即表示符号，又表示数值。如，-128。 [−1]补=2n−1=(11…1)2 (n个1)[-1]_补=2^n-1=(11\\ldots1)_2\\ (n个1)[−1]补​=2n−1=(11…1)2​ (n个1)。 [+0]补=[−0]补=(00…0) (n个0)[+0]_补=[-0]_补=(00\\ldots0)\\ (n个0)[+0]补​=[−0]补​=(00…0) (n个0)。 补码的0表示唯一。 移码 移码就是将每个数值加上一个偏置常数（Excess/Bias）。 通常，当编码位数为 nnn 时，bias 取 2n−12^{n-1}2n−1 或 2n−1−12^{n-1}-12n−1−1。 移码可以方便地进行大小的比较。 移码可以看成是在其补码的基础上对符号位取反。移码的0表示唯一。 其实（个人认为）根据补码和移码的定义，可以将补码当作特殊的移码。其bias为2n2^n2n。 各种码制带符号数的范围 浮点数 浮点数使用两个定点数来分别表示实数的尾数（F）和阶码（E）。其一般形式为：N=2E×FN=2^E \\times FN=2E×F。 一个数的浮点表示不是唯一的。小数点位置改变，阶码也随着相应改变。 浮点数所能表示的数值范围主要由阶码决定，所表示数值的精度则由尾数决定。 规格化浮点数： 尾数M≥0M \\ge 0M≥0，其规格化尾数形式为M=0.×××M=0.\\times\\times\\timesM=0.×××，×\\times×可为0也可为1。即MMM限定在了[0.5,1][0.5,1][0.5,1]。 尾数M≤0M \\le 0M≤0，其规格化尾数形式为M=1.×××M=1.\\times\\times\\timesM=1.×××，×\\times×可为0也可为1。即MMM限定在了[−1,−0.5][-1,-0.5][−1,−0.5]。 一般浮点数阶码用R位的移码表示，尾数用M位的补码表示。这种表示的数值范围为： −1×2(2R−1−1)∼+(1−2−M+1)×2(2R−1−1)-1 \\times 2^{(2^{R-1}-1)} \\sim +(1-2^{-M+1}) \\times 2^{(2^{R-1}-1)} −1×2(2R−1−1)∼+(1−2−M+1)×2(2R−1−1) 现在所有通用计算机都采用 IEEE 754 来表示浮点数。IEEE 754 的尾数用原码表示，阶码还是用移码表示。 寻址方式 立即寻址：操作数就包含在指令中。 直接寻址：操作数在内存，指令给出操作数的地址。 寄存器寻址：操作数在寄存器，指令给出操作数的寄存器名（地址）。 寄存器间接寻址：操作数在内存，寄存器存放操作数的地址，指令给出存放操作数地址的寄存器地址。 间接寻址：指令中给出操作数地址（操作数地址在内存中）的地址。 相对寻址：指令地址码给出的是一个偏移量（可正可负），操作数地址等于本条指令的地址加上该偏移量。 变址寻址：操作数地址等于变址寄存器的内容加偏移量。 校验码 码距，是指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。码距为n的编码方案，在该编码方案中任意两个合法编码之间至少有n个二进制位不同。例如值1和2的编码分别为0000 0001和0000 0010他们最后两位不同，所以，码距为2。 一个编码系统的码距≥2\\ge 2≥2时，该编码系统具有检错能力； 一个编码系统的码距≥3\\ge 3≥3时，该编码系统才可能有纠错能力。 即，一个校验码要想能够检错和纠错那么它的码距至少是3。 奇偶校验码 奇偶校验（Parity Codes）是通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）或者为偶数（偶校验）。但该编码只能检错，但不能纠错。 奇偶校验码码距为2。 奇校验：仅检测出代码中奇数位数（奇数个0或1发生错误），不能发现偶数位数出错。偶校验反之。 常用的奇偶校验码有3种：水平奇偶校验码、垂直奇偶校验码和水平垂直校验码。 海明码 海明码（Hamming Code）是一种利用奇偶性来检错和纠错的校验方法。海明码是在数据位之间的特定位置上插入k个校验位，通过扩大码距来实现检错和纠错。设数据位是nnn位，校验位是kkk位，则nnn和kkk必须满足以下关系： 2k−1≥n+k2^k-1 \\ge n+k 2k−1≥n+k 该公式的字面意思为，kkk个校验位的最大值（kkk个校验位都为1），要比海明码的位数（n+kn+kn+k）要大。 海明码的码距为3。 海明码的编码规则如下： kkk个校验位：Pk,Pk−1,⋯ ,P1P_k, P_{k-1}, \\cdots, P_1Pk​,Pk−1​,⋯,P1​。 nnn个数据位：Dn−1,Dn−2,⋯ ,D1,D0D_{n-1}, D_{n-2}, \\cdots, D_1, D_0Dn−1​,Dn−2​,⋯,D1​,D0​。 对应的海明码：Hn+k,Hn+k−1,⋯ ,H1H_{n+k}, H_{n+k-1}, \\cdots, H_1Hn+k​,Hn+k−1​,⋯,H1​。 Hj=Pi,j=2i−1H_j = P_i, j=2^{i-1}Hj​=Pi​,j=2i−1。 数据位依序插入到海明码中剩下的位置。 海明码中任一位都是由若干个校验位来检验： 校验数据位时：被校验的海明位的下标等于所有参与校验该位的校验位的下标之和。 校验位由自身校验。 Example： 偶校验：G4G3G2G1=(0000)2G_4G_3G_2G_1=(0000)_2G4​G3​G2​G1​=(0000)2​则表示数据无错误，否则表示接收到的数据有错误。 若出错，G4G3G2G1G_4G_3G_2G_1G4​G3​G2​G1​的十进制值指出来出错位置。如G4G3G2G1=1010G_4G_3G_2G_1=1010G4​G3​G2​G1​=1010，说明H10(D5)H_{10}(D_5)H10​(D5​)出错，将其取反即可纠错。 奇校验：G4G3G2G1=(1111)2G_4G_3G_2G_1=(1111)_2G4​G3​G2​G1​=(1111)2​则表示数据无错误，否则表示接收到的数据有错误。 循环冗余码 循环冗余校验码（Cyclic Redundancy Check，CRC）广泛应用于数据通信领域和磁介质存储系统中。它利用生成多项式为k个数据位产生个校验位来进行编码，其编码长度为k+r。CRC的代码格式为： 若CRC码的字长为n，又可称其为（n,k）码，则： 左边为信息码（数据），占k位； 右边为校验码，占n-k位。 校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。 在求CRC编码时，采用的是模2运算。模2加减运算的规则是按位运算，不发生借位和进位。 CRC码距为2，可以检错不能纠错。 计算机指令集 RISC精简指令集（计算机） CISC复杂指令集（计算机） 指令种类 少、精简 多、复杂 指令复杂度 低（简单） 高（复杂） 指令长度 固定 变化 寻址方式 少 复杂多样 实现（译码方式） 硬布线控制逻辑（组合逻辑控制器） 微程序控制技术 通用寄存器数量 多、大量 一般 流水线技术 支持 不支持 流水线技术 计算机中的流水线技术（Pipelining）是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行。 若要执行nnn条指令： 顺序执行总时间： 顺序执行总时间=单条指令执行的时间×n顺序执行总时间=单条指令执行的时间\\times n 顺序执行总时间=单条指令执行的时间×n 流水线执行总时间： 流水线执行总时间=一条指令执行的时间+流水线周期×(n−1)流水线执行总时间=一条指令执行的时间+流水线周期 \\times (n-1) 流水线执行总时间=一条指令执行的时间+流水线周期×(n−1) 流水线（操作）周期为执行时间最长的一段操作的时间。 连续输入nnn条指令的吞吐率： 吞吐率=n总执行时间吞吐率=\\cfrac {n}{总执行时间} 吞吐率=总执行时间n​ 如果是流水线的吞吐率，则总执行时间为流水线执行总时间。 流水线的吞吐率是最长流水段操作时间的倒数。即： 最长流水段操作时间=流水线执行总时间n最长流水段操作时间=\\cfrac {流水线执行总时间}{n} 最长流水段操作时间=n流水线执行总时间​ 加速比： 加速比=顺序执行总时间流水线执行总时间加速比 = \\cfrac{顺序执行总时间}{流水线执行总时间} 加速比=流水线执行总时间顺序执行总时间​ 存储器 按存储器所处位置可分为： 内存（主存）：在主机内或主板上，存放机器当前运行所需的程序和数据，以便向CPU提供信息。（相对外存）容量小、速度快。 外存（辅存）：存放当前不参加运行的大量信息，在需要时调入内存。 按存储器的构成材料分类： 磁存储器 半导体存储器 光存储器 按存储器工作方式： 读/写存储器（RAM）。 只读存储器：ROM、PROM、EPROM、EEPROM等。 固定只读存储器（ROM）：厂家生产时就写好数据在其中。只能读（用户）不能写。一般用于存放BIOS和微程序控制。 可编程读只读存储器（PROM）：其内容可以由用户一次性地写入，写入后不能再修改。 按访问方式： 按地址访问： 可分为： 随机存储器 顺序存储器 直接存储器 按内容访问：例如相联存储器。 虚拟存储器由主存与辅存组成。 DRAM（动态随机存储器）构成主存 DRAM需要周期性地刷新保持信息。 SRAM（静态随机存储器）构成Cache（缓存）。 闪存类似U盘，掉电后信息不会丢失。以块为单位进行删除。闪存是EPROM的一种类型，可以代替ROM存储器。闪存不可以代替主存。 缓存 高速缓存用来存放当前最活跃的程序和数据，其特点是： 位于CPU与主存之间；容量一般在几千字节到几兆字节之间； 速度一般比主存快5~10倍，由快速半导体存储器构成； 其内容是主存局部域的副本，对程序员来说是透明的（看不到或可以忽略）。 Cache存储器部分用来存放主存的部分拷贝（副本）信息。控制部分的功能是判断CPU要访问的信息是否在Cache存储器中，若在即为命中，若不在则没有命中。命中时直接对Cache存储器寻址；未命中时，要按照替换原则决定主存的一块信息放到Cache存储器的哪一块里。 缓存地址映射 CPU工作时，送出的是主存单元的地址。为从Cache存储器中读/写信息，就需要将主存地址转成Cache存储器的地址，这种地址转换即为地址映像。 高速缓存中的地址映像方法： 直接映像：主存的块与Cache块的对应关系是固定的。冲突多、关系固定。 全相联映像：允许主存的任一块调入Cache存储器的任一块。冲突少、关系不固定。 组相联映像：将缓存和主存先分为组，组下再分为块。组与组采用直接映像，组内的块采用全相联映像。冲突较少，是直接映像与全相联映像的折中。 发生块冲突从多到少的顺序：直接映像 &gt; 组相联映像 &gt; 全相联映像。 地址映像都是由硬件自动完成。 中断 计算机在执行程序过程中，当遇到急需处理的事件时，暂停当前正在运行的程序，转去执行有关服务程序，处理完后自动返回源程序，这个过程称为中断。 中断是一种非常重要的技术，输入输出设备和主机交换数据、分时操作、实时系统、计算机网络和分布式计算机系统中都要用到这种技术。为了提高响应中断的速度，通常把所有中断服务程序的入口地址（或称为中断向量）汇集为中断向量表。 输入输出控制方式 程序查询方式（程序直接控制方式）： CPU和I/O只能串行工作。CPU需要一直轮询检查，长期处于忙等状态，CPU利用率低。 一次只能读/写一个字。 由CPU将数放入内存。 中断驱动方式： I/O设备通过中断信号主动向CPU报告I/O操作已完成。 CPU和I/O可并行工作。 CPU利用率得到提升。 一次只能读/写一个字。 由CPU将数据放入内存。 DMA方式（直接存储器存储方式）： CPU和I/O可并行工作。 仅在传送数据块多开始和结束时才需要CPU的干预。 由外设直接将数据放入内存。 一次读写的单位为&quot;块&quot;而不是字。 DMA传输数据比中断驱动方式传输数据要快一点。 总线 总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。 采用总线结构主要有以下优点： 简化系统结构，便于系统设计制造； 大大减少了连线数目，便于布线，减小体积，提高系统的可靠性； 便于接口设计，所有与总线连接的设备均采用类似的接口； 便于系统的扩充、更新与灵活配置，易于实现系统的模块化； 便于设备的软件设计； 便于故障诊断和维修，同时也降低了成本。 在计算机系统中采用总线结构，便于实现系统的积木化构造，同时可以减少信息传输线的数量。 微机中的总线分为： 数据总线 地址总线 控制总线 常见总线： ISA总线。 EISA总线。 PCI总线：PCI总线是目前微型机上广泛采用的内总线，采用并行传输方式。 PCI Express 总线。 前端总线。 RS-232C。 SCSI总线：小型计算机系统接口（SCSI）是一条并行外总线。 SATA。 USB。 IEEE-1394。 IEEE-488总线。 地址总线宽度：例如，内存容量4GB，4GB=22+10+10+10B=232B4GB=2^{2+10+10+10}B=2^32B4GB=22+10+10+10B=232B。所以内存单元的地址宽度为32位，即地址总线宽度为32位。 数据总线宽度：例如字长为32的机器，那么其数据总线的宽度要为32。 加密技术与认证技术 加密技术 加密技术用于防止第三方窃听。 对称加密：只有一把密钥。加密和加密用同一把密钥。 密钥分发有缺陷。 加密解密速度很快。 适合加量大量明文数据。 非对称加密： 加密和解密不是同一把密钥。 一共有两把密钥，分别是公钥和私钥。 用公钥加密只能用私钥解密，用私钥加密只能用公钥解密。 不能通过一把密钥推出另一把密钥。 用接收方的公钥加密明文可以实现防止窃听的效果。 密钥分发没有缺陷。 加密解密速度很慢。 认证技术 认证技术用于防止篡改、假冒和否认。 摘要（防止篡改）：将发送的明文进行Hash算法后得到摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的Hash算法得到的摘要进行对比如果一致，侧没有篡改，否则有篡改。 数字签名（防止假冒和否认）： 发送方用自己的私钥对摘要进行签名（加密）。得到数字签名放在密文后一起发送过去。 接收方用发送方的公钥对数字签名进行验证（解密）。如果验证成功则该消息没有被假冒且不能否认，否则该消息的真实性为假冒发送。 数字证书 数字证书是用第三方CA机构使用自己的私钥对用户的公钥签名（加密），来保证这个公钥不被篡改。然后接收方用CA的公钥验证（解密），从而得到用户的公钥。 加密算法 对称密钥（私钥、私有密钥加密）算法（共享密钥加密算法）： DES 3DES RC-5 IDEA AES RC4 非对称密钥（公钥、公开密钥加密）算法： RSA ECC DSA 其他加密算法： Hash函数 SHA-1安全散列算法 MD5摘要算法： 输出结果为128位 摘要算法防止发送的报文被篡改 加密可以阻止被动攻击，认证可以阻止主动攻击（不可以处理被动攻击）。 系统可靠度 ","link":"https://linna-cy.github.io/old-blog/软件设计师_计算机系统/"},{"title":"Redis基础","content":"数据类型 Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型： 字符串 —— string 哈希 —— hash 适合存储对象。 列表 —— list 按照插入顺序排序，可以有重复元素。可以用来做任务队列。 集合 —— set 无序集合，没有重复元素（后插入的元素会覆盖已有的相同元素）。 有序集合 —— sorted set 有序集合（使用分值进行排序），没有重复元素。 常用命令 Redis命令符不区分大小写，但是key是区分大小写的。 更多命令请参考Redis中文网。 字符串操作命令 SET key value 设置指定key的值。 key相同的情况下，后设的值会覆盖前面的值。 GET key 获取指key的值。 SETEX key seconds value 设置指定key的值，并将key的过期时间设为seconds秒。 SETNX key value 只有在key不存在时设置key的值。 如： &gt; SETNX key1 value1 1 &gt; SETNX key1 value2 0 &gt; GET key1 value1 哈希操作命令 Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 HSET key field value 将哈希表key种的字段field的值设为value。 HGET key field 获取存储在哈希表中指定字段的值。 HDEL key field 删除存储在哈希表中的指定字段。 HKEYS key 获取哈希表中所有字段。 HVALS key 获取哈希表中所有值。 HGETALL key 获取在哈希表中指定key的所有字段和值。 列表操作命令 LPUSH key value1 [value2 ...] 将一个或多个值插入到列表头部。 LRANGE key start stop 获取列表指定范围内的元素（start到stop，索引从0开始）。 RPOP key 移除并获取列表最后一个元素。 LLEN key 获取列表长度。 BRPOP key1 [key2 ...] timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时（timeout秒）或（在指定的key中）发现可弹出元素为止。 集合操作命令 Redis set是string类型的无序集合，集合成员是唯一的。 SADD key member1 [member2 ...] 向集合添加一个或多个成员。 SMEMBERS key 返回集合中的所有成员。 SCARD key 获取集合的成员数。 SINTER key1 [key2 ...] 返回给定所有集合的交集。 SUNION key1 [key2 ...] 返回所有给定集合的并集。 SDIFF key1 [key2 ...] 返回给定所有集合的差集（左差集，即key1集合中在其他集合没有的元素集合）。 SREM key member1 [member2 ...] 移除集合中一个或多个成员。 有序集合操作命令 Redis sorted set 是string类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数（score）。Redis通过分数来为集合中的成员进行从小到大排序，有序集合的成员是唯一的，但分数却可以重复。 ZADD key score1 member1 [score2 member2 ...] 向有序集合添加一个或多个成员，或者更新已存在成员的分数。 ZRANGE key start stop [WITHSCOES] 通过索引区间返回有序集合中指定区间内的成员。使用WITHSCOES可以返回成员的分数。 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量increment。 ZREM key member [member ...] 移除有序集合中的一个或多个成员。 通用命令 KEYS pattren 查找所有符合给定模式（pattern）的key。 EXISTS key 检查给定key是否存在。 TYPE key 返回key所存储的值的类型。 TTL key 返回给定key的剩余生存时间（TTL，time to live），以秒为单位。 DEL key1 [key2 ...] 该命令用于在key存在时删除key。 如： &gt; TTL key -1 返回-1表示永久存活。 切换数据库 Redis 默认是在0号数据库中执行操作。如果想要切换数据库，可以使用： SELECT number 如： 127.0.0.1:6379&gt; SELECT 1 OK 127.0.0.1:6379[1]&gt; Redis 默认提供了16个数据库。 要修改该配置可以在redis.conf中修改databases的数量。 databash 16 Spring Data Redis 配置 application.yml： spring: application: name: springdataredis-demo # Redis相关配置 data: redis: host: localhost port: 6379 password: 123456 database: 0 # 操作0号数据库 jedis: # Redis连接池配置 pool: max-active: 8 # 最大连接数 max-wait: 1ms # 连接池最大阻塞等待时间 max-idle: 4 # 连接池中的最大空闲连接 min-idle: 0 # 连接池中的最小空闲连接 配置类（修改默认序列化器，防止因序列化在Redis上产生乱码，但并不妨碍读值。因为读取时会自动反序列化）： @Configuration public class RedisConfig extends CachingConfigurerSupport { @Bean public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // 默认的Key序列化器为：JdkSerializationRedisSerializer redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(connectionFactory); return redisTemplate; } } 测试 @SpringBootTest @RunWith(SpringRunner.class) public class SpringDataRedisTest { @Autowired private RedisTemplate redisTemplate; /** * 操作字符串类型数据 */ @Test public void testString() { // 获得String类型数据操作对象 ValueOperations valueOperations = redisTemplate.opsForValue(); valueOperations.set(&quot;city&quot;, &quot;guangzhou&quot;); String city = (String) valueOperations.get(&quot;city&quot;); System.out.println(city); // 设置超时 valueOperations.set(&quot;key1&quot;, &quot;value1&quot;, 10L, TimeUnit.SECONDS); // 不存在才设置 Boolean setIfAbsent1 = valueOperations.setIfAbsent(&quot;city&quot;, &quot;foshang&quot;); System.out.println(Boolean.TRUE.equals(setIfAbsent1) ? &quot;city设置成功&quot; : &quot;city已存在&quot;); Boolean setIfAbsent2 = valueOperations.setIfAbsent(&quot;city_name&quot;, &quot;foshang&quot;, 10L, TimeUnit.SECONDS); Object cityName = valueOperations.get(&quot;city_name&quot;); System.out.println(setIfAbsent2 ? &quot;city_name设置成功:&quot; + cityName : &quot;city_name已存在&quot;); } /** * 操作哈希类型数据 */ @Test public void testHash() { HashOperations hashOperations = redisTemplate.opsForHash(); String id = &quot;002&quot;; // 存值 hashOperations.put(id, &quot;name&quot;, &quot;xiaoming&quot;); hashOperations.put(id, &quot;age&quot;, &quot;20&quot;); hashOperations.put(id, &quot;address&quot;, &quot;guangzhou&quot;); // 取值 String name = (String) hashOperations.get(id, &quot;name&quot;); String age = (String) hashOperations.get(id, &quot;age&quot;); String address = (String) hashOperations.get(id, &quot;address&quot;); System.out.println(&quot;name:&quot; + name + &quot;,age:&quot; + age + &quot;,address:&quot; + address); // 获取hash结构中的所有字段 Set keys = hashOperations.keys(id); for (Object key : keys) { System.out.println(key); } // 删除 //hashOperations.delete(keys, &quot;address&quot;, &quot;age&quot;); // 获得hash结构中的所有值 List&lt;String&gt; values = hashOperations.values(id); for (String value : values) { System.out.println(value); } } /** * 操作列表类型数据 */ @Test public void testList() { ListOperations listOperations = redisTemplate.opsForList(); String key = &quot;mylist&quot;; // 存储 listOperations.leftPush(key, &quot;a&quot;); listOperations.leftPushAll(key, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;); // 取值 System.out.printf(&quot;入队：&quot;); List&lt;String&gt; myList = listOperations.range(key, 0, -1); for (String s : myList) { System.out.printf(s + &quot; &quot;); } System.out.println(); // 获得列表长度 llen int size = listOperations.size(key).intValue(); System.out.printf(&quot;出队：&quot;); for (int i = 0; i &lt; size; i++) { // 出队列 String element = (String) listOperations.rightPop(key); System.out.printf(element + &quot; &quot;); } System.out.println(); } /** * 操作集合类型数据 */ @Test public void testSet() { SetOperations setOperations = redisTemplate.opsForSet(); String key = &quot;myset&quot;; // 存值 setOperations.add(key, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;); // 取值 Set&lt;String&gt; myset = setOperations.members(key); for (String s : myset) { System.out.printf(s + &quot; &quot;); } System.out.println(); // 删除成员 setOperations.remove(key, &quot;a&quot;, &quot;b&quot;); // 取值 myset = setOperations.members(key); for (String s : myset) { System.out.printf(s + &quot; &quot;); } System.out.println(); } /** * 操作有序集合类型数据 */ @Test public void testZset() { ZSetOperations zSetOperations = redisTemplate.opsForZSet(); String key = &quot;myZset&quot;; // 存储 zSetOperations.add(key, &quot;a&quot;, 10.); zSetOperations.add(key, &quot;b&quot;, 11.); zSetOperations.add(key, &quot;c&quot;, 12.); zSetOperations.add(key, &quot;d&quot;, 13.); zSetOperations.add(key, &quot;a&quot;, 14.); // 取值 Set&lt;String&gt; range = zSetOperations.range(key, 0, -1); for (String s : range) { System.out.printf(s + &quot; &quot;); } System.out.println(); // 修改分数 zSetOperations.incrementScore(key, &quot;b&quot;, 20.); // 删除成员 zSetOperations.remove(key, &quot;a&quot;, &quot;c&quot;); // 取值 range = zSetOperations.range(key, 0, -1); for (String s : range) { System.out.printf(s + &quot; &quot;); } System.out.println(); } /** * 通用操作 */ @Test public void testCommon() { // 获取Redis中所有key Set&lt;String&gt; keys = redisTemplate.keys(&quot;*&quot;); for (String key : keys) { System.out.println(key); } // 判断m某个key是否存在 Boolean hasKey = redisTemplate.hasKey(&quot;linner&quot;); System.out.println(hasKey ? &quot;linner存在&quot; : &quot;linner不存在&quot;); // 删除指定key redisTemplate.delete(&quot;myZset&quot;); // 获取指定key对应的value的数据类型 DataType dataType = redisTemplate.type(&quot;myset&quot;); System.out.println(dataType.name()); } } ","link":"https://linna-cy.github.io/old-blog/Redis基础/"},{"title":"MyBatisPlus","content":"简介 MybatisPlus（简称MP）是基于MyBatis框架基础上开发的增强型工具（依然可以使用MyBatis里的工具），旨在简化开发、提供效率。更多详情请访问MyBatisPlus官网（官网有两个地址，https://mp.baomidou.com/或https://mybatis.plus）。 基于Spring使用MybatisPlus，在构建Spring工程时需要勾选MySQL和MyBatis相关技术。由于Spring并未收录MP，所以需要手动导入坐标： &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 可选： --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; 在application.yml（配置文件）中配置数据库信息： spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=Asia/Shanghai username: root password: root DAO接口 使用MP编写DAO接口，可以直接继承BaseMapper&lt;&gt;（该接口内置了许多DAO方法）： @Mapper public interface UserDao extends BaseMapper&lt;User&gt;{ } 编写引导类： @SpringBootApplication public class MybatisplusApplication { public static void main(String[] args) { SpringApplication.run(MybatisplusApplication.class, args); } } DAO接口要想被容器扫描到，有两种方案： 在DAO接口上添加@Mapper注解，并且确保DAO处在引导类所在包或其子包中。 在引导类上添加@MapperScan注解，其属性为所要扫描的DAO所在包：@MapperScan(&quot;com.linner.dao&quot;)（可以不写@Mapper）。 ","link":"https://linna-cy.github.io/old-blog/MyBatisPlus/"},{"title":"Maven 高级","content":"多模块开发 多模块开发有以下两种： 按照功能拆分。 按照模块拆分。 例如，将项目中的DAO类拆分出来作为一个独立的模块。然后使用Maven将该模块作为依赖导入项目中。 假设现在已经将项目中的实体类拆分出来作为maven-dao模块。该模块也使用Maven构建，然后导入该项目所需依赖。经过测试后，将该项目的&lt;groupId&gt;、&lt;artifactId&gt;和&lt;version&gt;导入原本项目。 maven-dao模块的pom.xml中： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- ... --&gt; &lt;!-- 将下面内容作为依赖导入到原项目中 --&gt; &lt;groupId&gt;com.linner&lt;/groupId&gt; &lt;artifactId&gt;springmvc-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- END --&gt; &lt;!-- ... --&gt; &lt;/project&gt; 将上方&lt;groupId&gt;、&lt;artifactId&gt;和&lt;version&gt;导入原项目： &lt;dependencies&gt; &lt;!-- ... --&gt; &lt;dependency&gt; &lt;groupId&gt;com.linner&lt;/groupId&gt; &lt;artifactId&gt;springmvc-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ... --&gt; &lt;/dependencies&gt; 接着使用Maven的install命令将maven-dao模块安装到Maven本地仓库中，项目即可正常启动。 依赖管理 依赖传递 Maven项目中的依赖是具有传递性的。即，依赖的依赖可以作为依赖使用。将依赖关系作为树状结构看待，那么依赖的子孙依赖，也可以作为项目的依赖。 依赖传递有直接依赖和间接依赖。 直接依赖： 在pom.xml中编写的依赖就是该项目的直接依赖。即，依赖树中，子依赖（子节点）即为当前项目（根节点）的直接依赖。 间接依赖： 依赖树中，直接依赖下的所有依赖（孙子节点）即为当前项目的间接依赖。 因为依赖传递的存在，会导致使用依赖的过程中出现冲突问题。例如有两个相同的依赖，它们的版本不同，就会导致依赖冲突。 Maven指定了一系列规则来解决依赖冲突问题。 特殊优先：同级下（依赖树中同个父节点的依赖为同级，即同个pom.xml下），配置了相同资源的不同版本，后配置的覆盖先配置。 路径优先：依赖树中，层级越浅，优先级越高；层级越深，优先级越低。 声明优先：资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。即，谁先声明用谁。 注意：依赖的优先级只对当前项目起作用。即，当前项目选择的依赖版本并不会影响到依赖中相同资源不同版本的依赖。 最终选择的依赖结果根据Idea中Mavem面板的依赖树视图。 可选依赖 可选依赖指对外隐藏当前所依赖的资源（不透明），隐藏后对应资源将不具有依赖传递。 可选依赖的开关使用&lt;optional&gt;。如： ``xml xxx.xxxxxx xxxxx-xxxxxx x.x.x true ## 排除依赖 排除依赖指主动断开依赖的资源，被排除的资源无需指定版本（不需要）。即，在当前项目中，排除依赖中不需要的间接依赖。 排除依赖使用`&lt;exclusions&gt;`来指定一个排除的依赖列表。列表中使用`&lt;exclusion&gt;`来指定要排除的依赖。如： ```xml &lt;dependency&gt; &lt;groupId&gt;xxx.xxxxxx&lt;/groupId&gt; &lt;artifactId&gt;xxxxx-xxxxxx&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;yyy.yyyyyy&lt;/groupId&gt; &lt;artifactId&gt;yyyyy-yyyyyyy&lt;/artifactId&gt; &lt;!-- 排除依赖不需要指定版本 --&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 聚合工程 聚合即为将多个模块组织成一个整体，同时进行项目构建的过程。聚合工程通常是一个不具有业务功能的&quot;空&quot;工程（有且仅有一个pom文件）。使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建。当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。 Example： 创建一个空的Maven项目，并将其打包方式设置为pom，然后添加所要管理的项目： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.linner&lt;/groupId&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 设置管理的模块名称 --&gt; &lt;modules&gt; &lt;!-- module里面的值为管理模块的相对路径 --&gt; &lt;module&gt;../xxxx&lt;/module&gt; &lt;module&gt;../yyyy&lt;/module&gt; &lt;module&gt;../zzzz&lt;/module&gt; &lt;/modules&gt; &lt;/project&gt; 当该maven-parent被compile后，所有被其管理的项目都会被执行编译操作。 聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。 继承 继承是用来解决重复配置问题。继承描述的是两个工程间的关系子工程可以继承父工程中的配置信息，常见于依赖关系的继承。继承的作用：简化配置、减少版本冲突。 一般继承和聚合都是使用同一个空项目来构建，但是这两个的功能是不一样的。 在子工程中配置当前工程继承自parent工程： &lt;!-- 在project下配置 --&gt; &lt;parent&gt; &lt;groupId&gt;com.linner&lt;/groupId&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt; &lt;!--设置父项目pom.xml位置路径--&gt; &lt;relativePath&gt;../maven-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; 将子项目共同使用的依赖都抽取出来，维护在父项目的pom.xml中： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.linner&lt;/groupId&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;../xxxx&lt;/module&gt; &lt;module&gt;../yyyy&lt;/module&gt; &lt;module&gt;../zzzz&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 子项目依赖版本问题 如果把所有用到的依赖都管理在父项目的pom.xml，这样就会导致有很多项目引入了过多自己不需要的依赖，这样对于子项目来说也是种负担。 可以在父工程中使用&lt;dependencyManagement&gt;来定义依赖管理： &lt;!-- 在project下配置 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencyManagement&gt;标签不真正引入jar包，而是配置可供子项目选择的jar包依赖。 如果子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定&lt;version&gt;： &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 子项目使用的jar包version由父项目决定。 属性 Maven属性的概念和变量的概念很相似。在一个地方声明，其他地方使用，当属性的声明修改后，所有使用属性的地方都会跟着修改。 在Maven中的属性分为: 自定义属性。 内置属性。 使用mvn help:system命令查看。 Setting属性。 Java系统属性。 环境变量属性。 自定义属性 在父工程中使用&lt;properties&gt;定义属性： 5.2.10.RELEASE 4.12 1.3.0 定义属性标签的名称可以自定义，如&lt;spring.version&gt;也可以修改为&lt;spring-version&gt;。 接着修改依赖的version： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; 使用${属性名}来使用属性。 配置文件加载属性 属性也可以作用于其他配置文件中（如jdbc.properties）。 先在父工程中定义属性，并且设置Maven过滤文件范围： &lt;properties&gt; &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/spring_db&lt;/jdbc.url&gt; &lt;/properties&gt; &lt;!-- ... --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 设置资源目录（相对路径） --&gt; &lt;directory&gt;../xxxx/src/main/resources&lt;/directory&gt; &lt;!-- 设置是否能够解析${}，默认是false --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 修改jdbc.properties（属性值的使用方式与pom.xml中相同）： jdbc.driver=com.mysql.jdbc.Driver jdbc.url=${jdbc.url} jdbc.username=root jdbc.password=root 如果需要在多个项目中解析属性值，可以使用${project.basedir}（Maven的内置系统属性）来简化书写： &lt;build&gt; &lt;resources&gt; &lt;!-- ${project.basedir}: 表示当前项目所在目录 子项目继承了父项目，相当于所有的子项目都添加了资源目录的过滤 --&gt; &lt;resource&gt; &lt;directory&gt;${project.basedir}/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 忽略 web.xml 检查 或者在 src\\main\\webapp\\WEB-INF\\ 添加一个 web.xml 文件 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;configuration&gt; &lt;!-- 忽略 web.xml 检查 --&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 使用mvn help:system命令可以查看更多的内置属性。 版本管理 SNAPSHOT（快照版本）： 项目开发过程中临时输出的版本，称为快照版本。 快照版本会随着开发的进展不断更新。 RELEASE（发布版本）： 项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的。 即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本。 alpha（内测版）：Bug多、不稳定、内部版本不断添加新功能。 beta（公测版）：不稳定（相对比alpha稳定些），Bug相对较多不断添加新功能。 纯数字版本。 多环境开发 Maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。 在父工程中配置多个环境，并指定默认激活环境： &lt;profiles&gt; &lt;!--开发环境--&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/spring_db&lt;/jdbc.url&gt; &lt;/properties&gt; &lt;activation&gt; &lt;!-- 设定是否为默认启动环境 --&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;!--生产环境--&gt; &lt;profile&gt; &lt;id&gt;pro&lt;/id&gt; &lt;properties&gt; &lt;jdbc.url&gt;jdbc:mysql://127.2.2.2:3306/spring_db&lt;/jdbc.url&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!--测试环境--&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;jdbc.url&gt;jdbc:mysql://127.3.3.3:3306/spring_db&lt;/jdbc.url&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 动态切换配置环境可以使用Maven的-P参数来指定，参数值为环境id： mvn install -P test 跳过测试 在执行install指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行test。test可以确保每次打包或者安装的时候，程序的正确性。 但是，假如测试已经通过，在没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。或者，功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。此时就需要跳过测试： Idea工具可以实现跳过测试（Maven面板中带闪电图标的按钮）。 在父工程中的pom.xml中添加测试插件配置： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.12.4&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;!--排除掉不参与测试的内容--&gt; &lt;excludes&gt; &lt;exclude&gt;**/BookServiceTest.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;configuration&gt;中有如下标签： skipTests：如果为true，跳过所有测试；为false，不跳过测试。 excludes：不参与测试的测试类，针对skipTests为false来设置的。 includes：参与测试的测试类，针对skipTests为true来设置的。 命令跳过测试： mvn 指令 -D skipTests 执行的项目构建指令必须包含测试生命周期，否则无效果。 命令需要在pom.xml所在目录下进行执行。 ","link":"https://linna-cy.github.io/old-blog/Maven高级/"},{"title":"SpringBoot 基础","content":"SpringBoot 简介 SpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化 Spring 应用的初始搭建以及开发过程。 SpringBoot开发分为如下几步： 创建新模块，选择Spring初始化，并配置模块相关基础信息。 选择当前模块需要使用的技术集。 开发控制器类。 运行自动生成的Application类。 项目创建及配置 创建项目 注意： 在创建好的工程中不需要创建配置类。 创建好的项目会自动生成其他的一些文件（这些文件目前来说没有任何作用），可以将这些文件删除。 可以删除的目录和文件如下： .mvn .gitignore HELP.md mvnw mvnw.cmd 项目依赖 在项目中的pom.xml中有如下代码： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 该代码指定了一个父工程，父工程中的东西在该工程中可以继承过来使用。 并且使用Spring Initializr创建的项目会自动在pom.xml中导入所需的起步依赖（包含starter的依赖）。 引导类 创建的每个SpringBoot项目都包含一个引导类，如： @SpringBootApplication public class SpringbootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringbootDemoApplication.class, args); } } 引导类是项目的入口，运行main()就可以启动项目。 引导类默认只会扫描当前包下同级的类和包（包下的的类）。 如果Controller包与引导类的包同级（例如com.linner.controller与com.linner.springbootdemo），此时引导类可以正常启动，但是由于扫描不到Cotroller包，接口无法访问。有三种解决方法： 将Controller包移动到引导类的包下（此处为springbootdemo）。 将引导类移动到项目组包下（此处为com.linner）。 在创建工程时，修改软件包名。 Spring Initializr默认软件包名为项目组名.项目名（此处为com.linner.springbootdemo）。此处创建的项目将其修改为项目组名（com.linner）。 切换 Web 服务器 如果要使用Jetty服务器，我们需要先在pom.xml中使用&lt;exclusion&gt;标签排除默认的Tomcat服务器，然后再导入使用Jetty服务器所需的坐标： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; 配置文件 SpringBoot有两种配置文件格式，它们都在resources目录下： properties格式： 文件名为application.properties，格式如下： # 端口 server.port=81 # 访问路径 server.servlet.context-path=/ yaml格式： 文件名为application.yml或application.yaml，格式如下： server: # 端口 port: 80 servlet: # 访问路径 context-path: / yaml格式的键值对中，键后面的冒号后（值的前面）一定要加空格。 SpringBoot程序的配置文件必须是application，只是后缀名不同。 以上三个配置文件可以同时存在，它们的优先级从高到低为： application.properties application.yml application.yaml Idea可以快速地编辑配置文件： yaml 语法 大小写敏感。 属性层级关系使用多行描述，每行结尾使用冒号结束。 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）。 空格的个数并不重要，只要保证同层级的左侧对齐即可。 属性值前面添加空格（属性名与属性值之间使用:+空格作为分隔）。 # 表示注释。 数据前面要加空格与冒号隔开。 数组数据在数据书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔。如： list: - Java - Spring 读取配置数据 使用@Value(&quot;表达式&quot;)可以从配置文件中读取数据，注解中用于读取属性名引用方式是：${一级属性名.二级属性名……}。如： @RestController public class MyController { @Value(&quot;${server.port}&quot;) private Integer port; @Value(&quot;${list[0]}&quot;) private String java; @GetMapping(&quot;/config&quot;) public String gerConfig() { return &quot;port=&quot; + this.port + &quot;\\n&quot; + this.java; } } SpringBoot还可以使用 @Autowired 注解注入 Environment 对象的方式读取数据。这种方式 SpringBoot 会将配置文件中所有的数据封装到 Environment 对象中，如果需要使用哪个数据只需要通过调用 Environment 对象的 getProperty(String name) 方法获取。如： @RestController public class MyController { @Autowired private Environment env; @GetMapping(&quot;/config&quot;) public String gerConfig() { return &quot;port=&quot; + env.getProperty(&quot;server.port&quot;); } } 自定义对象 SpringBoot提供了将配置文件中的数据封装到我们自定义的实体类对象中的方式。具体操作如下： 在实体类上添加@Component注解。 表示将实体类 bean 的创建交给 Spring 管理。 使用 @ConfigurationProperties 注解表示加载配置文件。 在该注解中也可以使用 prefix 属性指定只加载指定键的数据。 在Controller中进行注入。 Example： 添加依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 在配置文件中添加： myconfig: name: SpringBoot port: 80 id: 666 实体类： @Component @ConfigurationProperties(prefix = &quot;myconfig&quot;) public class MyConfig { private String name; private Integer id; private Integer port; // getter and setter... } Controller： @RestController public class MyController { @Autowired private MyConfig myConfig; @GetMapping(&quot;/myconfig&quot;) public MyConfig getMyConfig() { return this.myConfig; } } 多环境配置 由于开发环境、测试环境、生产环境的配置都不相同。所以SpringBoot给开发者提供了多环境的快捷配置，需要切换环境时只需要改一个配置即可。 yaml格式： # 开发 spring: config: activate: # 配置环境名 on-profile: dev # spring.profiles 配置已弃用 server: port: 80 --- # 生产 spring: config: activate: on-profile: pro #给生产环境起的名字 server: port: 81 --- # 测试 spring: config: activate: on-profile: test #给测试环境起的名字 server: port: 82 --- # 设置启用的环境 spring: profiles: active: test #表示使用的是开发环境的配置 properties格式： 使用多文件方式，文件名以application-开头。如： application-dev.properties： server.port=80 application-pro.properties： server.port=81 application-test.properties： server.port=82 SpringBoot只会默认加载名为 application.properties 的配置文件，所以需要在 application.properties 配置文件中设置启用哪个配置文件。如： spring.profiles.active=pro SpringBoot提供了在运行jar时设置开启指定的环境的方式。如： java –jar springbootdemo.jar –-spring.profiles.active=test 临时修改端口号： java –jar springbootdemo.jar –-server.port=88 命令行设置的端口号优先级高于配置文件。 SpringBoot官网已经对配置的优先级进行了说明： 配置文件分类 SpringBoot定义了配置文件不同的放置的位置。而放在不同位置的优先级是不同的。SpringBoot中4级配置文件放置位置： classpath：application.yml classpath：config/application.yml file：application.yml file：config/application.yml 级别越高优先级越高。 第三方资源整合 整合 Junit SpringBoot整合Junit分为三步： 在测试类上添加 @SpringBootTest 注解。 使用 @Autowired 注入要测试的资源。 定义测试方法进行测试。 Example： 编写Service： @Service public class BookService { public void save() { System.out.println(&quot;Book save ...&quot;); } } 编写Test类： @SpringBootTest class SpringbootDemoApplicationTests { @Autowired private BookService bookService; @Test public void testSave() { bookService.save(); } } 由于引导类默认扫描当前包下的类和包，所以测试类（或者测试类的包）和引导类要在同个包下。 否则，可以使用@SpringBootTest注解的classes属性指定引导类的字节码对象。如：@SpringBootTest(classes = SpringbootDemoApplication.class) 整合 MyBatis 在整合MyBatis前先建一个用于测试的数据库： SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- Table structure for book_tb DROP TABLE IF EXISTS `book_tb`; CREATE TABLE `book_tb` ( `id` int NOT NULL, `name` varchar(255) CHARACTER SET utf8mb3 COLLATE utf8mb3_bin NOT NULL, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb3 COLLATE = utf8mb3_bin ROW_FORMAT = Dynamic; -- Records of book_tb INSERT INTO `book_tb` VALUES (1, '郑嘉伦'); INSERT INTO `book_tb` VALUES (2, '钱璐'); INSERT INTO `book_tb` VALUES (3, '黄安琪'); INSERT INTO `book_tb` VALUES (4, '龙宇宁'); INSERT INTO `book_tb` VALUES (5, '姜宇宁'); INSERT INTO `book_tb` VALUES (6, '赵嘉伦'); SET FOREIGN_KEY_CHECKS = 1; 导入依赖： 在创建项目时，通过Spring Initializr导入依赖： 在pom.xml中导入坐标： &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 编写数据库配置： spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/spring_db username: root password: 123456 SpringBoot版本低于2.4.3（不含），Mysql驱动版本大于8.0时，需要在url连接串中配置时区 jdbc:mysql://localhost:3306/spring_db?serverTimezone=UTC，或在MySQL数据库端配置时区解决此问题。 定义实体类： public class Book { private Integer id; private String name; // getter、setter and toString } 定义DAO接口： @Mapper // SpringBoot定义DAO接口类 public interface BookDao { @Select(&quot;SELECT * FROM book_tb WHERE id = #{id}&quot;) public Book getById(Integer id); } 定义Test类： @SpringBootTest class SpringbootMybatisApplicationTests { @Autowired private BookDao bookDao; @Test public void testGetById() { Book book = bookDao.getById(1); System.out.println(book); } } 使用 Druid 数据源 SpringBoot有默认的数据源，但是也可以指定使用Druid数据源。 导入Druid依赖： &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; 在application.yml配置文件配置： spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/spring_db?serverTimezone=UTC username: root password: 123456 type: com.alibaba.druid.pool.DruidDataSource ","link":"https://linna-cy.github.io/old-blog/SpringBoot基础/"},{"title":"SpringMVC 基础","content":"简介 SpringMVC是Spring下的一个用于Web表现层开发的技术。相比Servlet，SpringMVC更加高效快捷。 SpringMVC流程如下： 浏览器发送请求到Tomcat服务器； Tomcat接收请求后，将请求交给SpringMVC中的DispatcherServlet（前端控制器）来处理。 DispatcherServlet按照对应规则将请求分发到对应的Bean。 Bean由我们自己编写来处理不同的请求。 每个Bean中可以处理一个或多个不同的请求URL。 DispatcherServlet和Bean对象都需要交给Spring容器来进行管理。 综上，我们需要编写的内容为： Bean对象； 请求URL和Bean对象对应关系的配置； 构建Spring容器。 将DispatcherServlet和Bean对象交给容器管理。 配置Tomcat服务器。 使Tomcat能够识别Spring容器，并将请求交给容器中的DispatcherServlet来分发请求。 项目的基本实现步骤如下： 创建Web工程（Maven结构），并在工程的pom.xml中添加SpringMVC和Servlet坐标。 创建SpringMVC控制器类（等同于Servlet功能）。 初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的Bean。 初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求。 项目结构及基础环境配置 使用SpringMVC开发的项目结构如下： 📁project-file-name 📁src 📁main 📁java 📁com.linner 📁config —— 配置类 📁controller —— 表现层 📁dao —— 持久层 📁domain —— 实体类 📁service —— 业务层 📁resourcs 📁webapp 这种项目结构采用了SSM架构，即： 表现层； 持久层； 业务层。 通过IDEA创建SpringMVC项目步骤如下： 创建基础的Maven-Archetype-Webapp项目。 补全项目结构： 📁src 📁main 📁java 📁resourcs 📁webapp 修改pom.xml文件： 将多余的内容删除，然后添加SpringMVC所需的依赖。如： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.linner&lt;/groupId&gt; &lt;artifactId&gt;springmvc-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- SpringMVC所需依赖的坐标： --&gt; &lt;!-- Servlet坐标： --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;!-- Servlet需要修改作用范围，否则会与Tomcat中的servlet-api包发生冲突 --&gt; &lt;!-- provided代表的是该包只在编译和测试的时候用 --&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- SpringMVC坐标： --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 项目环境 使用SpringMVC构建Web项目，除了以上基础配置外，还需要导入其他配置。 DAO相关的坐标： &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 配置类 jdbc.properties（数据库配置，放在项目中resources目录下）： jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql:///spring_db?useSSL=false&amp;characterEncoding=utf-8 jdbc.username=root jdbc.password=root SpringMVC项目至少需要SpringConfig和SpringMvcConfig这两个配置类。 Spring：控制业务（Service）和功能（DataSource、SqlSessionFactoryBean、 MapperScannerConfigurer等）相关的Bean。 SpringMVC：加载表现层Bean（Controller）。 SpringConfig（启动Tomcat服务器时加载Spring配置类）： @Configuration @ComponentScan({&quot;com.linner.service&quot;}) @PropertySource(&quot;classpath:jdbc.properties&quot;) @Import({JdbcConfig.class,MyBatisConfig.class}) @EnableTransactionManagement public class SpringConfig { } Spring需要管理的是service包和dao包。但dao包最终是交给MapperScannerConfigurer对象来进行扫描处理的。所以SpringConfig只需要扫描到service包即可。 演示@ComponentScan的另一种用法（排除controller包中的Bean）： @ComponentScan(value=&quot;com.linner&quot;, excludeFilters=@ComponentScan.Filter( type = FilterType.ANNOTATION, classes = Controller.class // 排除@Controller定义的Bean ) ) 上面方法本质是使用@ComponentScan的excludeFilters属性设置过滤规则。 type：设置排除规则。 ANNOTATION：按照注解排除。 ASSIGNABLE_TYPE：按照指定的类型过滤。 ASPECTJ：按照Aspectj表达式排除（基本上不会用）。 REGEX：按照正则表达式排除。 CUSTOM：按照自定义规则排除。 classes：设置排除的具体注解类。 SpringMvcConfig @Configuration @ComponentScan(&quot;com.linner.controller&quot;) public class SpringMvcConfig { } DAO相关配置类： JdbcConfig： public class JdbcConfig { @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; @Bean public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager ds = new DataSourceTransactionManager(); ds.setDataSource(dataSource); return ds; } } MyBatisConfig： public class MyBatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); factoryBean.setTypeAliasesPackage(&quot;com.linner.domain&quot;); return factoryBean; } @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.linner.dao&quot;); return msc; } } ServletConfig（Web项目入口配置类）： public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{&quot;/&quot;}; } } SpringMVC 工作流程 SpringMVC的使用过程共分两个阶段： 启动服务器初始化过程； 服务器启动，执行ServletConfig类，初始化Web容器。 根据getServletConfigClasses获取所需的SpringMVC配置类（这里是SpringMvcConfig）来初始化SpringMVC的容器。 加载SpringMvcConfig配置类。 执行@ComponentScan加载对应的Bean。 扫描指定包下所有类上的注解，将所有的Controller类（如有@Controller、@RestController等注解的类）加载到容器中。 加载每一个Controler。 使用@RequestMapping建立请求路径与Controler中的方法的对应关系。 执行getServletMappings方法，定义所有的请求都通过SpringMVC。如： protected Spring[] getServletMappings() { return new Spring[]{&quot;/&quot;}; } /代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求。 单次请求过程。 根据请求路径发送请求。 Web容器将符合设置的请求路径的请求交给SpringMVC处理。 解析请求路径。 执行匹配对应请求路径的方法。 将有@ResponseBody方法的返回值作为响应体返回给请求方。 请求与响应 SpringMVC是Web层的框架，主要作用是接收请求、接收数据、响应结果。 编写Controller只需要在Controller类上使用@Controller注解即可。 接收 URL 参数 接收URL参数，GET和POST请求的编写方式一致。 如果要使用不同的方式接收请求，可以修改@RequestMapping注解： @RequestMapping(value = &quot;/save&quot;, method = RequestMethod.GET) 普通参数 @Controller @RequestMapping(&quot;/user&quot;) public class UserController { // 使用 [http://localhost/user/hello?name=张三] 访问 // 返回响应体 Hello 张三! @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello(String name) { return &quot;Hello &quot; + name + &quot;!&quot;; } // 使用 [http://localhost/user/login?name=张三&amp;password=abc] 访问 // 返回响应体 OK，终端输出 userName=张三; password=abc @RequestMapping(&quot;/login&quot;) @ResponseBody public String login(@RequestParam(&quot;name&quot;) String userName, String password) { System.out.println(&quot;userName=&quot; + userName + &quot;; password=&quot; + password); return &quot;OK&quot;; } } 请求路径（@RequestMapping）： 请求路径使用@RequestMapping注解。注解中的值为请求路径。 @RequestMapping可以作用在类和方法上。 方法上定义的@RequestMapping是具体的请求路径。即，如果在方法上使用了@RequestMapping并且没有在类上使用@RequestMapping，那么该方法的请求路径即为方法上@RequestMapping中的值。 类上定义的@RequestMapping是请求目录。即，如果在方法和类上均使用了@RequestMapping，那么该方法的请求路径需要加上类@RequestMapping注解中定义的目录。例如上方代码中的请求路径为/user/hello和。 请求参数： 普通参数即URL地址传参。 定义相同的地址参数名与方法形参变量名即可接收参数。 如果想要形参名与地址参数名不同则可使用@RequestParam注解定义地址参数名（如login()）。 如果有多个请求参数则定义多个方法参数。 返回值： 返回值使用@ResponseBody注解后直接在方法中使用return返回。这里注解@ResponseBody是指将返回值作为响应体。 POJO类型参数 使用POJO类型接收参数，只需要让请求参数名与形参对象属性名相同即可。如果有嵌套的POJO参数，请求参数名与形参对象属性名相同，然后按照对象层次结构关系即可接收。 定义一个POJO类： public class Address { private String province; private String city; // setter、getter and toString... } public class User { private Integer id; private String name; private String password; private Address address; // setter、getter and toString... } Controller： @Controller @RequestMapping(&quot;/user&quot;) public class UserController { // 访问 [http://localhost/user/login?id=123&amp;password=abc&amp;name=张三&amp;address.province=广东&amp;address.city=广州] // 返回响应体 OK，终端输出 Login: User{id=123, name='张三', password='abc', address=Address{province='广东', city='广州'}} @RequestMapping(&quot;/login&quot;) @ResponseBody public String login(User user) { System.out.println(&quot;Login: &quot; + user); return &quot;OK&quot;; } } 数组、集合类型参数 接收数组参数只需让请求参数名与形参名相同且请求参数为多个即可（形参为数组类型）。 @Controller @RequestMapping(&quot;/user&quot;) public class UserController { // 访问 [http://localhost/user/setHobbies?id=123&amp;hobbies=唱歌,跳舞,Rap,打篮球] // 返回响应体 OK，终端输出 User 123's hobbyies: [唱歌, 跳舞, Rap, 打篮球] @RequestMapping(&quot;/setHobbies&quot;) @ResponseBody public String setHobbies(Integer id, String[] hobbies) { System.out.println(&quot;User &quot; + id + &quot;'s hobbies: &quot; + Arrays.toString(hobbies)); return &quot;OK&quot;; } } 使用集合类型形参接收参数，使用方式与数组不同（会报错）。因为SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象。 使用集合类型形参接收参数需要使用@RequestParam绑定参数关系。 @Controller @RequestMapping(&quot;/user&quot;) public class UserController { // 访问方式与数组形式相同，响应体与终端输出也相同 @RequestMapping(&quot;/setHobbies&quot;) @ResponseBody public String setHobbies(Integer id, @RequestParam List&lt;String&gt; hobbies) { System.out.println(&quot;User &quot; + id + &quot;'s hobbies: &quot; + hobbies); return &quot;OK&quot;; } } 日期格式 使用@DateTimeFormat可以设置参数的日期格式，如： @Controller @RequestMapping(&quot;/user&quot;) public class UserController { // URL: http://localhost/user/setBirthday?id=123&amp;birthday=2023/1/1 18:23:40 @RequestMapping(&quot;/setBirthday&quot;) @ResponseBody public String setBirthday(Integer id, @DateTimeFormat(pattern = &quot;yyyy/MM/dd HH:mm:ss&quot;) Date birthday) { System.out.println(&quot;User &quot; + id + &quot;'s birthday is &quot; + birthday); return &quot;OK&quot;; } } JSON 数据参数 使用JSON传输需要添加相应依赖。SpringMVC默认使用的是jackson来处理json的转换： &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; 在配置类中添加@EnableWebMvc注解来开启JSON数据类型自动转换： @Configuration @ComponentScan(&quot;com.linner.controller&quot;) @EnableWebMvc // 开启JSON数据类型自动转换 public class SpringMvcConfig { } 使用JSON传输数据只需要在形参前添加@ResponseBody注解来将外部传递的JSON数据映射到形参到对象中： @Controller @RequestMapping(&quot;/user&quot;) public class UserController { @RequestMapping(&quot;/login&quot;) @ResponseBody public String login(@RequestBody User user) { System.out.println(&quot;Login: &quot; + user); return &quot;OK&quot;; } @RequestMapping(&quot;/setHobbies&quot;) @ResponseBody public String setHobbies(Integer id, @RequestBody List&lt;String&gt; /* 也可以使用 String[] */ hobbies) { System.out.println(&quot;User &quot; + id + &quot;'s hobbies: &quot; + hobbies); return &quot;OK&quot;; } } login()： URL：http://localhost/user/login JSON： { &quot;id&quot;: 123, &quot;name&quot;: &quot;张三&quot;, &quot;password&quot;: &quot;123&quot;, &quot;address&quot;: { &quot;province&quot;: &quot;广东&quot;, &quot;city&quot;: &quot;广州&quot; } } setHobbies： URL：http://localhost/user/setHobbies2?id=123 JSON： [&quot;唱歌&quot;, &quot;跳舞&quot;, &quot;Rap&quot;, &quot;打篮球&quot;] 响应 JSON 数据 响应JSON数据需要依赖于@ResponseBody（在Controller中）和@EnableWebMvc（在配置类中）注解。将返回值设置为实体类对象，设置返回值类型为实体类类型，即可实现返回对应对象的JSON数据： 实体类： public class Book { private Integer id; private String name; // constructor、setter、getter and toString ... } Controller: @Controller @RequestMapping(&quot;/books&quot;) public class BookController { @RequestMapping(&quot;/search&quot;) @ResponseBody public Book search(int id) { return new Book(id, &quot;Hello SpringMVC&quot;); } @RequestMapping(&quot;/searchName&quot;) @ResponseBody public List&lt;Book&gt; searchName(String name) { System.out.println(&quot;Search the book &quot; + name); List books = new ArrayList&lt;Book&gt;(); for (int i = 0; i &lt; 5; i++) { books.add(new Book(i, name + Integer.toString(i))); } return books; } } searchName()： URL：http://localhost/books/searchName?name=SpringMVC 返回JOSN： [ { &quot;id&quot;: 0, &quot;name&quot;: &quot;SpringMVC0&quot; }, { &quot;id&quot;: 1, &quot;name&quot;: &quot;SpringMVC1&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;SpringMVC2&quot; }, { &quot;id&quot;: 3, &quot;name&quot;: &quot;SpringMVC3&quot; }, { &quot;id&quot;: 4, &quot;name&quot;: &quot;SpringMVC4&quot; } ] search()： URL：http://localhost/books/search?id=123 返回JSON： { &quot;id&quot;: 123, &quot;name&quot;: &quot;SpringMVC&quot; } REST 风格 REST（Representational State Transfer，表现形式状态转换），是一种软件架构风格。REST的优点有： 隐藏资源的访问行为，无法通过地址得知对资源是何种操作。 简化书写。 按照REST风格访问资源时使用行为动作区分对资源进行了何种操作： GET：查询； POST：新增。 PUT：修改。 DELETE：删除。 如： http://localhost/users——GET： 查询全部用户信息（查询）。 http://localhost/users/1——GET：查询指定用户（id为1）信息（查询）。 http://localhost/users——POST：添加用户信息（新增/保存）。 http://localhost/users——PUT：修改用户信息（修改/更新）。 http://localhost/users/1——DELETE：删除用户信息（删除）。 描述模块的名称通常使用复数，表示此类资源，而非单个资源。 Example： @Controller @RequestMapping(&quot;/users&quot;) public class UserController { /** * 添加用户 */ @RequestMapping(method = RequestMethod.POST) @ResponseBody public String save(@RequestBody User user) { return &quot;OK&quot;; } /** * 删除用户 */ @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable int id) { return &quot;OK&quot;; } /** * 修改用户 */ @RequestMapping(method = RequestMethod.PUT) @ResponseBody public String update(@RequestBody User user) { return &quot;OK&quot;; } /** * 根据用户id查询 */ @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET) @ResponseBody public String searchById(@PathVariable int id) { return &quot;OK&quot;; } /** * 查询所有用户 */ @RequestMapping(method = RequestMethod.GET) @ResponseBody public String searchAll() { return &quot;OK&quot;; } } 上方Controller中每个方法的@RequestMapping中都使用了method元素来确定请求方式。并且根据需要save()和update()都接收一个JSON数据。 delete()和searchById()都使用了路径参数（value = &quot;\\{id}&quot;）。指定路径参数后，需要在方法参数列表中添加名称相同的参数，并且用@PathVariable注解（public String delete(@PathVariable int id)）。 路径参数可以定义多个，如： @RequestMapping(value = &quot;/{id}/{name}&quot;, method = RequestMethod.GET) @ResponseBody public String searchById(@PathVariable int id, @PathVariable String name) { return &quot;OK&quot;; } 如果想要路径参数名与形参名不同，需要在@PathVariable中注明对应关系，如： @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable(&quot;id&quot;) int userId) { return &quot;OK&quot;; } RESTful 快速开发 使用@RestController注解： 将@ResponseBody注解提到类上，让所有的方法都有@ResponseBody的功能。 @RestController注解正好相当于@Controller加上@ResponseBody的功能，所以可以使用@RestController替代它们。 使用@GetMapping、@PostMapping、@PutMapping、@DeleteMapping等替代@RequestMapping。 例如@GetMapping就相当于RequestMapping(method = RequestMethod.GET)。 Example： @RestController @RequestMapping(&quot;/books&quot;) public class BookController { /** * 搜索全部书籍 */ @GetMapping public String getAll() { return &quot;All Books&quot;; } /** * 搜索图书 */ @GetMapping(&quot;/{id}&quot;) public String getById(@PathVariable int id) { return &quot;Get by id &quot; + id; } /** * 保存图书 */ @PostMapping public String save(@RequestBody Book book) { return &quot;Save &quot; + book.toString(); } /** * 修改图书 */ @PutMapping public String update(@RequestBody Book book) { return &quot;Update &quot; + book.toString(); } /** * 删除图书 */ @DeleteMapping(&quot;/{id}&quot;) public String delete(@PathVariable int id) { return &quot;Delete by id&quot; + id; } } 拦截器 拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行。拦截器可以在指定的发那个发调用前后执行预先设定的代码，可以阻止原始方法的执行。拦截器和过滤器在作用和执行顺序上很相似。它们的关系如下图所示： 创建拦截器类： @Component // 由SpringMVC来管理 public class BookInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;preHandle...&quot;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;postHandle...&quot;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;afterCompletion...&quot;); } } 配置拦截器类： @Configuration public class SpringMvcSupport extends WebMvcConfigurationSupport { @Autowired // 自动装配 private BookInterceptor bookInterceptor; @Override protected void addInterceptors(InterceptorRegistry registry) { // 添加（声明）拦截器并配置拦截规则 // 可以同时配置多个规则 registry.addInterceptor(bookInterceptor).addPathPatterns(&quot;/books&quot;, &quot;/books/*&quot;); } } 让SpringMVC扫描到拦截器的配置类： @Configuration @ComponentScan({&quot;com.linner.controller&quot;, &quot;com.linner.config&quot;}) @EnableWebMvc public class SpringMvcConfig { } 运行程序，发送books开头的请求（如http://localhost/books），终端会有如下输出： preHandle... getAll... postHandle... afterCompletion... 拦截器的执行顺序如下： 执行preHandle()。 preHandle()返回值为true： 执行请求路径相应的方法或下一个拦截器的preHandle()。 判断是否执行postHandle()： Controller被执行（后续拦截器链中没有一个preHandle()返回值为false），执行postHandle()。 Controller没有被执行（后续拦截器链中存在一个preHandle()返回值为false），不执行postHandle()。 执行afterCompletion()。 preHandle()返回值为false。 结束。 当配置多个拦截器时，形成拦截器链。多个preHandle()按照Interceptor被声明顺序执行；多个postHandle()按照Interceptor被声明顺序逆序执行。即，拦截器链的运行顺序参照拦截器添加顺序为准。 当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行。当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion()操作（afterCompletion()代表当前拦截器执行完成，与后续拦截器链中preHandle()的返回值和Controller是否被执行无关）。 拦截器配置书写简化 Interceptor的配置类SpingMvcSupport可以书写在SpringMvcConfig中： @Configuration @ComponentScan({&quot;com.linner.controller&quot;}) @EnableWebMvc public class SpringMvcConfig implements WebMvcConfigurer { @Autowired private BookInterceptor bookInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(bookInterceptor).addPathPatterns(&quot;/books&quot;, &quot;/books/*&quot;); } } 静态资源 @Configuration public class SpringMvcSupport extends WebMvcConfigurationSupport { @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;); } } addResourceHandler()：定义访问资源路径。 addResourceLocations()：定义访问路径时的静态资源目录。 ","link":"https://linna-cy.github.io/old-blog/SpringMVC基础/"},{"title":"Java 进阶","content":"反射 反射是Java中一种用于动态获取类或对象的信息以及动态调用对象方法的功能机制。在运行状态中，对于任意一个类，使用反射可以获取这个类的所有属性和方法；对于任意一个对象，使用反射能够调用它的任意属性和方法。利用反射可以无视对象的修饰符，调用类里面的内容。利用反射可以跟配置文件结合起来使用，把要创建的对象信息和方法写在配置文件中。 使用反射包含以下步骤： 获取class字节码文件对象。 利用反射可以操作类或对象的信息有： 构造方法（获取、创建对象） 成员变量（获取、赋值） 成员方法（获取、运行） 获取字节码文件对象 Java中的每个类都是一个Class对象（字节码文件对象）。获取字节码文件对象共有以下三种方式： 通过class字节码文件获取：Class.forName(&quot;类的全类名&quot;) 类的全类名=类的包名.类名。 使用该方式，是通过.java源代码文件编译后生成的.class字节码文件获取。 Class clazz = Class.forName(&quot;com.linner.repo.Student&quot;); 通过Class对象的class属性获取：类名.class 该方式是对象已载入内存后使用的，需要使用import语句将对应的类导入（.class文件加载到内存后产生的Class对象也是唯一的）。 Class clazz = Student.class; 通过对象获取：对象.getClass() 通过创建对象后的getClass()方法来返回该对象的Class对象。该方法需要创建具体对象后才能使用。 Student student = new Student(); Class clazz = student.getClass(); 以上三种方法获取到的Class对象均为同一个对象。即，使用==分别判断以上三种方法获取到的对象均为true。 获取了Class对象后就可以获取到该类的各种信息。 获取构造方法 获取构造方法即为获取Constructor对象。 方法名 说明 Constructor&lt;?&gt;[] getConstructors() 获得所有的公共构造方法（public） Constructor&lt;?&gt;[] getDeclaredConstructors() 获得所有的构造方法（包括private） Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获取指定的公共构造方法 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 获取指定的构造方法（包括private） Example： public class Student { public Student() { System.out.println(&quot;创建了一个Student对象&quot;); } private Student(String name) { System.out.println(&quot;创建了一个Student对象：&quot; + name); } public Student(String name, int age) { System.out.println(&quot;创建了一个Student对象：name=&quot; + name + &quot;, age=&quot; + age); } } public class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { // 获取Class对象 Class clazz = Class.forName(&quot;com.linner.repo.Student&quot;); // 获取所有公共构造方法对象 Constructor[] constructors1 = clazz.getConstructors(); for (Constructor constructor : constructors1) { System.out.println(constructor); } System.out.println(&quot;=======================&quot;); // 获取所有构造方法对象（包括private） Constructor[] constructors2 = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors2) { System.out.println(constructor); } System.out.println(&quot;=======================&quot;); // 获取指定的构造方法对象 // 空参构造方法 Constructor con1 = clazz.getConstructor(); System.out.println(con1); // 包含参数的构造方法 Constructor con2 = clazz.getConstructor(String.class, int.class); System.out.println(con2); // 获取指定的构造方法对象（包括private） Constructor con3 = clazz.getDeclaredConstructor(String.class); System.out.println(con3); } } 通过反射创建对象 使用Constructor对象的newInstance()方法可以为反射的类创建对象。 Example： public class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { // 获取Class对象 Class clazz = Class.forName(&quot;com.linner.reflect.Student&quot;); // 获取无参的公共构造方法 Constructor con1 = clazz.getConstructor(); // 使用无参的构造方法创建对象 Student stu1 = (Student) con1.newInstance(); System.out.println(stu1); // 获取带参数的构造方法（包括private） Constructor con2 = clazz.getDeclaredConstructor(String.class, int.class); // 暴力反射 // 如果是private修饰的构造方法，需要临时修改构造方法的访问权限（取消检查访问权限） con2.setAccessible(true); // 使用带参数的构造方法创建对象 Student stu2 = (Student) con2.newInstance(&quot;zhangsan&quot;, 23); System.out.println(stu2); } } 获取成员变量 获取成员变量即为获取Field对象。 方法名 说明 Field[] getFields() 返回所有公共成员变量对象（public） Field[] getDeclaredFields() 返回所有成员变量对象（包括private） Field getField(String name) 返回指定名称的公共成员变量对象（public） Field getDeclaredField(String name) 返回指定名称的成员变量对象（包括private） Example： public class Student { public String name; private int age; public String gender; private String address; } public class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { // 获取Class对象 Class clazz = Class.forName(&quot;com.linner.reflect.Student&quot;); // 获取所有公共成员变量对象 Field[] fields1 = clazz.getFields(); for (Field field : fields1) { System.out.println(field); } System.out.println(&quot;====================&quot;); // 获取所有成员变量（包括private） Field[] fields2 = clazz.getDeclaredFields(); for (Field field : fields2) { System.out.println(field); } System.out.println(&quot;====================&quot;); // 获取指定名称的公共成员变量 Field nameField = clazz.getField(&quot;name&quot;); System.out.println(nameField); System.out.println(&quot;====================&quot;); // 获取指定名称的成员变量（包括private） Field ageField = clazz.getDeclaredField(&quot;age&quot;); System.out.println(ageField); } } 利用反射获取和修改成员变量的值 可以使用以下Field对象方法对成员变量的值进行修改： 赋值： void set(Object obj, Object value) 参数： obj：要修改属性值的具体对象； value：具体要修改的值。 获取值： Object get(Object obj) 参数： obj：要修改属性值的具体对象。 Example： public class Student { public String name; private int age; private String gender; private String address; public Student(String name, int age, String gender, String address) { this.name = name; this.age = age; this.gender = gender; this.address = address; } } public class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException { Student student = new Student(&quot;张三&quot;, 23, &quot;大三&quot;, &quot;广州&quot;); // 获取Class对象 Class&lt;?&gt; clazz = Class.forName(&quot;com.linner.reflect.Student&quot;); // 获取并修改name的值 Field nameField = clazz.getField(&quot;name&quot;); // 获取name的值 String name = (String) nameField.get(student); System.out.println(name); // 修改name的值 nameField.set(student, &quot;李四&quot;); name = (String) nameField.get(student); System.out.println(name); System.out.println(&quot;===============&quot;); // 获取并修改私有变量的值（暴力反射） Field addressField = clazz.getDeclaredField(&quot;address&quot;); // 临时取消访问权限（获取和修改私有变量的值都需要此操作） addressField.setAccessible(true); // 获取私有变量address的值 String address = (String) addressField.get(student); System.out.println(address); // 修改私有变量address的值 addressField.set(student, &quot;北京&quot;); address = (String) addressField.get(student); System.out.println(address); } } 获取成员方法 获取成员方法即为获取Method对象。 方法名 说明 Method[] getMethods() 返回所有公共成员方法对象（public） Method[] getDeclaredMethods() 放回所有成员方法对象（包括private） Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 返回指定名称和形参的公共成员方法对象（public） Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes 返回指定名称和形参的成员方法对象（包括private） Example： package com.linner.reflect; public class Student { private String name; private int age; private String gender; private String address; public Student() { } public Student(String name) { this.name = name; } public Student(String name, int age) { this.name = name; this.age = age; } public Student(String name, int age, String gender, String address) { this.name = name; this.age = age; this.gender = gender; this.address = address; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, gender='&quot; + gender + '\\'' + &quot;, address='&quot; + address + '\\'' + '}'; } private void sleep() { System.out.println(this.name + &quot;正在睡觉&quot;); } private void study() { System.out.println(this.name + &quot;正在内卷&quot;); } private void study(int time) { System.out.println(this.name + &quot;已经卷了&quot; + time + &quot;分钟还在卷&quot;); } } public class ReflectDemo1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { // 获取Class对象 Class&lt;?&gt; clazz = Class.forName(&quot;com.linner.reflect.Student&quot;); // 获取所有公共成员方法 Method[] methods1 = clazz.getMethods(); for (Method method : methods1) { System.out.println(method); } System.out.println(&quot;==============&quot;); // 获取所有成员方法（包括private） Method[] methods2 = clazz.getDeclaredMethods(); for (Method method : methods2) { System.out.println(method); } System.out.println(&quot;==============&quot;); // 获取指定的公共成员方法 // 空参的公共成员方法 Method toStringMethod = clazz.getMethod(&quot;toString&quot;); System.out.println(toStringMethod); // 带参数的公共成员方法 Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class); System.out.println(setNameMethod); System.out.println(&quot;==============&quot;); // 获取指定的成员方法（包括private） // 空参的成员方法 Method studyMethod1 = clazz.getDeclaredMethod(&quot;study&quot;); System.out.println(studyMethod1); // 带参数的成员方法 Method studyMethod2 = clazz.getDeclaredMethod(&quot;study&quot;, int.class); System.out.println(studyMethod2); } } 通过反射运行成员方法 使用Method对象的invoke()方法可以运行成员方法。 Object invoke(Object obj, Object... args) obj：具体调用成员方法的对象； args：调用成员方法传递的参数； 返回值：方法的返回值。 Example： public class ReflectDemo1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { Student student = new Student(&quot;张三&quot;, 23, &quot;大三&quot;, &quot;广州&quot;); // 获取Class对象 Class&lt;?&gt; clazz = Class.forName(&quot;com.linner.reflect.Student&quot;); // 调用无参的成员方法 Method toStringMethod = clazz.getMethod(&quot;toString&quot;); String studentToString = (String) toStringMethod.invoke(student); System.out.println(studentToString); // 调用带参的私有成员方法 Method studyMethod = clazz.getDeclaredMethod(&quot;study&quot;, int.class); // 临时取消访问权限 studyMethod.setAccessible(true); studyMethod.invoke(student, 180); } } 注解 Java注解是附加在代码中的一些元信息，用于编译和运行时进行解析和使用，起到说明、配置的功能。 注解不会影响代码的实际逻辑（并不直接影响代码的语义），仅仅起到辅助性的作用（但是注解可以被看做是程序的工具或者类库。会反过来对正在运行的程序语义有所影响）。包含在java.lang.annotation包中。注解使用@interface来定义（类似于接口的定义）。为注解定义一个方法即为注解类型定义了一个元素，方法的声明不允许有参数或throw语句，返回值类型被限定为原始数据类型、String、Class、enums、注解类型，或前面这些类型的数组，方法可以有默认值。注解可以从源文件、class文件或者在运行时通过反射机制多种方式被读取。 注解的实现的原理很大的一部分是基于反射实现。 一般来说，注解一般分为三种类型： 元注解 标准注解 自定义注解 元注解 元注解是专职负责注解其他注解，主要是标明该注解的使用范围，生效范围。元注解并不能被修改，只能被用来定义自定义注解。 元注解包括以下四种： 注解 说明 @Target 定义注解的作用目标。即用来定义自定义注解具体作用在类上，方法上，还是变量上。具体值和作用对象如下：ElementType.TYPE：接口、类、枚举、注解ElementType.FIELD：字段、枚举的常量ElementType.METHOD：方法ElementType.PARAMETER：方法参数ElementType.CONSTRUCTOR：构造函数ElementType.LOCAL_VARIABLE：局部变量ElementType.ANNOTATION_TYPE：注解ElementType.PACKAGE：包 Retention 定义注解的保留策略。该注解的值如下：RetentionPolicy.SOURCE：定义注解仅存在于源码中，在class字节码文件中不包含；RetentionPolicy.CLASS：该注解默认的保留策略，定义注解会在class字节码文件中存在，但运行时无法获得；RetentionPolicy.RUNTIME：定义注解会在class字节码文件中存在，在运行时可以通过反射获取到。 @Document 说明该注解将被包含在javadoc中。 @Inherited 说明子类可以继承该注解。 标准注解 Java 提供了三个标准注解，定义在java.lang中（这三个注解的作用更多是一种注释）。 @Override：表示当前方法覆盖了父类中的对应方法（重写方法）。 @Deprecated：标记一个元素为已过期，避免或不推荐使用。 支持的元素类型为：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE。 @SuppressWarnings：不输出对应的编译警告。 自定义注解 注解的定义类似于接口的定义，使用@interface来定义。定义注解类中的一个方法即为注解类型定义了一个元素，方法的声明不允许有参数或throw语句，返回值类型被限定为原始数据类型、字符串String、Class、enums、注解类型，或前面这些类型的数组，方法可以有默认值。 自定义注解一般分为以下三个步骤： 定义注解。 如： @Target(ElementType.Type) // 表明该注解加载在类上 @Retention(RetentionPolicy.RUNTIME) // 表明运行时读取该注解 // 定义注解类 public @interface MyAnnotationType { // 定义注解方法（不能有参数或throw等） String value(); } @Target(ElementType.FIELD) // 表明该注解加载在字段上（接口、类、枚举）。 @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotationField { String name(); // 使用default定义默认值 int length() default 0; } 使用注解。 如（在其他类上）： @MyAnnotationType(&quot;Annotation&quot;) // 或（有多个元素时需要指定元素名）：@MyAnnotation1(value = &quot;Annotation&quot;) public class UsingAnnotations { @MyAnnotationField(name = &quot;张三&quot;, length = 12) public int a; @MyAnnotationField(name = &quot;李四&quot;) // length将使用默认值 public String b; } 读取注解。 如（定义一个类来读取）： public class AnnotationValues { public static void readValues() throws ClassNotFoundException { Class usingAnnotationsClass = Class.forName(&quot;UsingAnnotation&quot;); // 读取作用于类上的注解 MyAnnotationType mat = (MyAnnotationType) usingAnnotationsClass.getAnnotation(MyAnnotationType.class); System.out.println(mat.value()); // 读取作用于属性上的注解 Field a = usingAnnotationsClass.getDeclaredField(&quot;a&quot;); MyAnnotationField maf = (MyAnnotationField) a.getAnnotation(MyAnnotationField.class); System.out.println(maf.name()); System.out.println(maf.length()); } } 使用注解模拟 Junit public class AnnotationDemo { // @MyTest public void test1() { System.out.println(&quot;test1...&quot;); } @MyTest public void test2() { System.out.println(&quot;test2...&quot;); } // @MyTest public void test3() { System.out.println(&quot;test3...&quot;); } @MyTest public void test4() { System.out.println(&quot;test4...&quot;); } @MyTest public void test5() { System.out.println(&quot;test5...&quot;); } public static void main(String[] args) throws Exception { AnnotationDemo a = new AnnotationDemo(); // 获取Class对象 Class&lt;?&gt; clazz = Class.forName(&quot;com.linner.annotation.AnnotationDemo&quot;); // 判断对象的所有方法上是否存在MyTest注解 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { if (method.isAnnotationPresent(MyTest.class)) { method.invoke(a); } } } } ","link":"https://linna-cy.github.io/old-blog/Java进阶/"},{"title":"Spring Framework","content":"Spring Framewor 简介 Spring5.0已经全面支持JDK8，建议JDK使用1.8版本。 Spring Framework是Spring家族中其他框架的底层基础。 Spring Framewor 架构 Spring Framework的发展经历了很多版本的变更，每个版本都有相应的调整。 Spring Framework 架构： 核心层 Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块。 AOP层 AOP：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强。 Aspects：AOP是编程思想，Aspects是对AOP思想的具体实现。 数据层 Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术。 Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis。 Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现。 Web层 Test层 Spring主要整合了Junit来完成单元测试和集成测试。 从Spring Framework 5没有架构图，而最新的架构图是4版本，所以可以认为Spring Framework从4版本开始架构就已经趋于稳定，没有什么变动。 Spring 核心概念 在Spring核心概念主要包含： IOC IOC，Inversion of Control，即控制反转。 控制反转：主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部的一种思想。 例如，业务（Service）层要使用到数据（DAO）层的类对象。此时就可以使用IOC思想，由外部程序给业务层创建数据层对象。 这样可以降低业务层和数据层之间的耦合性。 如果数据层的实现更改的话，就无需在业务层中修改实现类。 IOC容器 Spring提供了一个容器，称为IOC容器，用来充当IOC思想中的&quot;外部&quot;。 IOC容器负责对象的创建、初始化等一系列工作。 Bean 在IOC容器中，被创建或被管理的对象统称为Bean。 IOC容器中存放的就是一个个的Bean对象。 DI 依赖注入：在容器中建立Bean与Bean之间的依赖关系的整个过程。 例如，业务层和数据层在IOC容器中创建Bean后，并不能直接工作，因为业务层需要依赖数据层才能正确工作。所以此时就需要使用依赖注入，在业务层和数据层之间建立依赖关系。 IOC和DI的最终目标就是充分解耦。在Spring Framewor中的实现依靠： 使用IOC容器管理Bean（IOC）。 在IOC容器内将有依赖关系的Bean进行关系绑定（DI）。 最终，使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系。 配置文件方法使用IOC/DI 使用 IOC 容器创建 Bean（bean 标签） 基础配置： 创建Maven项目，项目基础结构如下： 📁project-file-name 📁src 📁main 📁java 📁com.linner 📁dao 📁domain 📁service 📁resourcs 📁test 📁java 📁com.linner 📁service 📄pom.xml 添加Spring Framework的依赖jar包： &lt;dependencies&gt; &lt;!--...--&gt; &lt;!--springframework--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--...--&gt; &lt;/dependencies&gt; 添加业务层、数据层类： User.java: package com.linner.domain; public class User { Integer id; String username; String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username='&quot; + username + '\\'' + &quot;, password='&quot; + password + '\\'' + '}'; } } DAO(仅测试，无需查询数据库): 接口： package com.linner.dao; import com.linner.domain.User; import java.util.List; public interface UserDao { List&lt;User&gt; findAll(); User findById(int id); void delete(int id); void save(User user); void update(User user); } 实现类： package com.linner.dao.impl; import com.linner.dao.UserDao; import com.linner.domain.User; import java.util.List; public class UserDaoImpl implements UserDao { @Override public List&lt;User&gt; findAll() { System.out.println(&quot;UserDao findAll...&quot;); return null; } @Override public User findById(int id) { System.out.println(&quot;UserDao findById:&quot; + id); return null; } @Override public void delete(int id) { System.out.println(&quot;UserDao delete:&quot; + id); } @Override public void save(User user) { System.out.println(&quot;UserDao save:&quot; + user); } @Override public void update(User user) { System.out.println(&quot;UserDao update:&quot; + user); } } Service: 接口： package com.linner.service; import com.linner.domain.User; import java.util.List; public interface UserService { List&lt;User&gt; findAll(); User findById(int id); void delete(int id); void save(User user); void update(User user); } 实现类： package com.linner.service.impl; import com.linner.dao.UserDao; import com.linner.dao.impl.UserDaoImpl; import com.linner.domain.User; import com.linner.service.UserService; import java.util.List; public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public List&lt;User&gt; findAll() { System.out.println(&quot;UserService findAll...&quot;); userDao.findAll(); return null; } @Override public User findById(int id) { System.out.println(&quot;UserService findById:&quot; + id); userDao.findById(id); return null; } @Override public void delete(int id) { System.out.println(&quot;UserService delete:&quot; + id); userDao.delete(id); } @Override public void save(User user) { System.out.println(&quot;UserService save:&quot; + user); userDao.save(user); } @Override public void update(User user) { System.out.println(&quot;UserService update:&quot; + user); userDao.update(user); } } 测试方法： package com.linner.service; import com.linner.domain.User; import com.linner.service.UserService; import com.linner.service.impl.UserServiceImpl; import org.junit.Test; import java.util.List; public class UserServiceTest { private UserService userService = new UserServiceImpl(); @Test public void testFindAll() { userService.findAll(); System.out.println(&quot;------------&quot;); } @Test public void testFindById() { int id = 12; userService.findById(id); System.out.println(&quot;------------&quot;); } @Test public void testDelete() { int id = 12; userService.delete(id); System.out.println(&quot;------------&quot;); } @Test public void testSave() { User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userService.save(user); System.out.println(&quot;------------&quot;); } @Test public void testUpdate() { User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userService.update(user); System.out.println(&quot;------------&quot;); } } 创建Bean 在📁resourcs目录下创建String配置文件applicationContext.xml，并使用&lt;bean&gt;标签配置Bean： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--添加UserService--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot;/&gt; &lt;/beans&gt; 接着在程序中使用Spring提供的方法获取IOC容器。然后从IOC容器中获取对象并调用其方法，修改Test类进行测试： public class UserServiceTest { // private UserService userService = new UserServiceImpl(); // 使用IOC无需自己创建对象（对象由IOC容器分配 private static UserService userService; // 这里使用静态代码块获取容器和Bean static { // 获取IOC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); userService = (UserService) ctx.getBean(&quot;userService&quot;); } // ... } IOC核心容器创建方式有： ClassPathXmlApplicationContext：类路径下的XML配置文件。 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ClassPathXmlApplicationContext的参数为XML配置文件在类路径下的相对路径。 FileSystemXmlApplicationContext： ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;/home/linner/IdeaProjects/my-springfw-demo/src/main/resources/applicationContext.xml&quot;); FileSystemXmlApplicationContext的参数为XML配置文件在文件系统下的绝对路径。 UserServiceTest执行成功说明配置成功。 Bean 的基础配置 &lt;bean&gt;标签是作为Spring配置Bean使用。其基本形式为： &lt;bean id=&quot;&quot; class=&quot;&quot;/&gt; id：Bean标签的唯一标识。在同一个上下文中(配置文件)不能重复。 class：Bean的类型。包含包名和类名。 别名（name 属性） &lt;bean&gt;的name属性可以为&lt;bean&gt;指定别名，别名可以有多个，使用,，;，空格进行分隔。如： &lt;bean id=&quot;userService&quot; name=&quot;service userEbi&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot;/&gt; 说明：EBI全称Enterprise Business Interface，译为企业业务接口。 获取 Bean 的方式（getBean() 方法） 使用getBean()获取Bean的方式有三种： 按照名称获取： 是指在getBean()方法中传递String类型的参数，参数的值为Bean的名称。 Object getBean(String s) 按照类型获取： 需要保证该类型在IOC容器中有且仅有一个Bean（不能包含多个同类型的Bean）。 在参数中传递该类型的class。 &lt;T&gt; T getBean(Class&lt;T&gt; aClass) 按照名称和类型获取： 在参数中传入Bean的名称和类型。 &lt;T&gt; T getBean(String s, Class&lt;T&gt; aClass) 作用范围（scope 属性） &lt;bean&gt;的scope属性可以为&lt;bean&gt;设置作用范围，可选值为： singloton：默认，表示创建的对象为单例（在整个IOC容器中所有获取到的该对象都为同一个对象）。如： &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot; scope=&quot;singloton&quot;/&gt; 或： &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot; /&gt; 实际上，单例对象在容器被获取的时候就已经被创建了。 prototype：表示创建的对象为非单例（每次在IOC容器中获取到的对象都是不同的对象）。如： &lt;bean id=&quot;userService&quot; name=&quot;service userEbi&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot; scope=&quot;prototype&quot;/&gt; Example： 将UserService设为单例： String配置文件applicationContext.xml中userService的&lt;bean&gt;（由于Spring默认创建的是单例，所以这里可以选择不添加scope=&quot;singloton&quot;）： &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot;&gt; &lt;/bean&gt; 创建新的测试类TestForUserServiceScope： package com.linner.service; import com.linner.domain.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestForUserServiceScope { private static ApplicationContext ctx; static { ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); } @Test public void testFindAll() { UserService userService = (UserService) ctx.getBean(&quot;userService&quot;); System.out.println(userService); userService.findAll(); System.out.println(&quot;------------&quot;); } @Test public void testFindById() { UserService userService = (UserService) ctx.getBean(&quot;userService&quot;); System.out.println(userService); int id = 12; userService.findById(id); System.out.println(&quot;------------&quot;); } @Test public void testDelete() { UserService userService = (UserService) ctx.getBean(&quot;userService&quot;); System.out.println(userService); int id = 12; userService.delete(id); System.out.println(&quot;------------&quot;); } @Test public void testSave() { UserService userService = (UserService) ctx.getBean(&quot;userService&quot;); System.out.println(userService); User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userService.save(user); System.out.println(&quot;------------&quot;); } public void testUpdate() { UserService userService = (UserService) ctx.getBean(&quot;userService&quot;); System.out.println(userService); User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userService.update(user); System.out.println(&quot;------------&quot;); } } 执行UserServiceTest1后，在输出中可以发现：每个测试方法中使用getBean()获取到的UserService都是同个对象。 将UserService设为非单例： 修改String配置文件applicationContext.xml： &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot; scope=&quot;prototype&quot;&gt; 再次执行UserServiceTest1，可以发现：每个测试方法中使用getBean()获取到的UserService都是不同的对象。 Bean 的实例化 实例化Bean分为三种方式： 构造方法 静态工厂 实例工厂 构造方法实例化 Bean（默认） &lt;bean&gt;默认是使用无参的构造方法实例化Bean。并且，Spring底层用的是反射（因为即使将构造方法设置为private依然可以使用）。 静态工厂实例化 Bean（factory-method 属性） 静态工厂实例化Bean指的是通过工厂类来创建对象。 一般情况下是使用如下方法静态工厂实例化对象： 创建com.linner.factory包，并编写UserDaoFactory： package com.linner.factory; import com.linner.dao.UserDao; import com.linner.dao.impl.UserDaoImpl; public class UserDaoFactory { public static UserDao getUserDao() { return new UserDaoImpl(); } } 编写TestFroInstanceUserDao测试类： package com.linner.dao; import com.linner.domain.User; import com.linner.factory.UserDaoFactory; import org.junit.Test; public class TestFroInstanceUserDao { private UserDao userDao = UserDaoFactory.getUserDao(); @Test public void testFindAll() { userDao.findAll(); System.out.println(&quot;------------&quot;); } @Test public void testFindById() { int id = 12; userDao.findById(id); System.out.println(&quot;------------&quot;); } @Test public void testDelete() { int id = 12; userDao.delete(id); System.out.println(&quot;------------&quot;); } @Test public void testSave() { User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userDao.save(user); System.out.println(&quot;------------&quot;); } @Test public void testUpdate() { User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userDao.update(user); System.out.println(&quot;------------&quot;); } } 在IOC容器中使用静态工厂实例化： 在Spring配置文件中加入UserDao的配置： &lt;bean id=&quot;userDao&quot; class=&quot;com.linner.factory.UserDaoFactory&quot; factory-method=&quot;getUserDao&quot;/&gt; class：工厂类的类全名。这里指定的是创建UserDao的静态工厂类UserDaoFactory。 factory-method：class指定的工厂类中创建对象的方法名。这里指定的是工厂类中用来创建UserDao的方法。 修改TestFroInstanceUserDao： import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestFroInstanceUserDao { private static UserDao userDao; static { ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); userDao = (UserDao) ctx.getBean(&quot;userDao&quot;); } // ... } 注意：使用这种方法实例化，不能将该Bean注入到其他Bean中。 实例工厂实例化 Bean 使用 Bean 的 factory-bean 属性 实例化工厂实例化Bean是指，为工厂类添加一个单例的Bean（为区分则称为工厂Bean），然后在要实例化的Bean中指定使用这个工厂Bean作为实例化工厂。 修改UserDaoFactory（不使用静态工厂）： public class UserDaoFactory { public UserDao getUserDao() { return new UserDaoImpl(); } } 在Spring的配置文件中添加UserDaoFactory的&lt;bean&gt;，并且修改UserDao的&lt;bean&gt;： &lt;bean id=&quot;userDaoFactory&quot; class=&quot;com.linner.factory.UserDaoFactory&quot;/&gt; &lt;bean id=&quot;userDao&quot; factory-bean=&quot;userDaoFactory&quot; factory-method=&quot;getUserDao&quot;/&gt; 添加了一个userDaoFactory工厂Bean。 factory-bean：工厂的实例对象，即工厂Bean的id或name。 factory-method：工厂对象中具体创建对象的方法名，即factory-bean指定对象中创建该对象的方法名。 成功执行TestFroInstanceUserDao即配置成功。 使用 FactoryBean 接口 创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法： package com.linner.factory; import com.linner.dao.UserDao; import com.linner.dao.impl.UserDaoImpl; import org.springframework.beans.factory.FactoryBean; public class UserDaoFactoryBean implements FactoryBean { @Override public Object getObject() throws Exception { return new UserDaoImpl(); } @Override public Class&lt;?&gt; getObjectType() { return UserDao.class; } @Override public boolean isSingleton() { return true; } } getObject()：创建实例化对象并返回。代替原始实例工厂中创建对象的方法。 getObjectType()：返回所创建类的Class对象。 isSingleton()：设置对象是否为单例。默认true，可以不重写。 修改Spring配置文件： &lt;bean id=&quot;userDao&quot; class=&quot;com.linner.factory.UserDaoFactoryBean&quot;/&gt; 成功执行TestFroInstanceUserDao即配置成功。 Bean 的生命周期 Bean的生命周期是指Bean对象从创建到销毁的整个过程。对Bean的生命周期进行控制，可以在Bean创建后（如加载初始化需要用到资源）还有销毁前（如释放资源）执行一些操作。 init-method 和 destroy-method 属性 Spring控制生命周期的第一个方法便是使用Spring配置文件中&lt;bean&gt;的 init-method 和 destroy-method 属性。 在UserDaoImpl中创建初始化方法和销毁方法（方法名任意）： public class UserDaoImpl implements UserDao { /** * 初始化方法 */ public void init() { System.out.println(&quot;UserDao init...&quot;); } /** * 销毁方法 */ public void destroy() { System.out.println(&quot;UserDao destroy...&quot;); } // ... } 修改Spring配置文件： &lt;bean id=&quot;userDao&quot; class=&quot;com.linner.dao.impl.UserDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&gt; init-method：class指定的类中的初始化方法，在创建Bean对象后执行。 destroy-method：class指定的类中的销毁方法，在销毁Bean前执行。 编写TestForLifeCycle测试类： package com.linner; import com.linner.dao.UserDao; import org.junit.Test; import org.springframework.context.support.ClassPathXmlApplicationContext; public class TestForLifeCycle { @Test public void testForLifeCycle() { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) ctx.getBean(&quot;userDao&quot;); userDao.findAll(); ctx.close(); } } 对比之前的ctx对象，这里ctx对象使用的类型从ApplicationContext变成了ClassPathXmlApplicationContext。这是因为ApplicationContext中并没有close()方法。而想要执行Bean对象中的destroy()，就必须在程序退出前关闭IOC容器（调用ctx.close()）。 注册钩子关闭容器 在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器。 修改TestForLifeCycle： public class TestForLifeCycle { @Test public void testForLifeCycle() { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); ctx.registerShutdownHook(); UserDao userDao = (UserDao) ctx.getBean(&quot;userDao&quot;); userDao.findAll(); } } 注意：ApplicationContext中也没有registerShutdownHook()。所以这里使用的是ClassPathXmlApplicationC对象。 InitializingBean 和 DisposableBean 接口 Spring 提供了InitializingBean和DisposableBean接口以更加方便地控制Bean生命周期。使用这两个接口则无需通过Sping配置文件中的init-method和destroy-method 属性来控制生命周期。 实现InitializingBean接口的afterPropertiesSet()方法和DisposableBean接口的destroy()方法： import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; public class UserDaoImpl implements UserDao, InitializingBean, DisposableBean { /** * InitializingBean接口的初始化方法 */ @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;UserDao init by afterPropertiesSet()...&quot;); } /** * DisposableBean接口的销毁方法 */ @Override public void destroy() { System.out.println(&quot;UserDao destroyed by destroy()...&quot;); } // ... } 在Spring配置文件中删除init-method和destroy-method属性： &lt;bean id=&quot;userDao&quot; class=&quot;com.linner.dao.impl.UserDaoImpl&quot;/&gt; 使用 Bean 标签的注意事项 class属性不能使用接口。因为接口不能创建对象。 获取Bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException。 Bean默认为单例，避免了对象的频繁创建与销毁，达到了对Bean对象的复用，性能高。 如果对象是有状态对象（即该对象有成员变量可以用来存储数据）。因为所有请求线程共用一个Bean对象，所以会存在线程安全问题。 如果对象是无状态对象（即该对象没有成员变量没有进行数据存储）。因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。 适合交给容器进行管理的Bean对象： 表现层对象 业务层对象 数据层对象 工具对象 不适合交给容器进行管理的Bean对象： 封装实例的域对象。会引发线程安全问题。 DI 依赖注入 上面的程序，在UserServiceImpl中依然需要手动创建对象： public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); // ... } 当前业务层和数据层的耦合性还是很高。此时就需要使用依赖注入来降低耦合性。 Spring依赖注入支持简单数据类型、引用数据类型还有集合注入，并且提供了两种注入方式： Setter注入 构造器注入 基础配置： 创建Maven项目。 添加Spring Framework和Junit的依赖jar包。 添加业务层、数据层类： User.java: 同使用IOC容器创建Bean中的User.java。 DAO(仅测试，无需查询数据库): 同使用IOC容器创建Bean中的DAO（UserDao）。 Service: 同使用IOC容器创建Bean中的Service（UserService）。 测试方法： package com.linner.service; import com.linner.domain.User; import com.linner.service.UserService; import com.linner.service.impl.UserServiceImpl; import org.junit.Test; import java.util.List; public class UserServiceTest { private static UserService userService; static { ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); userService = (UserService) ctx.getBean(&quot;userService&quot;); } @Test public void testFindAll() { userService.findAll(); System.out.println(&quot;------------&quot;); } @Test public void testFindById() { int id = 12; userService.findById(id); System.out.println(&quot;------------&quot;); } @Test public void testDelete() { int id = 12; userService.delete(id); System.out.println(&quot;------------&quot;); } @Test public void testSave() { User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userService.save(user); System.out.println(&quot;------------&quot;); } @Test public void testUpdate() { User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userService.update(user); System.out.println(&quot;------------&quot;); } } Setter 注入（property 标签） Setter注入是指，在实现类中为需要注入的属性设置Setter方法，让Spring能够使用Setter方法自动给属性创建对象。 注入引用数据类型 要在Bean中注入引用类型属性，注入的属性其实现类必须得是IOC容器中的Bean。 在UserServiceImpl中，取消手动创建对象，并为userDao属性提供setter方法： public class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } // ... } 修改Spring配置文件applicationContext.xml： &lt;!--...--&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.linner.dao.impl.UserDaoImpl&quot;/&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!--...--&gt; 为UserService注入UserDao要在UserService的&lt;bean&gt;标签中使用&lt;property&gt;标签。· &lt;property&gt;表示配置当前&lt;bean&gt;的属性，其标签属性有： name：&lt;bean&gt;所指的实现类的属性名，表示配置哪一个具体的属性。 ref：要配置的属性的Bean的id或name，表示参照哪一个&lt;bean&gt;（该注入的Bean必须在容器中存在）。 成功运行ServiceBeanTest说明注入成功。 如果要注入多个属性，则在实例类中加入多个属性，为其设置Setter并在Bean中配置多个&lt;property&gt;即可。 注入简单数据类型 在Bean中注入简单类型属性，简单数据类型并不用在配置文件中为简单类型添加Bean标签配置。 为BookDao添加简单类型属性： import org.springframework.beans.factory.InitializingBean; public class UserDaoImpl implements UserDao, InitializingBean { private String databaseName; private int connectionNum; public void setConnectionNum(int connectionNum) { this.connectionNum = connectionNum; } public void setDatabaseName(String databaseName) { this.databaseName = databaseName; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;UserDao init: DatabaseName=&quot; + this.databaseName + &quot;, ConnectionNum=&quot; + this.connectionNum); } // ... } 在Spring配置文件中为UserDao添加&lt;property&gt;标签： &lt;bean id=&quot;userDao&quot; class=&quot;com.linner.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;connectionNum&quot; value=&quot;10&quot;/&gt; &lt;/bean&gt; name：含义不变，与引用注入类型用法中的含义相同。 value: 要配置的属性的值，必须是简单数据类型。对于参数类型，Spring在注入的时候会自动转换，但是有可能会发生转换错误的情况。 成功运行ServiceBeanTest说明注入成功。 集合注入 修改UserDao，为其添加集合类型参数和对应Setter方法： import java.util.*; public class UserDaoImpl implements UserDao, InitializingBean { private int[] array; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String,String&gt; map; private Properties properties; // ...此处省略setter方法 @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;UserDao init: &quot; + &quot;array=&quot; + Arrays.toString(array) + &quot;, list=&quot; + list + &quot;, set=&quot; + set + &quot;, map=&quot; + map + &quot;, properties=&quot; + properties); } // ... } 修改Spring配置文件： &lt;bean id=&quot;userDao&quot; class=&quot;com.linner.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;array&quot;&gt; &lt;array&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;a&lt;/value&gt; &lt;value&gt;b&lt;/value&gt; &lt;value&gt;c&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;a&quot; value=&quot;1&quot;/&gt; &lt;entry key=&quot;b&quot; value=&quot;2&quot;/&gt; &lt;entry key=&quot;c&quot; value=&quot;3&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;a&quot;&gt;1&lt;/prop&gt; &lt;prop key=&quot;b&quot;&gt;2&lt;/prop&gt; &lt;prop key=&quot;c&quot;&gt;3&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;property&gt;：Setter注入依然使用该标签。其name属性含义不变。 集合类型的值在其标签下定义。 &lt;array&gt;：定义数组类型的值。 数组元素中的值使用&lt;value&gt;标签定义。 &lt;value&gt;标签中的值要与数组的类型一致。 一般形式如下： &lt;property name=&quot;...&quot;&gt; &lt;array&gt; &lt;value&gt;...&lt;/value&gt; &lt;value&gt;...&lt;/value&gt; &lt;value&gt;...&lt;/value&gt; &lt;!--...--&gt; &lt;/array&gt; &lt;/property&gt; &lt;list&gt;：定义List类型的值。 其用法与&lt;array&gt;类似。 &lt;property name=&quot;...&quot;&gt; &lt;list&gt; &lt;value&gt;...&lt;/value&gt; &lt;value&gt;...&lt;/value&gt; &lt;value&gt;...&lt;/value&gt; &lt;!--...--&gt; &lt;/list&gt; &lt;/property&gt; &lt;set&gt;：定义Set类型的值。 其用法与&lt;array&gt;类似。 &lt;property name=&quot;...&quot;&gt; &lt;set&gt; &lt;value&gt;...&lt;/value&gt; &lt;value&gt;...&lt;/value&gt; &lt;value&gt;...&lt;/value&gt; &lt;!--...--&gt; &lt;/set&gt; &lt;/property&gt; &lt;map&gt;：定义Map类型的值。 其元素使用&lt;entry&gt;标签定义。并且元素的key使用key属性定义，元素的value使用value属性定义。 key和value属性的值要和Map的类型对应。 &lt;property name=&quot;...&quot;&gt; &lt;map&gt; &lt;entry key=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;entry key=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;entry key=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;!--...--&gt; &lt;/map&gt; &lt;/property&gt; &lt;props&gt;：定义Properties的值。 其元素使用&lt;prop&gt;标签定义。key使用key属性定义，value在标签中定义。 &lt;property name=&quot;...&quot;&gt; &lt;props&gt; &lt;prop key=&quot;...&quot;&gt;...&lt;/prop&gt; &lt;prop key=&quot;...&quot;&gt;...&lt;/prop&gt; &lt;prop key=&quot;...&quot;&gt;...&lt;/prop&gt; &lt;!--...--&gt; &lt;/props&gt; &lt;/property&gt; 注意： List的底层也是通过数组实现的，所以&lt;list&gt;和&lt;array&gt;标签是可以混用。 集合中要添加引用类型，只需要把&lt;value&gt;标签改成&lt;ref&gt;标签。 构造器注入（constructor-arg 标签） 构造器注入是指Spring通过Bean的实例类中，带参的构造方法将其他Bean进行注入。 注入引用数据类型 在UserServices中删除Setter方法（此处删除Setter方法是为了证明使用的是构造器注入而非Setter注入）并添加带参的构造方法： public class UserServiceImpl implements UserService { private UserDao userDao; public UserServiceImpl(UserDao userDao) { this.userDao = userDao; } // ... } 修改Spring配置文件： &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;constructor-arg&gt;中name和ref属性的含义与&lt;property&gt;的含义类似。只不过name属性指的是Bean实例类型中构造方法的参数名（名称必须要一致）。 成功运行ServiceBeanTest说明注入成功。 如果要注入多个类型数据，则在构造方法中加入多个参数并在Bean中配置多个&lt;constructor-arg&gt;即可。 注入简单数据类型 在UserDao中删除Setter方法，并为其添加带参的构造方法： public class UserDaoImpl implements UserDao, InitializingBean { private String databaseName; private int connectionNum; public UserDaoImpl(String databaseName, int connectionNum) { this.databaseName = databaseName; this.connectionNum = connectionNum; } // ... } 修改Spring配置文件： &lt;bean id=&quot;userDao&quot; class=&quot;com.linner.dao.impl.UserDaoImpl&quot;&gt; &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt; &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;10&quot;/&gt; &lt;/bean&gt; 成功运行ServiceBeanTest说明注入成功。 集合注入 构造器注入集合数据类型的方式与Setter注入集合数据类型的方式类似。 只不构造器注入要定义相应的带参方法，并且将&lt;property&gt;标签改为&lt;constructor-arg&gt;。 自动装配（bean 标签的 autowire 属性） 自动装配只适用于引用类型依赖注入，不能对简单类型进行操作。 自动装配的方式有： 按类型（常用） 按名称 按构造方法（的参数） 按类型自动装配 为UserService中的属性（如userDao）提供Setter方法。接着在Spring中为UserService删除其&lt;bean&gt;标签下的所有&lt;proerty&gt;或&lt;constructor-arg&gt;。然后给&lt;bean&gt;添加autowire=&quot;byType&quot;： &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;/&gt; 注意： 类中对应属性的Setter方法不能省略。 被注入的对象必须要被Spring的IOC容器管理。 按照类型自动装配如果Spring在IOC中找到多个类型相同的Bean则会报NoUniqueBeanDefinitionException错误。 按名称自动装配 一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入。 修改Spring配置文件（添加autowire=&quot;byName&quot;）： &lt;bean id=&quot;userService&quot; class=&quot;com.linner.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;/&gt; 注意： 按名称自动装配是根据Setter方法的名称在IOC容器中寻找名称对应的Bean（Bean的id或name）。如setUserDao()则需要寻找名称为userDao的Bean。 如果按照名称找不到对应的Bean，则注入null（不会报错！）。 按名称自动装配中，实例类成员变量名与配置耦合，不推荐使用。 配置文件管理第三方 Bean（properties 文件加载） 数据源对象管理（DAO层） 以Druid为例： pom.xml依赖： &lt;dependencies&gt; &lt;!--Spring Framework--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL JDBC--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;!--Druid--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; JDBC配置（jdbc.properties）： jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:33061/spring_db jdbc.username=root jdbc.password=n546,Lin0 Spring配置（applicationContext.xml）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--需要开启context命名空间--&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--加载jdbc配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath*:jdbc.properties&quot;/&gt; &lt;!--Druid Bean--&gt; &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 编写App.java： package com.linner; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DruidDataSource dataSource = ctx.getBean(DruidDataSource.class); System.out.println(dataSource); } } 如果终端成功输出dataSource，说明配置成功。 注解开发 Spring对注解支持的版本历程: 2.0版开始支持注解 2.5版注解功能趋于完善 3.0版支持纯注解开发 基础配置： 创建Maven项目。 添加Spring Framework和Junit的依赖jar包。 添加业务层、数据层类： User.java: 同使用IOC容器创建Bean中的User.java。 DAO(仅测试，无需查询数据库): 同Setter 注入中的DAO（UserDao）。 Service: 同Setter 注入中的Service（UserService）。 Spring 配置文件包扫描 为了能够获取到使用注解定义的Bean，需要在Spring配置文件中使用包扫描来识别出指定包下的所有Bean。 创建Spring配置文件。在Spring配置文件中加入包扫描： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.linner&quot;/&gt; &lt;/beans&gt; 注意： 使用&lt;context:component-scan&gt;包扫描，需要在&lt;beans&gt;标签中加入属性： xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 接着在&lt;context:component-scan&gt;的xsi:schemaLocation属性中加入值： http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd &lt;context:component-scan&gt;： component：组件，Spring将管理的Bean视作自己的一个组件。 scan：扫描。 base-package：该属性指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。 包路径越精确，如：com.linner.dao.impl，扫描的范围越小速度越快。 包路径越广泛，如：com.linner，扫描的范围越大速度越慢。 一般扫描到项目的组织名称即Maven的&lt;groupId&gt;下（如：com.linner）即可。 包扫描不仅能扫描当前包，还能扫描当前包下的子包。 创建 Bean 对象（@Component） 在UserDao中添加@Component注解： import org.springframework.stereotype.Component; @Component(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { // ... } 编写新的测试类UserDaoTest： package com.linner.dao; import com.linner.domain.User; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class UserDaoTest { private static UserDao userDao; static { ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); userDao = (UserDao) ctx.getBean(&quot;userDao&quot;); } @Test public void testFindAll() { userDao.findAll(); System.out.println(&quot;------------&quot;); } @Test public void testFindById() { int id = 12; userDao.findById(id); System.out.println(&quot;------------&quot;); } @Test public void testDelete() { int id = 12; userDao.delete(id); System.out.println(&quot;------------&quot;); } @Test public void testSave() { User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userDao.save(user); System.out.println(&quot;------------&quot;); } @Test public void testUpdate() { User user = new User(); user.setId(12); user.setUsername(&quot;abc&quot;); user.setPassword(&quot;abc123&quot;); userDao.update(user); System.out.println(&quot;------------&quot;); } } @Component可以传递一个String类型的值。用于制定Bean的名称。 @Component可以直接使用而不指定名称。即，使用按类型获取Bean。但必须保证该类型在IOC中有且仅有一个Bean。如： @Component(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { // ... } UserDao userDao = ctx.getBean(UserDao.class); @Component注解如果不起名称，会有一个默认值，就是将当前类名首字母转为小写后的值。所以也可以按照名称获取。 @Component还有其他三个衍生注解。 @Controller：表现层 @Service：业务层 @Repository：数据层 它们的作用和@Component是一样的，仅作为对表现层、业务层和数据层的类进行区分。如： import org.springframework.stereotype.Repository; @Repository(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { // ... } import org.springframework.stereotype.Repository; @Repository public class UserDaoImpl implements UserDao { // ... } 纯注解开发（配置类、包扫描） Spring3.0开启了纯注解开发模式，使用Java类替代配置文件。 删除Spring配置文件并创建配置类： package com.linner.config; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.linner&quot;) public class SpringConfig { } @Configuration：设定该类为Spring配置类。 @ComponentScan：包扫描，用来替换配置文件中的&lt;context:component-scan&gt;。在一个配置类中仅能使用一次。多个扫描路径使用数据格式，如： @ComponentScan({&quot;com.linner.dao&quot;, &quot;com.linner.service&quot;}) 包扫描不仅能扫描当前包，还能扫描当前包下的子包 修改UserDaoTest： import com.linner.config.SpringConfig; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class UserDaoTest { private static UserDao userDao; static { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); userDao = (UserDao) ctx.getBean(&quot;userDao&quot;); } // ... } 使用Spring配置类，获取IOC容器应该使用AnnotationConfigApplicationContext对象： public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) 作用范围（@Scope） 注解开发控制Bean的作用范围使用@Scope。它的值有两个： &quot;singleton&quot;：默认值，将当前类设置为单例。 &quot;prototype&quot;：将当前类设置为多例。如： import org.springframework.context.annotation.Scope; @Repository @Scope(&quot;prototype&quot;) public class UserDaoImpl implements UserDao { // ... } 生命周期控制（@PostConstruct 和 @PreDestroy） 注解控制Bean生命周期使用： @PostConstruct：初始化。 @PreDestroy：销毁。 给UserDao加入初始化和销毁方法（方法名任意）： import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; @Repository public class UserDaoImpl implements UserDao { /** * 初始化方法 */ @PostConstruct public void init() { System.out.println(this + &quot;init...&quot;); } /** * 销毁方法 */ @PreDestroy public void destroy() { System.out.println(this + &quot;destroy...&quot;); } // ... } 与使用注解开发的情况一样，要想执行destroy()需要在程序执行的时候关闭容器： ctx.close(); 或： ctx.registerShutdownHook(); 注意:@PostConstruct和@PreDestroy注解如果找不到，需要导入下面的jar包== &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。 依赖注入 给UserService配置Bean： import org.springframework.stereotype.Service; @Service public class UserServiceImpl implements UserService { // ... } 按照类型注入 注解开发按照类型注入使用@Autowired注解。 给UserService注入UserDao： import org.springframework.beans.factory.annotation.Autowired; @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; // ... } @Autowired可以在实例类的成员变量上使用，也可以在Setter方法上使用，如： @Service public class UserServiceImpl implements UserService { private UserDao userDao; @Autowired public void setUserDao(UserDao userDao) { this.userDao = userDao; } // ... } 在实例类的成员变量上使用@Autowired，即使将Setter方法注释掉依然可以注入成功。因为自动装配基于反射设计创建对象并通过暴力反射为属性进行设值（即使是私有属性也能设值）。 使用@Autowired需要保证该类型在IOC容器中有且仅有一个同类型的Bean。 如果IOC容器中有对个同类型的Bean。那么@Autowired就会按照变量名和Bean的名称进行匹配。如： @Repository(&quot;userDao&quot;) public class UserDaoImpl implements UserDao { /*...*/ } @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; // ... } 也能注入成功。 如果有多个同类型Bean，并且@Autowired名称匹配不上，那么会报NoUniqueBeanDefinitionException错误。 使用使用IOC容器创建Bean中的UserServiceTest，成功执行说明配置成功。 按照名称注入 注解开发名称注入使用@Qualifier注解来完成。 import org.springframework.beans.factory.annotation.Qualifier; @Service public class UserServiceImpl implements UserService { @Autowired @Qualifier(&quot;userDao&quot;) private UserDao userDao; // ... } 在@Qualifier中指定Bean的名称。并且，@Qualifier必须和@Autowired一起使用才能起到按照名称注入的效果。 经过测试单独使用@Qualifier（不加@Autowired）的效果和按照类型注入的效果一样（可能会有其他细微的区别）。 注入简单数据类型 注解开发注入简单类型数据使用@Value注解。 import org.springframework.beans.factory.annotation.Value; @Repository public class UserDaoImpl implements UserDao { @Value(&quot;mysql&quot;) private String databaseName; @Value(&quot;10&quot;) private int connectionNum; // ... } @Value中的值使用String类型。如果要注入的是其他类型数据，需要按照其类型数据的格式编写。 注解读取 properties 配置文件 使用@Value的意义之一在于：读取properties配置文件的信息。 在resource目录下新建jdbc.properties： databaseName=mysql connectionNum=10 在配置类上添加@PropertySource注解： import org.springframework.context.annotation.PropertySource; @Configuration @ComponentScan(&quot;com.linner&quot;) @PropertySource(&quot;jdbc.properties&quot;) public class SpringConfig { } 修改UserDao： @Repository public class UserDaoImpl implements UserDao { @Value(&quot;${databaseName}&quot;) private String databaseName; @Value(&quot;${connectionNum}&quot;) private int connectionNum; // ... } 读取多个配置文件，使用数组形式给@PropertySource传递字符串数组。如： @PropertySource({&quot;jdbc.properties&quot;, &quot;xxx.properties&quot;}) @PropertySource注解属性中不支持使用通配符*，运行会报错。 @PropertySource注解属性中可以加入classpath:，代表从当前项目的根路径找文件： @PropertySource({&quot;classpath:jdbc.properties&quot;}) 注解管理第三方 Bean 基础配置： User.java: 同使用IOC容器创建Bean中的User.java。 UserDao： package com.linner.dao; import com.linner.domain.User; import org.apache.ibatis.annotations.*; import java.util.List; public interface UserDao { @Select(&quot;SELECT * FROM user_tb&quot;) List&lt;User&gt; findAll(); @Select((&quot;SELECT * FROM user_tb WHERE id = #{id}&quot;)) User findById(int id); @Delete(&quot;DELETE FROM user_tb WHERE id = #{id}&quot;) void delete(int id); @Insert(&quot;INSERT INTO user_tb(username, password) VALUES (#{username}, #{password})&quot;) void save(User user); @Update(&quot;UPDATE user_tb SET username = #{username}, password = #{password} WHERE id = #{id}&quot;) void update(User user); } UserService： UserService接口同使用IOC容器创建Bean中的UserService.java。 UserService实现类UserServiceImpl.java： package com.linner.service.impl; import com.linner.dao.UserDao; import com.linner.domain.User; import com.linner.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; @Override public List&lt;User&gt; findAll() { return userDao.findAll(); } @Override public User findById(int id) { return userDao.findById(id); } @Override public void delete(int id) { userDao.delete(id); } @Override public void save(User user) { userDao.save(user); } @Override public void update(User user) { userDao.update(user); } } 整合 Mybatis pom.xml依赖： &lt;!--Spring Framework--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--MySQL JDBC--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;!--Druid--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;!--MyBatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring JDBC--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--MyBatis Spring 整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--Junit 单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 建立User表： DROP TABLE IF EXISTS `user_tb`; CREATE TABLE `user_tb` ( `id` int(10) PRIMARY KEY AUTO_INCREMENT COMMENT '用户id', `username` varchar(10) NOT NULL COMMENT '用户名', `password` varchar(10) NOT NULL COMMENT '密码' ) CHARACTER SET = utf8; JDBC配置文件jdbc.properties： jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false&amp;useServerPrepStmts=true jdbc.username=root jdbc.password=root JDBC配置类JdbcConfig.java： package com.linner.config; import com.alibaba.druid.pool.DruidDataSource; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import javax.sql.DataSource; public class JdbcConfig { // 驱动信息： @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; /** * 获取DataSource对象 */ @Bean public DataSource dataSource() { DruidDataSource ds = new DruidDataSource(); // 设置驱动信息 ds.setDriverClassName(this.driver); ds.setUrl(this.url); ds.setUsername(this.username); ds.setPassword(this.password); return ds; } } @Bean：用于方法上，根据返回值类型自动产生Bean，并且方法的参数会按照类型自动装配。 Mybatis配置类MybatisConfig.java： package com.linner.config; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.mapper.MapperScannerConfigurer; import org.springframework.context.annotation.Bean; import javax.sql.DataSource; public class MybatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) { SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); // 设置模型类的别名扫描 ssfb.setTypeAliasesPackage(&quot;com.linner.domain&quot;); // 设置数据源 ssfb.setDataSource(dataSource); return ssfb; } /** * 获取MapperScannerConfigurer对象 */ @Bean public MapperScannerConfigurer mapperScannerConfigurer() { MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(&quot;com.linner.dao&quot;); return msc; } } SqlSessionFactoryBean：用于封装SqlSessionFactory需要的环境信息（原先的信息是在Mybatis配置文件中定义，如今可以在Java中用代码定义）。用于产生SqlSessionFactory对象。 setTypeAliasesPackage()：设置模型类的别名扫描 setDataSource()：设置DataSource。这里设置的DataSource通过方法的参数和@Bean注解实现了自动装配。并且自动装配的对像是Druid的DataSource。 MapperScannerConfigurer：用于加载Dao接口，创建代理对象保存到IOC容器中。此处设置的是dao包下的所有接口。这些接口都会被Mybatis创建成对象并且作为Bean保存在IOC容器中。即，使用ctx.getBean(UserDao.class)能获取到UserDao。 Spring配置类SpringConfig.java： package com.linner.config; import org.springframework.context.annotation.*; @Configuration @ComponentScan(&quot;com.linner&quot;) @PropertySource(&quot;classpath:jdbc.properties&quot;) @Import({JdbcConfig.class, MybatisConfig.class}) public class SpringConfig { } @Import：用于引入其他配置类。如果要引入多个配置类则需要使用数组形式。 测试类UserServiceTest： package com.linner; import com.linner.config.SpringConfig; import com.linner.domain.User; import com.linner.service.UserService; import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import java.util.List; public class UserServiceTest { private static UserService userService; static { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); userService = ctx.getBean(UserService.class); } @Test public void testFindAll() { List&lt;User&gt; users = userService.findAll(); for (User user : users) { System.out.println(user); } } @Test public void testFindById() { int id = 10; User user = userService.findById(id); System.out.println(user); } @Test public void testDelete() { int id = 10; userService.delete(id); } @Test public void testSave() { User user = new User(); user.setUsername(&quot;张三&quot;); user.setPassword(&quot;abc&quot;); userService.save(user); } @Test public void testUpdate() { User user = new User(); user.setId(21); user.setUsername(&quot;张三&quot;); user.setPassword(&quot;abc&quot;); userService.update(user); } } 整合 Junit 引入Spring与测试有关的整合包： &lt;!--Spring 测试整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; 修改测试类UserServiceTest： import org.junit.runner.RunWith; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import java.util.List; // 设置类运行器 @RunWith(SpringJUnit4ClassRunner.class) // 设置Spring环境对应的配置 // 加载配置类 @ContextConfiguration(classes = {SpringConfig.class}) // 加载配置文件 //@ContextConfiguration(locations={&quot;classpath:applicationContext.xml&quot;}) public class UserServiceTest { // 自动装配UserService，删除static静态代码块 @Autowired private UserService userService; } AOP AOP 介绍 一般常用的编程思想是OOP（面向对象编程，Object Oriented Programming）。 而AOP（面向切面编程，Aspect Oriented Programming），是一种编程范式，指导开发者如何组织程序结构。 编程思想主要的内容就是指导程序员该如何编写程序，所以AOP和OOP是两种不同的编程范式。 AOP的作用是在不改变原始设计的基础上为其进行功能增强。类似于Filter代理模式。 AOP术语： 连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等。 在SpringAOP中，理解为方法的执行。 例如要对项目中UserDao的功能在不进行任何修改的前提下实现增强。那么UserDao中要增强的方法即为连接点。 切入点（Pointcut）：匹配连接点的式子。 在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法。 连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。 通知（Advice）：在切入点处执行的操作，也就是共性功能。 在SpringAOP中，功能最终以方法的形式呈现。 通知类：定义通知的类。 切面（Aspect）：描述通知与切入点的对应关系。 通知是要增强的内容，会有多个；切入点是需要被增强的方法，也会有多个。通知和切入点的关系通过切面来描述。 目标对象（Target）：也叫原始对象。原始功能去掉共性功能对应的类产生的对象。即，配置AOP之前原设计的对象（要增强的对象）。 代理（Proxy）：通过通知类把目标对象增强后产生的对象。 目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现。 注解开发 AOP 基础配置：使用整合 Junit中的配置。 pom.xml导入坐标： &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; spring-context中已经包含了spring-aop，所以不需要再单独导入spring-aop。 AspectJ是AOP思想的一个具体实现，AspectJ比起Spring的AOP实现来说，更加好用。 创建通知类UserDaoAdvice： package com.linner.aop; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; @Component @Aspect public class UserDaoAdvice { @Pointcut(&quot;execution(* com.linner.dao.UserDao.*(..))&quot;) private void pt() {} @Before(&quot;pt()&quot;) public void method() { System.out.println(&quot;Before...&quot;); } } @Aspect：设置当前类为AOP切面类。 @Pointcut：设置切入点方法。切入点定义需要一个不具有实际意义的方法（无参、无返回值、空方法体）。即UserDaoAdvice中的pt()。 @Pointcut中的execution()用来定义切入点。 @Before：设置切面。即设置当前通知方法在原始切入点方法前运行。 切入点定义作为@Before的参数。 在SpringConfig加入@EnableAspectJAutoProxy注解： import org.springframework.context.annotation.*; @Configuration @ComponentScan(&quot;com.linner&quot;) @EnableAspectJAutoProxy @PropertySource(&quot;classpath:jdbc.properties&quot;) @Import({JdbcConfig.class, MybatisConfig.class}) public class SpringConfig { } AOP 切入点表达式 切入点表达式是对要进行增强的方法的描述方式。切入点表达式的一般形式如下： 动作关键字(访问修饰符 返回值类型 包名.类名.方法名(参数类型列表) 异常名) 由于通常都是对public方法进行定义，而public是默认的，所以可以省略。 切入点表达式定义的类可以是接口，也可以是其实现类。 AOP是在Spring中运行的，很显然切入点表达式定义的类必须存在IOC容器中。 如果匹配无参方法，直接省略参数。 Example： execution(void com.linner.dao.UserDao.delete(int)) 切入点表达式通配符 *：匹配任意单个独立的任意符号。 可以独立出现，匹配任意返回值类型、单个包名（不能用做匹配完整包名）、类名、方法名或单个参数类型（即匹配单个单词）； 也可以作为前缀或者后缀的匹配符出现。 如： execution（* com.linner.*.UserService.find*(*)) 匹配com.linner包下的任意包中的UserService类或接口中，所有以find开头的、带有一个参数的、任意返回值类型的方法。 ..：匹配多个连续的任意符号。 可以独立出现，常用于简化包名与参数的书写。 execution（* com..UserService.findById(..)) 匹配com包下的任意包中的UserService类或接口中所有名称为findById的（参数的数量、类型任意，返回值任意）方法。 +：专用于匹配子类类型。 execution(* *..*Service+.*(..)) 这个使用率较低。*Service+，表示所有以Service结尾的接口的子类。 书写技巧（所有代码按照标准规范开发，否则以下技巧全部失效）： 描述切入点通常描述接口，而不描述实现类，如果描述到实现类，就出现耦合了。 访问控制修饰符针对接口开发均采用public描述（简化书写）。 返回值类型对于增删改方法使用精准类型加速匹配，对于查询类使用*通配快速描述。 包名书写尽量不使用..匹配，效率过低，常用*做单个包描述匹配，或精准匹配。 接口名/类名书写名称与模块相关的采用*匹配，例如UserService书写成*Service，绑定业务层接口名。 方法名书写以动词进行精准匹配，名词采用*匹配，例如getById书写成getBy*，selectAll书写成selectAll。 参数规则较为复杂，根据业务方法灵活调整。 通常不使用异常作为匹配规则。 通知类型 AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置。 AspactJ提供了5种通知类型： 前置通知 后置通知 环绕通知 返回后通知 抛出异常后通知 // 代码1 try { // 代码2 // 原始的业务操作 // 代码3 } catch (Exception e) { // 代码4 } // 代码5 其中： 前置通知：代码1和代码2 返回后通知：代码3 抛出异常后通知：代码4 后置通知:代码5 环绕通知：上述整个代码块 通知方法的方法名称没有限制，只需在方法的上端使用注解定义即可。各通知类型的注解如下： 前置通知：@Before 后置通知：@After 环绕通知：@Around 返回后通知：@AfterReturning 抛出异常后通知：@AfterThrowing 这些注解的使用方式都是一样的。在对应的方法上定义，并且传入切入点（函数形式）。如：@Around(&quot;pt()&quot;)。 前置通知和后置通知的使用 前置通知和后置通知的使用方式一样： @Component @Aspect public class UserDaoAdvice { @Pointcut(&quot;execution(* com.linner.dao.UserDao.*(..))&quot;) private void pt() {} @Before(&quot;pt()&quot;) public void before() { System.out.println(&quot;Before...&quot;); } @After(&quot;pt()&quot;) public void after() { System.out.println(&quot;After...&quot;); } } 环绕通知的使用 import org.aspectj.lang.ProceedingJoinPoint; @Component @Aspect public class UserDaoAdvice { @Pointcut(&quot;execution(* com.linner.dao.UserDao.findById(int))&quot;) private void pt() {} @Around(&quot;pt()&quot;) public Object around(ProceedingJoinPoint pjp) throws Throwable { System.out.println(&quot;Before...&quot;); Object ret = pjp.proceed(); System.out.println(&quot;After....&quot;); return ret; } } 环绕通知必须传入一个ProceedingJoinPoint参数。使用pjp.proceed()才可以在环绕通知中掉用原始方法。并且proceed()可以获取到原始方法的返回值。 如果也想让代理后的方法返回跟原始方法一样的值。那么必须定义环绕方法的返回值类型，并且使用proceed()获取原始方法的返回值并返回。 环绕通知比较灵活，可以将其定义成其他类型的通知，并且可以做到其他通知做不到的事情。例如循环调用原始方法等。 环绕通知需要抛出异常是因为。原始方法有可能会出现异常，并且原始方法的异常并不确定。所以为了提高通用性，环绕通知默认抛出异常。 如果环绕方法定义的是void类型，并且原始方法有返回值。如果此时在环绕通知中没有返回值，那么在掉用代理后的方法后，返回的是null。 返回后通知的使用 @Component @Aspect public class UserDaoAdvice { @Pointcut(&quot;execution(* com.linner.dao.UserDao.findById(int))&quot;) private void pt() {} @AfterReturning(&quot;pt()&quot;) public void afterReturning() { System.out.println(&quot;After Returning...&quot;); } } 注意：返回后通知是需要在原始方法正常执行后才会被执行，如果原始方法执行的过程中出现了异常，那么返回后通知不会被执行。 后置通知是不管原始方法有没有抛出异常都会被执行。 异常后通知 @Component @Aspect public class UserDaoAdvice { @Pointcut(&quot;execution(* com.linner.service.UserService.findAll())&quot;) private void pt() {} @AfterThrowing(&quot;pt()&quot;) public void afterThrowing() { System.out.println(&quot;After Throwing...&quot;); } } 在UserServiceImpl.findAll()中模拟错误即可触发。例如使用int a = 1/0;模拟错误。 注意：异常后通知是需要原始方法抛出异常。如果没有抛异常，异常后通知将不会被执行。 ","link":"https://linna-cy.github.io/old-blog/Spring Framework/"},{"title":"Ajax 前后端交互","content":" 相关文章链接: Maven Tomcat Servlet 与 Tomcat HttpServlet 与 Tomcat Ajax AJAX (Asynchronous JavaScript And XML)，其含义为异步的 JavaScript 和 XML。其中 JavaScript 表明该技术和前端相关；XML 是指以此进行数据交换。 AJAX 作用有以下两方面： 与服务器进行数据交换：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用校验等等。 同步：浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后，浏览器页面才能继续做其他的操作。 异步：浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。 Ajax 简单使用 服务端： package web.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/ajaxServlet&quot;) public class AjaxServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 返回给客户端响应数据 resp.getWriter().write(&quot;Hello Ajax!&quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 客户端： //1. 创建核心对象 let xhttp; if (window.XMLHttpRequest) { xhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //2. 发送请求 xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/ajax-demo/ajaxServlet&quot;); xhttp.send(); //3. 获取响应 xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { // 处理从服务端发送过来的响应数据 alert(this.responseText); } }; Axios Axios 是一个对原生的AJAX进行封装，简化书写的前端框架。 使用 Axios 进行交互 Axios 的使用分为以下两步： 引入 Axios 的 js 文件 &lt;script src=&quot;js/axios.js&quot;&gt;&lt;/script&gt; 使用 Axios 发送请求，并获取响应结果： 发送 GET 请求的基本形式： axios({ method: &quot;get&quot;, // 请求参数会传递给服务器，此处请求参数可以转义也可以不转义 url: &quot;http://localhost:8080/axios-demo/demo?message=Hello%20World&quot; }).then(function (resp){ // 对响应数据进行处理 alert(resp.data); }) 发送 POST 请求的基本形式： axios({ method: &quot;post&quot;, url: &quot;http://localhost:8080/axios-demo/demo&quot;, data: &quot;message=Hello World&quot; }).then(function (resp){ alert(resp.data); }); 其中： axios() 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数： method 属性：用来设置请求方式的。 取值为 get 或者 post。 url 属性：用来书写请求的资源路径。 如果是 get 请求，需要将请求参数拼接到路径的后面，格式为： url?参数名=参数值&amp;参数名2=参数值2。 data 属性：作为请求体被发送的数据。 即，如果是 post 请求的话，数据需要作为 data 属性的值。 then() 需要传递一个匿名函数。 then() 中传递的匿名函数称为回调函数，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。 而该回调函数中的 resp 参数是对响应的数据进行封装的对象，通过 resp.data 可以获取到响应的数据。 请求方法别名 为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下： get 请求： axios.get(url[,config]) delete 请求： axios.delete(url[,config]) head 请求： axios.head(url[,config]) options 请求： axios.option(url[,config]) post 请求： axios.post(url[,data[,config]) put 请求： axios.put(url[,data[,config]) patch 请求： axios.patch(url[,data[,config]) this 作用域问题 使用请求方法别名和箭头函数可以解决this作用域问题，防止this指向错误： GET请求： axios.get( &quot;http://localhost:8080/axios-demo/demo?message=Hello World&quot; ).then(resp =&gt; { // 对响应数据进行处理 alert(resp.data); }) POST请求： axios.post( &quot;http://localhost:8080/axios-demo/demo&quot;, &quot;message=Hello World&quot; ).then(resp =&gt; { // 对响应数据进行处理 alert(resp.data); }) JSON JSON（JavaScript Object Notation）是指 JavaScript 对象表示法。 JSON的优点：数据格式简单，所占的字节数少等。 JSON 的格式 JSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的： { &quot;key_1&quot;: value_1, &quot;key_2&quot;: value_2, &quot;key_3&quot;: value_3, ..., &quot;key_n&quot;: value_n } JSON 格式中的键要求必须使用双引号括起来。 Value 的数据类型分为如下： 数字（整数或浮点数） 字符串（使用双引号括起来） 逻辑值（true或者false） 数组（在方括号{}中） 对象（在花括号[]中） null 在 js 中定义 json： var 变量名 = `{ &quot;key1&quot;:value1, &quot;key2&quot;:value2, ... }`; 在 JS 中使用 JOSN JS 提供了一个对象 JSON ，该对象有如下两个方法： parse(str)：将 JSON串转换为 js 对象。 使用方式： var jsObject = JSON.parse(jsonStr); stringify(obj)：将 js 对象转换为 JSON 串。 使用方式： var jsonStr = JSON.stringify(jsObject) 携带JSON发送异步请求 可以使用 JSON.stringify() 将js对象转换为 JSON 串，再将该 JSON 串作为 axios 的 data 属性值进行请求参数的提交。 但其实只需要将需要提交的参数封装成 js 对象，并将该 js 对象作为 axios 的 data 属性值。axios 会自动将 js 对象转换为 JSON 串进行提交。 发送异步请求时，如果请求参数是 JSON 格式，那请求方式必须是 POST。因为 JSON 串需要放在请求体中。 Fastjson Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。 依赖坐标： &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; JOSN 和 Java对象的相互转换包含： 请求数据（反序列化）： JSON字符串转为Java对象。 将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法即可。 String toJSONString(Object object) 响应数据（序列化）： Java对象转为JSON字符串。 将 Java 对象转换为 JSON 串，只需要使用 Fastjson 提供的 JSON 类中的 toJSONString() 静态方法即可。 &lt;T&gt; T parseObject(String jsonStr, Class&lt;T&gt; clazz) Example： 导入坐标。 编写pojo类： package pojo; public class User { private Integer id; private String username; private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username='&quot; + username + '\\'' + &quot;, password='&quot; + password + '\\'' + '}'; } } 编写FastJsonDemo： package web.servlet; import com.alibaba.fastjson.JSON; import pojo.User; public class FastJsonDemo { public static void main(String[] args) { // 1. Java对象转JSON字符串 User user = new User(); user.setId(1); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123&quot;); String jsonString = JSON.toJSONString(user); System.out.println(jsonString); // 输出：{&quot;id&quot;:1,&quot;password&quot;:&quot;123&quot;,&quot;username&quot;:&quot;zhangsan&quot;} // 2. 将JSON字符串转为Java对象 User u = JSON.parseObject( &quot;{\\&quot;id\\&quot;:1,\\&quot;password\\&quot;:\\&quot;123\\&quot;,\\&quot;username\\&quot;:\\&quot;zhangsan\\&quot;}&quot;, User.class); System.out.println(u); } } ","link":"https://linna-cy.github.io/old-blog/Ajax 前后端交互/"},{"title":"Filter 过滤器","content":" 相关文章链接: Maven Tomcat Servlet 与 Tomcat HttpServlet 与 Tomcat Filter 概述 Filter 表示过滤器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。设置 Filter 会在访问资源之前会先经过 Filter，将资源拦截，从而实现权限控制、统一编码处理、敏感字符处理等功能。 过滤器Filter是在请求进入容器后，但在进入Servlet之前进行预处理。 进行 Filter 开发分成以下三步实现： 定义类，实现 Filter接口，并重写其所有方法： package filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; // 拦截的路径，这里 &quot;/*&quot; 拦截了项目中所有资源请求 @WebFilter(&quot;/*&quot;) public class FilterDemo implements Filter { // Filter的初始化方法 @Override public void init(FilterConfig filterConfig) throws ServletException { // ... } // Filter的操作方法，在init后执行 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // ... } // 销毁Filter执行的方法 @Override public void destroy() { // ... } } 配置Filter拦截资源的路径： 在类上定义 @WebFilter 注解。 此处注解的 value 属性值 /* 表示拦截所有的资源。 package filter; // import ... // 拦截的路径，这里 &quot;/*&quot; 拦截了项目中所有资源请求 @WebFilter(&quot;/*&quot;) public class FilterDemo implements Filter { // ... } 在doFilter()方法中对拦截的资源进行处理，并选择是否放行： package web.filter; // import ... // 拦截的路径，这里 &quot;/*&quot; 拦截了项目中所有资源请求 @WebFilter(&quot;/*&quot;) public class FilterDemo implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // 1. 放行前，对request数据进行处理 // ... // 放行前response中没有数据 // 2. 放行 filterChain.doFilter(servletRequest, servletResponse); // 调用该方法，会执行其它拦截器或访问路径中对应的Servlet或访问对应资源 // 如果该方法没有被调用，那么对应资源将不可被访问，且后续的其它拦截器都不会被执行 // 3. 放行后，对response数据进行处理 // ... } // ... } 项目依赖： &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;80&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在doFilter()中，如果要使用request和response，可以将它们强转为对应的HttpServletRequest和HttpServletResponse对象来进行操作。 Filter 执行流程 Filter 的执行流程如下： 浏览器访问资源 资源被Filter拦截 Filter 执行放行前逻辑 判断是否放行 放行： 可能会执行以下操作： 如果有，则执行后续的Filter 如果资源没有被后续其它Filter拦截，那么访问对应资源 不放行： 后续的其它 Filter 将不会被执行，资源也不可被访问 Filter 执行放行后逻辑 Filter 拦截路径配置 拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 @WebFilter 注解进行配置。 拦截路径有如下四种配置方式： 拦截具体的资源：/index.html，只有访问index.html时才会被拦截 目录拦截：/user/*，访问/user下的所有资源，都会被拦截 后缀名拦截：*.html，访问后缀名为jsp的资源，都会被拦截 拦截所有：/*，访问项目下所有资源，都会被拦截 过滤器链 过滤器链是指在一个Web应用，可以对同个拦截路径配置多个过滤器，这多个过滤器组成了过滤器链。 过滤器链基于函数回调，多个过滤器之间的优先级顺序以过滤器类名的自然顺序（A-Z 0-9）为规则进行排序。 例如，有Filter1和Filter2两个拦截路径相同的Filter： 执行 Filter1 的放行前逻辑代码 执行 Filter1 的放行代码 执行 Filter2 的放行前逻辑代码 执行 Filter2 的放行代码 访问到资源 执行 Filter2 的放行后逻辑代码 执行 Filter1 的放行后逻辑代码 ","link":"https://linna-cy.github.io/old-blog/Filter/"},{"title":"会话跟踪技术 —— Cookie 和 Session","content":" 相关文章链接: Maven Tomcat Servlet 与 Tomcat HttpServlet 与 Tomcat 会话跟踪技术 会话是指一个终端用户与交互系统进行通讯的过程，例如从浏览器发出请求到服务端响应数据给前端这个过程即为一个会话。 会话跟踪指的是一种维护浏览器状态的方法。服务器会收到多个请求，这多个请求可能来自多个浏览器。服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。 浏览器和服务器不支持数据共享的原因： HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求。 HTTP协议设计成无状态的目的是让每次请求之间相互独立，互不影响。 请求与请求之间独立后，就无法实现多次请求之间的数据共享。 实现会话跟踪技术的方式有： 客户端会话跟踪技术：Cookie。 Cookie是存储在浏览器端。 服务端会话跟踪技术：Session。 Session是存储在服务器端。 Cookie Cookie是一种客户端会话技术，将数据保存到客户端，在以后的每次请求中都携带Cookie数据进行访问。 服务器将Cookie发送给浏览器，是通过在响应头中添加Set-Cookie键值对实现的，如Set-Cookie: message=&quot;Hello Wrold&quot;。在多个Cookie之间使用;分割。 浏览器在接收了服务器发送来的Cookie后，会将数据存储在浏览器的内存中。在接下来的每次请求中，浏览器都会将获取到的Cookie发送到服务器（同一次会话中或在Cookie存活时间内）。浏览器将Cookie发送到服务器，是通过在请求头中设置Cookie键值对实现的，如Cookie: message=&quot;Hello Wrold&quot;。同样的，在多个Cookie之间使用;分割。 创建Cookie对象： Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;) 发送Cookie到客户端（使用Response对象）： response.addCookie(cookie) 从客户端获取Cookie（使用Request对象）： request.getCookies() 创建Maven web项目。 项目依赖： &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!--servlet--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 发送 Cookie 发送Cookie使用的是HttpServletResponse对象提供的addCookie()： response.addCookie(cookie) package web.cookie; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; @WebServlet(&quot;/cookieServlet&quot;) public class CookieServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 创建Cookie对象 String value = &quot;Hello World&quot;; System.out.println(&quot;存储数据: &quot; + value); Cookie cookie = new Cookie(&quot;message&quot;, value); // 设置存活时间, 7天 cookie.setMaxAge(60*60*24*7); // 2. 发送Cookie, response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 在发送Cookie时，可以使用setMaxAge()方法设置Cookie存活的时间（单位：秒）。 如果要在Cookie中存储中文数据，需要将中文数据使用URLEncoder.encode()按照UTF-8（与前端页面的编码保持一致）编码。 package web.cookie; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; @WebServlet(&quot;/cookieServlet&quot;) public class CookieServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 创建Cookie对象 // 存储中文 String value = &quot;你好&quot;; // URL编码 value = URLEncoder.encode(value, StandardCharsets.UTF_8); // System.out.println(&quot;存储数据: &quot; + value); Cookie cookie = new Cookie(&quot;message&quot;, value); // 设置存活时间, 7天 cookie.setMaxAge(60*60*24*7); // 2. 发送Cookie, response response.addCookie(cookie); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 获取 Cookie 从客户端获取Cookie使用的是HttpServletRequest对象提供的getCookies()： request.getCookies() 它返回一个Cookie数组（Cookie[]）。 package web.cookie; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.nio.charset.StandardCharsets; @WebServlet(&quot;/cookieServlet&quot;) public class CookieServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 获取Cookie数组 Cookie[] cookies = request.getCookies(); // 2. 遍历数组 for (Cookie cookie : cookies) { // 3. 获取数据 String name = cookie.getName(); if (&quot;message&quot;.equals(name)) { String value = cookie.getValue(); // URL解码 value = URLDecoder.decode(value, StandardCharsets.UTF_8); System.out.println(name + &quot;:&quot; + value); break; } } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } Cookie对象提供的getName()和getValue()可以分别获取Cookie的名称和值。 获取Cookie后应该使用URLDecoder.decode进行解码，这样确保Cookie里出现中文数据时不会乱码。 Cookie 常用方法 方法 说明 Cookie[] getCookies() HttpServletRequest提供的获取客户端Cookie的方法 void addCookie(Cookie cookie) HttpServletResponse提供的，将Cookie发送到客户端的方法 Cookie(String name, String value) Cookie类的构造函数，用于创建Cookie，需要指定名称name和值value void setMaxAge(int expiry) 设置Cookie过期的时间（单位：秒）。值为-1（默认情况下）或其它负数，Cookie只会在当前Session会话中持续有效。值为0表示删除对应Cookie int getMaxAge() 返回Cookie的最大生存周期（单位：秒）。默认情况下（不设置过期时间），-1 表示 Cookie 将持续到浏览器关闭。 String getName() 返回Cookie的名称（名称在创建后不能改变） void setValue(String newValue) 设置与Cookie关联的值 String getValue() 获取与Cookie关联的值 Session Session是一种服务端会话跟踪技术，其数据保存在服务端。Session因为是存储在服务端所以比起Cookie，Session要更加安全。但与之相对的，Session不适合长期保存数据。 Session是基于Cookie实现的。Session要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取Session的对象是同一个。在第一次获取Session对象时，Session对象会有一个唯一的标识，如id:123。Tomcat服务器发现业务处理中使用了Session对象，就会把Session的唯一标识id:123当做一个Cookie，添加Set-Cookie:JESSIONID=123到响应头中，并响应给浏览器。所以，浏览器通过Cookie告诉服务器Session的id，服务器也通过Cookie获取相应的Session，从而实现一次会话多次请求之间的数据共享。 JavaEE中提供了HttpSession接口，来实现一次会话的多次请求之间数据共享功能： 获取Session对象（使用Request对象）： HttpSession session = request.getSession(); Session对象提供的功能: 存储数据到 session 域中： void setAttribute(String name, Object o) 根据 key，获取值： Object getAttribute(String name) 根据 key，删除该键值对： void removeAttribute(String name) 存储数据 package web.session; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; @WebServlet(&quot;/sessionServlet&quot;) public class SessionServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 存储数据到Session中 // 1. 获取Session对象 HttpSession session = request.getSession(); // 2. 存储数据 session.setAttribute(&quot;message&quot;, &quot;Hello World!&quot;); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 由于Session中的数据是存储在服务器，所以在Session中存储和读取中文数据不需要进行编码和解码。 获取数据 package web.session; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; @WebServlet(&quot;/sessionServlet&quot;) public class SessionServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 从Session中获取数据 // 1. 获取Session对象 HttpSession session = request.getSession(); // 2. 获取数据 Object message = session.getAttribute(&quot;message&quot;); System.out.println(message); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } Session 的钝化与活化 正常来说，Session是存储在内存中的，只要服务器关闭，那么所有会话的Session都会失效。但是Tomcat在正常关闭的情况下，Session并不会失效，这是因为Session的钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中。钝化的数据路径为：项目目录\\target\\tomcat\\work\\Tomcat\\localhost\\项目名称\\SESSIONS.ser。 再次启动服务器后，从文件中加载数据到Session中，这就是Session的活化。而数据加载到Session中后，路径中的SESSIONS.ser文件会被删除掉。 Session 的销毁 默认情况下，无操作，30分钟后自动销毁Session。对于这个失效时间，是可以通过在项目的web.xml中配置进行修改： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;session-config&gt; &lt;session-timeout&gt;100&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; 如果没有配置，默认是30分钟，默认值是在Tomcat的web.xml配置文件中写死的。通过在Tomcat的web.xml中搜索&lt;session-timeout&gt;即可找到对应设置。 也可以通过调用HTTPSession的invalidate()方法进行手动销毁。 Session 常用方法 方法 说明 HttpSession getSession() HttpServletRequest提供的方法，用于获取当前会话的HttpSession对象 Object getAttribute(String name) 返回在该 session 会话中具有指定名称（name）的对象；如果没有指定名称的对象，则返回 null void setAttribute(String name, Object value) 使用指定的名称绑定一个对象到该 session 会话 void removeAttribute(String name) 将从该 session 会话移除指定名称的对象 Enumeration getAttributeNames() 返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称 String getId() 返回一个包含分配给该 session 会话的唯一标识符的字符串 void invalidate() 销毁当前Session对象。该方法指示该 session 会话无效，并解除绑定到它上面的任何对象 Cookie 和 Session Cookie 和 Session 的区别： 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端。 安全性：Cookie不安全，Session安全。 数据大小：Cookie最大3KB，Session无大小限制。 存储时间：Cookie可以通过setMaxAge()长期存储，Session默认30分钟。 服务器性能：Cookie不占服务器资源，Session占用服务器资源。 ","link":"https://linna-cy.github.io/old-blog/Cookie and Session/"},{"title":"Ubuntu zsh 中文支持","content":"安装中文支持： apt-get install language-pack-zh-hans -y 查看系统语言包： locale -a 修改.zshrc，加入： export LC_ALL=zh_CN.UTF-8 export LANG=zh_CN.UTF-8 修改/etc/default/locale： LANG=&quot;zh_CN.UTF-8&quot; ","link":"https://linna-cy.github.io/old-blog/Ubuntu zsh 中文/"},{"title":"HttpServlet 与 Tomcat","content":" 相关文章链接: Maven Tomcat Servlet 与 Tomcat HttpServlet 简介 HttpServlet是对HTTP协议封装的Servlet实现类。 Servlet的体系结构： 在开发中，关注更多的是Servlet.service()方法。而每实现一个Servlet就必须实现Servlet接口，重写接口中的5个方法。 但其实可以通过继承HttpServlet来编写Servlet，简化Servlet的开发流程。并且，如果是开发B/S架构的Web项目，针对的都是HTTP协议。 使用HttpServlet的格式如下： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.*; import java.io.IOException; @WebServlet(&quot;/demo&quot;) public class ServletDemo extends HttpServlet { // 需要复写以下两个方法: @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;Get...&quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;Post...&quot;); } } 启动Tomcat，使用浏览器访问http://localhost:8080/web-demo/demo可以在控制台看到doGet()方法被执行。 在项目的webapp目录下新建index.html，写入： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;TestPost&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/web-demo/demo&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot;/&gt;&lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 启动Tomcat，访问http://localhost:8080/web-demo/，在表单输入内容后提交。即可在控制台看到doPost()被执行。 使用Servlet实现HttpServlet 既然HttpServlet继承自Servlet，那么也可以通过编写Servlet类来实现HttpServlet： package com.linner.web; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; public class MyHttpServlet implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { // 根据请求方式的不同,分别进行处理 HttpServletRequest request = (HttpServletRequest) servletRequest; // 1. 获取请求方式 String method = request.getMethod(); // 2. 判断 if (&quot;GET&quot;.equals(method)) { // GET 方式的处理逻辑 doGet(servletRequest, servletResponse); } else if (&quot;POST&quot;.equals(method)) { // POST 方式的处理逻辑 doPost(servletRequest, servletResponse); } } protected void doPost(ServletRequest servletRequest, ServletResponse servletResponse) { } protected void doGet(ServletRequest servletRequest, ServletResponse servletResponse) { } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 翻阅HttpServlet.service()方法源码，可以发现HttpServlet不仅仅可以对GET和POST进行处理，还能处理其它五种请求：doHead()、doPut()、doDelete()、doOptions()和doTrace()。 HttpServletRequest 和 HttpServletResponse Request 和 Response 概述 Request是请求对象，Response是响应对象。在Servlet中也存在这样的两个对象： public class ServletDemo implements Servlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { // ... } // ...... } Request作用：获取请求数据 浏览器会发送HTTP请求到后台服务器（如，Tomcat） HTTP的请求中会包含很多请求数据 如，HTTP协议请求： 请求行 请求头 请求体 后台服务器会对HTTP请求中的数据进行解析并把解析结果存入到一个对象中 所存入的对象即为Request对象，所以我们可以从Request对象中获取请求的相关参数 获取到数据后就可以继续后续的业务 如，获取用户名和密码就可以实现登录操作的相关业务 Response作用：设置响应数据 业务处理完后，后台就需要给前端返回业务处理的结果（即，响应数据） 把响应数据封装到Response对象中 后台服务器会解析Response对象，按照格式（响应行+响应头+响应体）拼接结果 浏览器最终解析结果，把内容展示在浏览器给用户浏览 而HttpServlet使用的 Request 和 Response 对象与Servlet有所不同。HttpServlet使用的是 HttpServletRequest 和 HttpServletResponse。 Example： @WebServlet(&quot;/demo&quot;) public class HttpServletDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 使用request对象 获取请求数据 String name = request.getParameter(&quot;name&quot;); // Parameter在地址中以 ? 开始：url?name=zhangsan // 使用response对象 设置响应数据 response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;&lt;h1&gt;&quot;+name+&quot;,欢迎您！&lt;/h1&gt;&quot;); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } Request 和 Response 继承体系 HttpServletRequest和ServletRequest之间是继承关系，HttpServletResponse和ServletResponse是继承关系。 Request之间的继承关系如下： Response之间的继承关系如下： HttpServletRequest HTTP常用的请求方式为： GET POST HTTP请求数据总共分为三部分内容： 请求行 请求头 请求体 在请求数据中，还包含着请求参数： 对于GET：请求参数包含在请求头中。 对于POST：请求参数一般包含在请求体中。 获取请求行数据 如打开以下链接： http://localhost:8080/HttpServlet/httpservlet.html?username=linner 其请求行大致内容如下： GET /HttpServlet/httpservlet.html?username=linner HTTP/1.1 包含以下三部分内容： 请求方式：GET 请求资源路径：/HttpServlet/httpservlet.html?username=linner 请求资源路径包含： 虚拟目录（项目访问路径）：/HttpServlet URI（统一资源标识符）：/HttpServlet/httpservlet.html 请求参数：username=linner HTTP协议及版本：HTTP/1.1 这三部分内容，HttpServletRequest对象都提供了对应的API方法来获取： 获取请求方式： String getMethod() 返回：GET 获取虚拟目录（项目访问路径）: String getContextPath() 返回：/HttpServlet 获取URL（统一资源定位符）: StringBuffer getRequestURL() 返回：http://localhost:8080/HttpServlet/httpservlet.htm 获取URI（统一资源标识符）: String getRequestURI() 返回：/HttpServlet/httpservlet.html 获取请求参数（GET方式）: String getQueryString() 返回：username=linner（多个参数也一并返回） Example： package com.linner.web; import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.annotation.*; import java.io.IOException; @WebServlet(&quot;/test&quot;) public class TestHttpServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;---------------------------------------&quot;); System.out.println(&quot;请求行：&quot;); System.out.println(&quot;请求方式：&quot; + request.getMethod()); System.out.println(&quot;虚拟目录：&quot; + request.getContextPath()); System.out.println(&quot;URL：&quot; + request.getRequestURL()); System.out.println(&quot;URI：&quot; + request.getRequestURI()); System.out.println(&quot;请求参数：&quot; + request.getQueryString()); System.out.println(&quot;---------------------------------------&quot;); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 获取请求头数据 请求头数据由多个 key: value 组成，如客户端浏览器的版本信息： User-Agent: Mozila/5.0 Chrome/105.0.0.0 Edg/105.0.1343.42 HttpServletRequest 获取请求头的方法为： String getHeader(String name) name：是请求头中的key。 返回值：返回name对应key的value。 使用getHeader()获取客户端浏览器的版本信息： package com.linner.web.request; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/test&quot;) public class RequestDemo7 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String agent = request.getHeader(&quot;user-agent&quot;); // name 不区分大小写 System.out.println(agent); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 输出： Mozila/5.0 Chrome/105.0.0.0 Edg/105.0.1343.42 获取请求体数据 浏览器发送的GET请求，是没有请求体的。只有在发送POST请求时才带有请求体。 请求体中的数据格式如： username=linner&amp;password=123456 与资源路径中，请求参数的格式一样。 HttpServletRequest提供了两种方式来获取请求体中的数据： 获取字节输入流： 当前端发送的是字节数据，如传递的是文件数据时使用。 ServletInputStream getInputStream() 获取字符输入流： 当前端发送的是纯文本数据时使用。 BufferedReader getReader() 如果要在客户端浏览器发送POST请求，需要编写一个&lt;form&gt;表单。 Example： 在项目的webapp目录下添加index.html： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- action: 表单提交的请求地址 method: 请求方式，指定为post --&gt; &lt;form action=&quot;/request-demo/test&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 在doPost方法中获取数据： 由于index.html提交的是纯文本数据，所以要使用getReader()方法获取。 package com.linner.web.request; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; @WebServlet(&quot;/test&quot;) public class RequestDemo8 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 获取字符输入流 BufferedReader br = request.getReader(); // 2. 读取数据 String line = br.readLine(); System.out.println(line); } } BufferedReader流是通过HttpServletRequest对象来获取的，当请求完成后HttpServletRequest对象就会被销毁，HttpServletRequest对象被销毁后，BufferedReader流就会自动关闭，所以就不需要手动关闭流了。 getReader()获取请求参数后，还需要使用readLine()读取参数数据。 通过浏览器访问：http://localhost:8080/request-demo/。在表单中输入内容，然后提交，就可以在控制台看到前端所发送的请求数据： username=linner&amp;password=123456 获取请求参数 使用getQueryString()方法和getReader()分别获取GET和POST的请求参数： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/test&quot;) public class RequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String result = req.getQueryString(); System.out.println(result); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { BufferedReader br = req.getReader(); String result = br.readLine(); System.out.println(result); } } 上述代码存在的问题： doGet()和doPost中出现了重复代码。 在实际业务中，可能会出现很多相同的业务代码， doGet()和doPost都必须存在。 GET请求和POST请求获取请求参数的方式不一样。 在doPost()中调用doGet()，然后在doGet()判断请求的方式，并分别做处理： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/test&quot;) public class RequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 获取请求方式 String method = req.getMethod(); // 2. 获取请求参数 String params = &quot;&quot;; if(&quot;GET&quot;.equals(method)){ params = req.getQueryString(); }else if(&quot;POST&quot;.equals(method)){ BufferedReader reader = req.getReader(); params = reader.readLine(); } // 3. 处理请求 System.out.println(params); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } HttpServletRequest已经对获取请求参数的方式进行了封装： 获取所有参数Map集合 Map&lt;String, String[]&gt; getParameterMap() 根据名称获取参数值（返回值为数组，返回多个参数） String[] getParameterValues(String name) 根据名称获取参数值（单个值） String getParameter(String name) 同样是在doPost()中调用doGet()，然后在doGet()处理参数，但是在获取参数时不用对请求方式进行判断。 Example： webapp/index.html： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; test:get &lt;form action=&quot;/request-demo/test&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; get-1 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; get-2 &lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; test:post &lt;form action=&quot;/request-demo/test&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;1&quot;&gt; post-1 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;2&quot;&gt; post-2 &lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 使用getParameterValues()和getParameter()获取请求参数： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/test1&quot;) public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;---------------&quot;); // 验证请求的方式： String method = req.getMethod(); System.out.println(method); // 获取多个 value： System.out.print(&quot;hobby: &quot;); String[] hobbies = request.getParameterValues(&quot;hobby&quot;); for (String hobby : hobbies) { System.out.print(hobby + &quot;, &quot;); } System.out.println(&quot;\\b\\b &quot;); // 获取单个 value： String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username: &quot; + username); System.out.println(&quot;password: &quot; + password); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 使用getParameterMap()一次性获取所有参数： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Map; @WebServlet(&quot;/test&quot;) public class RequestDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;-------------------------------------------&quot;); // 验证请求的方式： String method = request.getMethod(); System.out.println(method); // 获取所有参数的Map集合 Map&lt;String, String[]&gt; map = request.getParameterMap(); for (String key : map.keySet()) { System.out.print(key + &quot;:&quot;); // 获取key对应的所有values String[] values = map.get(key); for (String value : values) { System.out.print(value + &quot;, &quot;); } System.out.println(&quot;\\b\\b &quot;); } } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 请求转发 请求转发（forward）是一种在服务器内部的资源跳转方式。如： 服务器内资源A获取请求。 资源A（处理一部分数据后）将请求转发给资源B去处理。 资源B处理完成后将将结果响应给浏览器。 请求从资源A到资源B的过程即为请求转发。 请求转发的特点： 浏览器地址栏路径不变。 只能转发到当前服务器的内部资源。 一次请求，可以在转发的资源间使用request共享数据。 使用request.getRequestDispatcher(&quot;/path&quot;).forward(request, response)进行请求转发： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/demo1&quot;) public class RequestDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;demo1...&quot;); // 存储数据 request.setAttribute(&quot;msg&quot;, &quot;Hello&quot;); // 请求转发（资源转发到demo2） request.getRequestDispatcher(&quot;/demo2&quot;).forward(request, response); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/demo2&quot;) public class RequestDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;demo2...&quot;); // 获取数据 Object msg = request.getAttribute(&quot;msg&quot;); System.out.println(msg); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } 通过http://localhost:8080/request-demo/demo1访问。 由于请求转发是在服务器内部的资源转发，所以getRequestDispatcher()中的路径不需要包含虚拟目录。 请求转发使用HttpServletRequest（Request）对象进行资源的传递。这个用来存储资源的空间被称为Request域。 HttpServletRequest对象提供了对于Request中的域属性操作的方法有： 在 Request 域属性空间中放入数据： void setAttribute(String name, Object object) 其生命周期与 Request 的生命周期相同。 从 Request 的域属性空间中获取指定名称的数据： Object getAttribute(String name) 从 Request 的域属性空间中删除指定名称的数据： void removeAttribute(String name) 创建请求转发器： RequestDispatcher getRequestDispatcher(String path) 请求转发器中有一个方法，用于完成将请求对象转发给下一个资源： void forward(HttpServletRequest request, HttpServletResponse response) Tomcat7 请求参数中文乱码问题 Tomcat8.0 之后，已经将默认编码设置为UTF-8。 POST请求参数是通过流的方式获取数据： Tomcat在获取流的时候采用的编码是ISO-8859-1。 页面设置的编码格式一般为UTF-8。 ISO-8859-1编码是不支持中文的，所以会出现乱码。 解决方案：通过HttpServletRequest提供的setCharacterEncoding()，在Tomcat在获取流数据之前的编码设置为UTF-8。 package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.net.URLDecoder; import java.nio.charset.StandardCharsets; @WebServlet(&quot;/test&quot;) public class RequestDemo4Copy extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 设置字符输入流的编码 request.setCharacterEncoding(&quot;UTF-8&quot;); // 2. 获取请求参数 BufferedReader br = request.getReader(); String line = br.readLine(); // getReader()获取的是编码后的URL，如果要显示中文，需要对URL按照UTF-8进行解码 String decode = URLDecoder.decode(line, StandardCharsets.UTF_8); System.out.println(&quot;解决乱码后: &quot; + decode); } } GET请求参数包含在URL中： getQueryString()获取的并不是字符输入流，所以setCharacterEncoding()并不适用。 浏览器在发送HTTP的过程中会根据页面&lt;meta&gt;标签指定的charset的方式（一般为UTF-8）对URL进行编码。 URL编码： 将字符串按照编码方式转为二进制。 每个字节（8位）转为2个16进制数（一个16进制数代表4位）并在前边加上%。 Tomcat在接收编码后的URL后，会默认按照ISO-8859-1进行URL解码。 可以使用以下两个函数可以模拟URL编码、解码的过程： 编码： java.net.URLEncoder.encode(string, charset) 解码： java.net.URLDecoder.decode(string, charset) 解决方案： 把字符数据（URL编码）按照ISO-8859-1编码转换成字节。 字节按照浏览器对应的URL编码（UTF-8）转换成对应的字符。 这样在转换的过程中保持编码一致，就可以解决中文乱码问题： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.nio.charset.StandardCharsets; @WebServlet(&quot;/test&quot;) public class RequestDemo4Copy extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String qs = request.getQueryString(); // 把字符数据（URL编码）按照ISO-8859-1编码转换成字节 byte[] bytes = qs.getBytes(StandardCharsets.ISO_8859_1); // 按照UTF-8编码转换成对应的字符 String s = new String(bytes, StandardCharsets.UTF_8); // 转换后的字符是URL编码后的字符，需要再次解码 qs = URLDecoder.decode(s, StandardCharsets.UTF_8); System.out.println(&quot;解决乱码后: &quot; + qs); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } } 通用方式解决乱码问题： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.nio.charset.StandardCharsets; @WebServlet(&quot;/test&quot;) public class RequestDemo4Copy extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1. 获取username String username = request.getParameter(&quot;username&quot;); // 2. 解决乱码 username = new String(username.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); System.out.println(&quot;解决乱码后: &quot; + username); } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doGet(request, response); } } HttpServletResponse HTTP响应数据总共分为三部分内容，分别是： 响应行 如，HTTP/1.1 200 OK，从左到右分别为： HTTP协议及版本 响应状态码 设置响应状态码，HttpServletResponse对象提供了以下方法设置： void setStatus(int sc) 状态码描述 响应头 由多个 key: value 组成。HttpServletResponse对象提供了以下方法设置键值对： void setHeader(String name, String value) 响应体 获取字符输出流： PrintWriter getWriter() 获取字节输出流： ServletOutputStream getOutputStream() Respones重定向 Response重定向（redirect）是一种资源跳转方式。如： 浏览器发送请求给服务器，服务器中对应的资源A接收到请求。 资源A现在无法处理该请求，就会给浏览器响应一个302的状态码和location（一个访问资源B的路径）。 浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B。 重定向的特点: 浏览器地址栏路径发送变化（由资源A的路径变化为资源B的路径）。 进行重定向访问时，由浏览器发送两次请求，所以地址发生了变化。 可以重定向到任意位置的资源（服务器内部、外部均可）。 资源由浏览器来访问，所以可以重定向到任意位置资源。 不能在多个资源使用Request重定向共享数据。 重定向是由浏览器来发送新的请求，每次请求中的Request对象都是不同的。 重定向需要两个步骤： 设置302状态码： response.setStatus(302) 设置响应头中，location的值： response.setHeader(&quot;location&quot;, &quot;/path_b&quot;) Example： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/demo1&quot;) public class ResponseDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;demo1...&quot;); // 重定向 // 1. 设置相应状态码 resp.setStatus(302); // 2. 设置相应头 Location (不区分大小写) resp.setHeader(&quot;Location&quot;, &quot;/request-demo/demo2&quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/demo2&quot;) public class ResponseDemo2 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;demo2...&quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 由于重定向是将重定向后的资源路径告知浏览器，所以location需要添加虚拟目录（如/response-demo/demo2）。 如果是重定向到服务器外部资源，location的值为外部资源的URL。 HttpServletResponse提供了sendRedirect()方法来简化重定向流程。修改ResponseDemo1： package com.linner.web.response; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/resp1&quot;) public class ResponseDemo1 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;resp1...&quot;); // 简化方式完成重定向 // 动态获取虚拟目录 String contextPath = req.getContextPath(); resp.sendRedirect(contextPath + &quot;/resp2&quot;); @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 响应字符数据 将字符数据写回到浏览器，需要： 通过HttpServletResponse对象获取字符输出流： PrintWriter writer = response.getWriter() 通过字符输出流写数据： writer.write(&quot;你好&quot;) Example： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(&quot;/demo&quot;) public class ResponseDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 设置content-type（响应的数据格式）和字符集（编码） resp.setContentType(&quot;text/html;charset=utf-8&quot;); // content-type也可以使用setHeader()手动设置 // resp.setHeader(&quot;content-type&quot;, &quot;text/html&quot;); // 获取字符输出流 PrintWriter writer = resp.getWriter(); writer.write(&quot;你好&quot;); writer.write(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;); // } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } write()不仅能写入文本数据，还能写入HTML数据。 PrintWriter 对象会在 HttpServletRequest 被销毁时一并销毁，无需手动关闭。 响应字节数据 将字节数据写回到浏览器，需要： 通过HttpServletResponse对象获取字节输出流： ServletOutputStream os = response.getOutputStream() 通过字节输出流写数据： os.write(buff) Example： package com.linner.web; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.FileInputStream; import java.io.IOException; import java.io.PrintWriter; @WebServlet(&quot;/demo&quot;) public class ResponseDemo extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 读取文件 FileInputStream fis = new FileInputStream(&quot;src/main/webapp/imgs/bg.jpg&quot;); // 2. 获取response字节输出流 ServletOutputStream os = resp.getOutputStream(); // 3. 完成流的copy byte[] buff = new byte[1024]; int len = 0; while ((len = fis.read(buff)) != -1) { os.write(buff, 0, len); } fis.close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req, resp); } } 其中，流的copy可以使用IOUtils工具类的copy()来简化操作： 导入配置： &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; 修改ResponseDemo： @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 1. 读取文件 FileInputStream fis = new FileInputStream(&quot;src/main/webapp/imgs/reg_bg_min.jpg&quot;);0 // 2. 获取response字节输出流 ServletOutputStream os = resp.getOutputStream(); // 3. 完成流的copy IOUtils.copy(fis, os); fis.close(); } 总结 HttpServletRequest 常用方法 方法名 作用 String getMethod() 获取请求方式 String getContextPath() 获取虚拟目录（项目访问路径） StringBuffer getRequestURL() 获取URL（统一资源定位符） String getRequestURI() 获取URI（统一资源标识符） String getQueryString() 获取请求参数（GET方式） String getHeader(String name) 获取name指定key对应的请求头的value ServletInputStream getInputStream() 获取请求体字节输入流（POST方式获取请求参数） BufferedReader getReader() 获取请求体字符输入流getReader()获取请求参数后，还需要使用readLine()读取参数数据即，BufferedReader br = request.getReader();String line = br.readLine(); Map&lt;String, String[]&gt; getParameterMap() 获取所有请求参数Map集合 String[] getParameterValues(String name) 根据名称获取请求参数值返回值为数组返回多个参数 String getParameter(String name) 根据名称获取请求参数值返回单个参数值 void setAttribute(String name, Object object) 在 Request 域属性空间中放入数据 Object getAttribute(String name) 从 Request 的域属性空间中获取指定名称的数据 void removeAttribute(String name) 从 Request 的域属性空间中删除指定名称的数据 RequestDispatcher getRequestDispatcher(String path) 创建请求转发器请求转发器中有一个方法，用于完成将请求对象转发给下一个资源：void forward(HttpServletRequest request, HttpServletResponse response) void setCharacterEncoding(String charset) 设置请求体字符输入流的编码 HttpServletResponse 常用方法 方法名 作用 void setStatus(int sc) 设置响应状态码 void setHeader(String name, String value) 设置响应头键值对 PrintWriter getWriter() 获取响应体字符输出流获取字符输出流后还需要使用write()方法来写入字符数据：PrintWriter writer = response.getWriter();writer.write(&quot;Hello World!&quot;); ServletOutputStream getOutputStream() 获取响应体字节输出流获取字节输出流前需要先使用FileInputStream对象来读取文件然后使用IOUtils工具类的copy()来copy流获取字节输出流后还需要使用write()方法来写入字符数据响应字节数据 void sendRedirect(String path) Respones重定向 ","link":"https://linna-cy.github.io/old-blog/HttpServlet/"},{"title":"Servlet 与 Tomcat","content":" 相关文章链接: Maven Tomcat Servlet 简介 Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet 基本使用 创建Maven Web项目后，导入Servlet依赖坐标和Tomcat插件： &lt;dependencies&gt; &lt;!-- Servlet依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 使用&lt;scope&gt;provided&lt;/scope&gt;的原因： provided指的是在编译和测试过程中有效，最后生成的war包时不会加入。 因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错。 创建Servlet类，实现Servlet接口，并重写接口中所有方法： package com.linner.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; @WebServlet(&quot;/demo&quot;) public class ServletDemo implements Servlet { @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println(&quot;Hello Servlet!&quot;); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } } 使用@WebServlet注解配置该Servlet的访问路径：@WebServlet(&quot;/demo&quot;) 启动Tomcat，根据自己项目和Tomcat的配置访问，如：http://localhost:8080/web-demo/demo 访问成功后可以看到在控制台输出service()方法中的内容。 Servlet 执行流程 运行Tomcat时并没有显式创建Servlet对象，也没有显式调用其中的方法。可控制台依然输出了ServletDemo.service()中的内容。 访问该Tomcat项目时，浏览器发出http://localhost:8080/web-demo/demo请求，从请求中可以解析出三部分内容： 根据localhost:8080可以找到要访问的Tomcat Web服务器 根据web-demo可以找到部署在Tomcat服务器上的web-demo项目 根据demo可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配 找到ServletDemo这个类后，Tomcat Web服务器就会为ServletDemo这个类创建一个对象，然后调用对象中的service()方法。 而Tomcat则是根据@WebServlet注解或web.xml配置文件等信息来创建对应的Servlet对象。 Servlet 生命周期 生命周期是指对象的生命周期指一个对象从被创建到被销毁的整个过程。 Servlet运行在Servlet容器（web服务器）中，其生命周期由容器来管理，分为4个阶段： 加载和实例化：默认情况下，Servlet会在第一次访问时被容器创建 初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作 init()方法仅会被调用一次 请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理 服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放 在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收 可以把Servlet的创建放到服务器启动的时候来创建（修改@WebServlet注解）： @WebServlet(urlPatterns = &quot;/demo1&quot;, loadOnStartup = 1) loadOnstartup的取值有两类情况： 负整数：第一次访问时创建Servlet对象 非负整数：服务器启动时创建Servlet对象，数字越小优先级越高（0的优先级最高） Example： package com.linner.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; @WebServlet(urlPatterns = &quot;/demo&quot;, loadOnStartup = 1) public class ServletDemo implements Servlet { /** * 初始化方法 * - 在Servlet被第一次访问或者服务器启动时被调用一次 */ public void init(ServletConfig config) throws ServletException { System.out.println(&quot;init...&quot;); } /** * 提供服务 * - 每一次Servlet被访问时被调用 * - 可被调用多次 */ public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { System.out.println(&quot;Hello Servlet!&quot;); } /** * 销毁方法 * - 调用时机：内存释放或者服务器关闭的时候被调用一次 */ public void destroy() { System.out.println(&quot;destroy...&quot;); } public ServletConfig getServletConfig() { return null; } public String getServletInfo() { return null; } } 注意：若要在关闭Tomcat时调用destroy()，需要在正常关闭Tomcat的情况下，destroy()才能被执行。 Servlet 方法 剩下两个Servlet方法的作用是： 获取Servlet信息： public String getServletInfo() { return &quot;&quot;; } 获取ServletConfig对象： public String getServletInfo() { return &quot;&quot;; } ServletConfig对象，Tomcat Web服务器在创建Servlet对象的时候会通过init()方法将其作为参数传入： void init(ServletConfig config) throws ServletException 在getServletInfo()中仅需将服务器传过来的ServletConfig进行返回即可： private ServletConfig servletConfig; public void init(ServletConfig config) throws ServletException { // 获取服务器传入的ServletConfig this.servletConfig = config; System.out.println(&quot;init...&quot;); } public ServletConfig getServletConfig() { // 将服务器传入的ServletConfig返回 return servletConfig; } urlPattern 配置 urlPatterns 多路径访问 一个Servlet，可以配置多个访问路径（urlPattern）： @WebServlet(urlPatterns = {&quot;/path1&quot;, &quot;/path2&quot;, ....}) 精确匹配 配置路径： @WebServlet(&quot;/path/servlet&quot;) 访问路径：http://localhost:8080/web-demo/path/servlet 目录匹配 配置路径： @WebServlet(&quot;/path/*&quot;) 访问路径： http://localhost:8080/web-demo/path/abc http://localhost:8080/web-demo/path/def http://localhost:8080/web-demo/path/ http://localhost:8080/web-demo/path/anypath ... 精确匹配优先级要高于目录匹配 扩展名匹配 配置路径： @WebServlet(&quot;*.html&quot;) 访问路径： http://localhost:8080/web-demo/index.html http://localhost:8080/web-demo/login.html http://localhost:8080/web-demo/any_name.html ... 注意： 如果路径配置的不是扩展名，那么在路径的前面就必须要加/否则会报错 如果路径配置的是*.html，那么在*.html的前面不能加/，否则会报错 任意匹配 配置路径： @WebServlet(&quot;/&quot;) 或 @WebServlet(&quot;/*&quot;) 访问路径： 任何以 http://localhost:8080/web-demo/ 开头的路径 /和/*的区别： 当项目中的Servlet配置了@WebServlet(&quot;/&quot;)，会覆盖掉Tomcat中的DefaultServlet，当其他的urlPattern都匹配不上时都会走这个Servlet。 当项目中配置了@WebServlet(&quot;/&quot;)，意味着匹配任意访问路径。 DefaultServlet是用来处理静态资源，如果使用@WebServlet(&quot;/&quot;)将其覆盖掉。当请求静态资源的时候则是使用了自定义的Servlet类，最终会导致静态资源不能被访问。 XML配置Servlet（不推荐） Servlet从3.0版本后才开始支持注解配置，而3.0版本前只支持XML配置文件的配置方法。 编写Servlet类： package com.linner.web; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; public class ServletDemo implements Servlet { // ... } 在web.xml中配置该Servlet： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- Servlet 全类名 --&gt; &lt;servlet&gt; &lt;!-- Servlet的名称，名字任意 --&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;!-- Servlet的类全名 --&gt; &lt;servlet-class&gt;com.linner.web.ServletDemo&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- Servlet 访问路径 --&gt; &lt;servlet-mapping&gt; &lt;!-- Servlet的名称，要和上面的名称一致 --&gt; &lt;servlet-name&gt;demo&lt;/servlet-name&gt; &lt;!-- Servlet的访问路径 --&gt; &lt;url-pattern&gt;/demo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; ServletRequest 和 ServletResponse 在 Servlet.service() 中有这样两个参数，它们的类型是 ServletRequest 和 ServletResponse。这两个参数就是Servlet的 Request 和 Response 对象。 Request是请求对象，作用是将客户端的请求数据从客户端发送到服务端；Response是响应对象，作用是将服务端的响应数据从服务端发送到客户端。 ","link":"https://linna-cy.github.io/old-blog/Servlet/"},{"title":"Tomcat","content":" 相关文章链接: Maven Tomcat基本使用 Tomcat安装 访问Tomcat官网下载。Tomcat是绿色版，直接解压即可。 启动Tomcat 以Windows系统为例，运行Tomcat目录下 bin\\startup.bat 启动脚本即可完成启动。 启动后，通过浏览器访问 http://localhost:8080能看到Apache Tomcat的内容就说明Tomcat已经启动成功。 Windows系统下启动的过程中，如果控制台有中文乱码，需要修改conf/logging.prooperties。 将 java.util.logging.ConsoleHandler.encoding = UTF-8 修改为 java.util.logging.ConsoleHandler.encoding = GBK 关闭Tomcat 关闭Tomcat不应该直接关闭运行窗口来强制关闭。应该运行bin\\shutdown.bat或ctrl+c来正常关闭。 修改端口 Tomcat默认的端口是8080，通过修改 conf/server.xml 来修改端口号： &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;&gt; 部署 Tomcat部署项目： 将项目放置到webapps目录下，即部署完成。 一般JavaWeb项目会被打包称war包，然后将war包放到webapps目录下，Tomcat会自动解压缩。 Maven 创建 Web 项目 使用Maven工具能更加简单快捷的创建Web项目。 Maven Web 项目结构 📁project_name --- 项目主目录 📁src --- 源代码和测试代码文件目录 📁main --- 源代码文件目录 📁java --- 源代码Java文件目录 📁resourcs --- 源代码配置文件目录 ❗📁webapp 或 web --- Web项目核心目录 存放web配置文件和web项目代码 (html, css, javascript等) ❗📁WEB-INF --- Web项目核心目录 📄web.xml --- Web项目配置文件 其它目录或文件，如 index.html、html、css、js等 📁test --- 测试代码文件目录 📁java --- 测试代码Java文件目录 📁resource --- 测试代码配置 📄pom.xml --- 项目核心配置文件 开发完成部署的 Maven Web 项目结构： 📁project_name --- 项目访问路径（虚拟目录） ❗📁WEB-INF --- Web项目核心目录 📁classes --- Java字节码文件 编译后的Java字节码文件和resources的资源文件，会被放到该目录下 包括pom.xml中依赖坐标对应的jar包 📁lib --- 项目所需jar包 📄web.xml --- Web项目配置文件 其它目录或文件，如 index.html、html、css、js等 创建 Maven Web 项目 创建方式有两种：使用骨架和不使用骨架 使用骨架大致步骤如下： 创建Maven项目 选择使用Web项目骨架 输入Maven项目坐标创建项目 确认Maven相关的配置信息后，完成项目创建 删除pom.xml中多余内容 补齐Maven Web项目缺失的目录结构 最终目录结构如下： 📁project_name 📁src 📁main 📁java 📁resourcs 📁webapp 📁WEB-INF 📄web.xml 📄pom.xml 不使用骨架大致步骤如下： 创建Maven项目 选择不使用Web项目骨架 按照正常的方式创建，不勾选Create from archetype 输入Maven项目坐标创建项目 在pom.xml设置打包方式为war &lt;project&gt; &lt;!-- ...... --&gt; &lt;groupId&gt;......&lt;/groupId&gt; &lt;artifactId&gt;.......&lt;/artifactId&gt; &lt;vesion&gt;.......&lt;/vesion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- ...... --&gt; &lt;/project&gt; 补齐Maven Web项目缺失webapp的目录结构 文件--&gt;项目结构--&gt;Facet中按+然后选择Web，选择当前项目 修改webapp目录，并补齐Maven Web项目缺失WEB-INF/web.xml的目录结构，即可完成构建 在IDEA中使用Tomcat 在IDEA中集成使用Tomcat有两种方式，分别是集成本地Tomcat和Tomcat Maven插件。 集成本地Tomcat 右上角 编辑运行/调试配置 对话框--&gt;编辑配置--&gt;+--&gt;Tomcat服务器--&gt;本地 指定本地Tomcat的具体路径 将开发项目部署项目到Tomcat中 xxx.war 和 xxx.war exploded 这两种部署项目模式的区别： war模式是将WEB工程打成war包，把war包发布到Tomcat服务器上 war exploded模式是将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上 war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容 war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署 建议选war模式进行部署，更符合项目部署的实际情况 Tomcat Maven插件 在pom.xml中添加Tomcat插件： &lt;build&gt; &lt;plugins&gt; &lt;!--Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 使用Maven Helper插件快速启动项目，选中项目，右键 --&gt;Run Maven --&gt; tomcat7:run 安装Maven Helper插件：File --&gt; Settings --&gt; Plugins --&gt; Maven Helper ---&gt; Install，重启IDEA ","link":"https://linna-cy.github.io/old-blog/Tomcat/"},{"title":"MyBatis","content":" 在阅读该文章前, 最好先学会使用数据库 (如MySQL)、数据库驱动和Maven. 相关文章链接: SQL语句 MySQL 环境配置 JDBC Druid Maven MyBatis 介绍 MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。 持久层： 是负责将数据到保存到数据库的那一层代码。即，操作数据库的Java代码为持久层。 而Mybatis就是对JDBC代码进行了封装。 持久层是JavaEE三层架构中的一层。 JavaEE三层架构：表现层、业务层、持久层。 框架： 框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。 使用框架的好处：在框架的基础之上构建软件编写更加高效、规范、通用、可扩展。 使用JDBC存在以下问题: 硬编码 手动注册驱动、获取连接、SQL语句等。 操作繁琐 手动设置参数、封装结果集等。 使用Mybatis： 硬编码可以配置到配置文件。 操作繁琐的地方Mybatis都自动完成。 配置 Mybatis 使用Maven导入Mybatis。 在 pom.xml 配置文件中导入坐标： &lt;dependencies&gt; &lt;!--mybatis 依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql 驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写 mybatis-config.xml 文件： 在模块下的 resources 目录下创建Mybatis的配置文件 mybatis-config.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 需要注意配置标签的前后顺序(按照MyBatis官方文档目录中的顺序去定义) --&gt; &lt;!-- 别名或包扫描 --&gt; &lt;typeAliases&gt; &lt;!-- name属性的值是实体类所在包 --&gt; &lt;!-- 包扫描后,别名默认为类名(不区分大小写) --&gt; &lt;!-- 使用别名可以简化映射配置文件中 resultType 属性值的编写 --&gt; &lt;package name=&quot;package.name.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments:配置数据库的连接环境信息, 可以配置多个environment信息, 通过对应的default属性切换不同的environment --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- 可以配置多个&lt;environment&gt; --&gt; &lt;!-- 使用 id 给每段环境起名 --&gt; &lt;!-- 在 &lt;environments&gt; 中使用 default='environment-id' 来指定使用哪儿段配置 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 数据库连接信息 注意url、username和password --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis1?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;test&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 数据库连接信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis2?useSSL=false&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 加载映射文件 --&gt; &lt;!-- ...... --&gt; &lt;!-- 在下节中讲解 --&gt; &lt;/mappers&gt; &lt;/configuration&gt; 更多MyBatis配置请查看官方文档：MyBatis文档——配置 使用 Mybatis 编写 Mapper类 在 java 目录下创建与 pojo 对应的 Mapper接口 ClassNameMapper.java： public interface ClassNameMapper { // 方法 } 编写 SQL 映射文件 在模块的 resources 目录下创建与 pojo 对应的映射配置文件 ClassNameMapper.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- namespace:名称空间 --&gt; &lt;mapper namespace=&quot;package.name.mapper&quot;&gt; &lt;!-- 相应的SQL语句（XML映射） --&gt; &lt;/mapper&gt; 在Mybatis的配置文件 mybatis-config.xml 中加载映射文件： 直接加载映射文件： &lt;mappers&gt; &lt;mapper resource=&quot;com/abc/mapper/ClassNameMapper.xml&quot;/&gt; &lt;/mappers&gt; 使用这种方式加载映射文件，多个映射文件需要定义多个 &lt;mapper&gt;，过于繁琐。 2. Mapper代理方式（推荐）： 如果 Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。 &lt;mappers&gt; &lt;package name=&quot;com.abc.mapper&quot;/&gt; &lt;/mappers&gt; 注意：使用Mapper代理方式加载映射文件，Mapper接口与其对应的配置文件，它们的路径（包名）要相同。 即，在java目录下的 Mapper接口的包名，要和映射配置文件在 resources下的路径要一致。 如 Mapper接口的包名为 com.abc.mapper，那么其映射配置文件的路径则为 com/abc/mapper。 了解 Maven项目结构，请查看：Maven标准化项目结构 实例 在 Mapper 接口中定义方法，方法名就是SQL映射文件中SQL语句的id，并保持参数类型和返回值类型一致。 例如，为 User对象定义 selectAll()和 selectById()方法： 创建 User表: CREATE DATABASE mybatis; USE mybatis; DROP table IF EXISTS tb_user; CREATE table tb_user ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20), password VARCHAR(20), gender CHAR(1), addr VARCHAR(30) ); INSERT INTO tb_user VALUES (NULL, 'zhangsan', '123', '男', '北京'); INSERT INTO tb_user VALUES (NULL, '李四', '234', '女', '天津'); INSERT INTO tb_user VALUES (NULL, '王五', '11', '男', '西安'); pojo包下定义 User实体类: package com.linner.pojo; public class User { private Integer id; private String username; private String password; private String gender; private String addr; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public String getAddr() { return addr; } public void setAddr(String addr) { this.addr = addr; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, username='&quot; + username + '\\'' + &quot;, password='&quot; + password + '\\'' + &quot;, gender='&quot; + gender + '\\'' + &quot;, addr='&quot; + addr + '\\'' + '}'; } } mapper包下定义 UserMapper: package com.linner.pojo; import com.linner.pojo.User; import org.apache.ibatis.annotations.Select; import java.util.List; public interface UserMapper { List&lt;User&gt; selectAll(); User selectById(int id); // 更多操作接口 } 在 resources目录下创建与 UserMapper包名对应的路径，并添加 UserMapper.xml映射配置文件: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.linner.mapper.UserMapper&quot;&gt; &lt;!-- select语句使用&lt;select&gt; id 为对应Mapper类中的方法名 resultType 为对应的实体类, 使用了&lt;typeAliases&gt;包扫描, 省略了包名 --&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; SELECT * FROM tb_user; &lt;/select&gt; &lt;select id=&quot;selectById&quot; resultType=&quot;user&quot;&gt; SELECT * FROM tb_user WHERE id = #{id}; &lt;/select&gt; &lt;!-- 更多XML映射 --&gt; &lt;/mapper&gt; resources目录下，配置 mybatis-config.xml文件: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 别名或包扫描 --&gt; &lt;!-- 使用别名可以简化映射配置文件中 resultType 属性值的编写 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.linner.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 数据库连接信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL=false&amp;useServerPerpStmts=true&amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- Mapper代理方式--&gt; &lt;package name=&quot;com.linner.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 编写测试类: package com.linner.test; import com.linner.mapper.UserMapper; import com.linner.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test; import java.io.IOException; import java.io.InputStream; import java.util.List; public class UserMapperTest { @Test public void testSelectAll() throws IOException { // 1. 加载mybatis的核心配置文件,获取SqlSessionFactory String resource = &quot;./mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2. 获取SqlSession对象,用它来执行SQL SqlSession sqlSession = sqlSessionFactory.openSession(); // 3. 执行sql语句 // 3.1 方式一: // List&lt;User&gt; users = sqlSession.selectList(&quot;com.linner.mapper.UserMapper.selectAll&quot;); // 3.2 方式二: // 3.2.1 获取UserMapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 3.2.2 执行对应Mapper对象的方法 List&lt;User&gt; users = userMapper.selectAll(); // 4. 处理数据(模拟) System.out.println(users); // 5. 释放资源(仅需释放SqlSession对象) sqlSession.close(); } @Test public void testSelectById() throws IOException { // 模拟接收参数 int id = 1; // 1. 获取sqlSessionFactory String resource = &quot;./mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2. 获取SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 3. 获取Mapper接口的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 4. 执行方法 User user = userMapper.selectById(id); // 5. 处理数据(模拟) System.out.println(user); // 6. 释放资源 sqlSession.close(); } } XML 映射器 通过在 XxxMapper.xml 中使用元素来定义各种CRUD操作。 常用的元素如下（按照定义的顺序给出）： &lt;sql&gt; – 可被其它语句引用的可重用语句块。 &lt;insert&gt; – 映射插入语句。 &lt;update&gt; – 映射更新语句。 &lt;delete&gt; – 映射删除语句。 &lt;select&gt; – 映射查询语句。 Select 查询所有数据 xml 配置文件： &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; SELECT * FROM tb_user &lt;/select&gt; Mapper 接口方法： List&lt;User&gt; selectAll(); id：相应 Mapper 接口中的方法名。 resultType：相应 Mapper 接口中的返回值类型（可自动封装为对象，不区分大小写）。 Mapper 接口返回值：返回一个List&lt;User&gt;。这个返回值可以是User、List&lt;User&gt;或ArrayList&lt;User&gt;等，MyBatis会根据返回值自动封装。 根据id字段查询 xml 配置文件： &lt;select id=&quot;selectById&quot; resultType=&quot;user&quot;&gt; SELECT * FROM tb_user WHERE id = #{id}; &lt;/select&gt; Mapper 接口方法： User selectById(int id); &lt;select&gt;中，#{id}为相应 Mapper 接口中的参数 id。#{id}被称为参数占位符，相当于JDBC中的?占位符。 多条件动态查询 xml 配置文件： &lt;select id=&quot;selectByCondition&quot; resultType=&quot;user&quot;&gt; SELECT * FROM tb_user &lt;where&gt; &lt;if test=&quot;username != null and username != '' &quot;&gt; username = #{username} &lt;/if&gt; &lt;if test=&quot;password != null and password != '' &quot;&gt; AND password = #{password} &lt;/if&gt; &lt;if test=&quot;gender != null and gender != '' &quot;&gt; AND gender = #{gender} &lt;/if&gt; &lt;if test=&quot;addr != null and addr != '' &quot;&gt; AND addr = #{addr} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 多条件查询使用了动态SQL&lt;where&gt;和&lt;if&gt;。如果仅需查询某部分字段，仅仅使用SQL语句在实现上有难度。而Mybatis就提供了动态SQL方便了我们的实现。 &lt;if&gt;：能根据User对象的值来决定是否在SQL语句中加入其包含的语句。 &lt;where&gt;：只会在子元素返回任何内容的情况下才插入WHERE子句。 而且，若子句的开头为AND或OR，&lt;where&gt;元素也会将它们去除。 单条件动态查询 xml 配置文件： &lt;select id=&quot;selectByConditionSingle&quot; resultMap=&quot;brandResultMap&quot;&gt; SELECT * FROM tb_brand &lt;where&gt;&lt;!--使用where标签确保不会出错--&gt; &lt;choose&gt;&lt;!--相当于switch--&gt; &lt;when test=&quot;status != null&quot;&gt;&lt;!--相当于case--&gt; status = #{status} &lt;/when&gt; &lt;when test=&quot;companyName != null and companyName != '' &quot;&gt;&lt;!--相当于case--&gt; company_name like #{companyName} &lt;/when&gt; &lt;when test=&quot;brandName != null and brandName != '' &quot;&gt;&lt;!--相当于case--&gt; brand_name like #{brandName} &lt;/when&gt; &lt;!--没有条件输入很可能会报错,使用&lt;otherwise&gt;保底--&gt; &lt;!--如果没有使用&lt;where&gt;，则必须使用&lt;otherwise&gt;--&gt; &lt;!--&lt;otherwise&gt; 1 = 1 &lt;/otherwise&gt;--&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; 单条件动态查询使用了&lt;where&gt;、&lt;choose&gt;、&lt;when&gt;和&lt;otherwise&gt;，它们都是MyBatis提供的动态SQL元素。 &lt;choose&gt;与&lt;when&gt;（必须）和&lt;otherwise&gt;元素配合使用。它会根据子元素&lt;when&gt;的test属性来判断要选择哪个&lt;when&gt;或&lt;otherwise&gt;元素。 如果&lt;choose&gt;外没有被&lt;where&gt;包裹则必须使用&lt;otherwise&gt;来包裹一个永真的条件SQL语句，以确保SQL语句不会出错。如果被&lt;where&gt;包裹了，&lt;where&gt;会根据需要判断是否要添加WHERE子句。 &lt;choose&gt;、&lt;when&gt;和&lt;otherwise&gt;与switch语句的作用十分相似。 Insert xml 配置文件： &lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO tb_user (username, password, ordered, gender, addr) VALUES (#{username}, #{password}, #{ordered}, #{gender}, #{addr}); &lt;/insert&gt; Mapper 接口方法： boolean add(User user); 接口方法直接传入对象即可，对象成员要与 VALUES 子句中的参数一一对应（参数符号中的名称要与对象的成员名称相同）。 如果XML映射中只有一个参数，那么这个参数的名称不必与接口的参数名称相同。 id：含义与 &lt;insert&gt; 的含义相同，为相应 Mapper 接口中的方法名（以下 id均为此含义，省略）。 useGeneratedKeys： 值为 true 时，Mybatis 会使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（如自增的主键）。 默认为 false。 keyProperty：getGeneratedKeys 获取到的主键值所要赋予的对象成员名。MyBatis 会使用 getGeneratedKeys 的返回值来设置它的值。 如，keyProperty=&quot;id&quot;——直接将获取到的主键值赋值给 user.id。 如果生成列不止一个，可以用逗号分隔多个属性名称。 Mapper 接口返回值：boolean，插入成功返回 true，插入失败返回 false。 返回值也可以选择忽略，将add()接口的返回值设置为void即可。 Update xml 配置文件： &lt;update id=&quot;update&quot;&gt; UPDATE tb_user &lt;set&gt; &lt;if test=&quot;username != null and username != '' &quot;&gt; username = #{username}, &lt;/if&gt; &lt;if test=&quot;password != null and password != '' &quot;&gt; password = #{password}, &lt;/if&gt; &lt;if test=&quot;ordered != null&quot;&gt; ordered = #{ordered}, &lt;/if&gt; &lt;if test=&quot;gender != null and (gender == '男' or gender == '女')&quot;&gt; gender = #{gender}, &lt;/if&gt; &lt;if test=&quot;addr != null and addr != ''&quot;&gt; addr = #{addr} &lt;/if&gt; &lt;/set&gt; WHERE id = #{id}; &lt;/update&gt; Mapper 接口方法： int update(User user); 在 &lt;update&gt; 中有一些用 &lt;set&gt; 包裹起来的 &lt;if&gt;。这是因为需要使用 &lt;set&gt; 动态包含需要更新的列，忽略其它不更新的列。从而能根据User对象的值来决定要更新哪些数据，并且动态地改变SQL语句。 Update的Mapper接口返回值是int类型，返回更新的行数。同样可以将接口的返回值设置为void来忽略它。 Delete 删除单行数据 xml 配置文件： &lt;delete id=&quot;deleteById&quot;&gt; DELETE FROM tb_user WHERE id = #{id}; &lt;/delete&gt; Mapper 接口方法： int deleteById(int id); 删除多行数据 xml 配置文件： &lt;delete id=&quot;deleteByIds&quot;&gt; DELETE FROM tb_brand WHERE id IN &lt;!-- &lt;foreach&gt;参数: - item: 代表数组参数中的每个元素 - separator: 分隔符 - open: 插入开始符 - close: 插入结束符 --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #{id} &lt;/foreach&gt; &lt;/delete&gt; Mapper 接口方法： int deleteByIds(@Param(&quot;ids&quot;) int[] ids); Mybatis提供了 &lt;foreach&gt; 标签遍历数组，拼接SQL语句。&lt;foreach&gt; 同样也是动态SQL。 更多XML映射器请查看官方文档：MyBatis文档——XML映射器 结果映射 resultMap 假设SQL表中的字段与实体类的成员变量名无法一一对应，会导致SQL语句的传参出现问题。例如： CREATE table tb_user ( user_id INT PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR(20), user_password VARCHAR(20), user_gender CHAR(1), user_addr VARCHAR(30) ); public class User { private Integer id; private String username; private String password; private String gender; private String addr; // setter 和 getter // ... } 那么可以使用&lt;resultMap&gt;元素来对表字段和成员名做一个映射（结果映射）： &lt;!-- &lt;resultMap&gt;: - id: 唯一标识 - type: 映射的类型,支持别名 --&gt; &lt;resultMap id=&quot;userResultMap&quot; type=&quot;user&quot;&gt; &lt;!-- 两种标签: - &lt;id&gt;: 完成主键字段的映射 - column: 表的列名 - property: 实体类的属性名 - &lt;result&gt;: 完成一般字段的映射 - column: 表的列名 - property: 实体类的属性名 --&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot;&gt; &lt;result column=&quot;user_name&quot; property=&quot;userame&quot;/&gt; &lt;result column=&quot;user_password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;user_gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;user_addr&quot; property=&quot;addr&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT * FROM tb_user &lt;/select&gt; 要使用结果映射，需要把&lt;select&gt;中的resultType属性替换为resultMap，并且其属性值为&lt;resultMap&gt;的id值。 自动映射 当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。 接上节例子，使用SQL语句的 AS 来实现： &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; SELECT user_id AS &quot;id&quot;, user_name AS &quot;username&quot;, user_password AS &quot;password&quot;, user_gender AS gender, user_addr AS &quot;addr&quot; FROM tb_user &lt;/select&gt; 通常数据库列使用大写字母组成的单词命名，单词间用下划线分隔；而 Java 属性一般遵循驼峰命名法约定。为了在这两种命名方式之间启用自动映射，需要将 mapUnderscoreToCamelCase 设置为 true。&lt;!-- 配置mybatis自动转换为驼峰式命名 --&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;resultMap&gt;和自动映射可以混用。 参数 MyBatis有两种参数： #{p} —— 会自动转义。 ${p} —— 不会自动转义。 官方文档：MyBatis——XML映射器参数 MyBatis 参数封装: 单个参数: POJO类型: 直接使用,保证 属性名 和 参数占位符名称 一致 Map类型: 直接使用,保证 键名 和 参数占位符名称 一致 Collection: 封装为Map集合 相当于： map.put(&quot;arg0&quot;, collection集合) map.put(&quot;collection&quot;, collection集合) 使用@Param注解,替换Map集合中默认的arg键名 List: 封装为Map集合 相当于： map.put(&quot;arg0&quot;, list集合) map.put(&quot;collection&quot;, list集合) map.put(&quot;list&quot;, list集合) 使用@Param注解,替换Map集合中默认的arg键名 Array: 封装为Map集合 相当于： map.put(&quot;arg0&quot;, 数组) map.put(&quot;array&quot;, 数组) 使用@Param注解,替换Map集合中默认的arg键名 其他类型: 直接使用,且占位符名称和参数名称可以不相同 多个参数: 封装为Map集合 每个参数有两个键: 相当于： map.put(&quot;arg0&quot;, 参数值1) map.put(&quot;param1&quot;, 参数值1) map.put(&quot;arg1&quot;, 参数值2) map.put(&quot;param2&quot;, 参数值2) 使用@Param注解,替换Map集合中默认的arg键名: 相当于： @Param(&quot;username&quot;) 参数类型 参数名 map.put(&quot;username&quot;, 参数值1) map.put(&quot;param1&quot;, 参数值1) 示例： public interface UserMapper { User selectById(int id); List&lt;User&gt; selectByCondition( @Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); } 注解实现CRUD 对于简单的SQL语句来说，使用注解开发会比配置文件开发更加方便。 @Select(value = &quot;SELECT * FROM tb_user WHERE id = #{id}&quot;) User selectById(int id); 注意：注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 statement。 Mybatis 针对 CURD 操作都提供了对应的注解： 查询 ：@Select 添加 ：@Insert 修改 ：@Update 删除 ：@Delete 注解适合用于完成简单功能，而使用配置文件来完成复杂功能。如果使用注解来完成动态SQL之类的复杂功能，就需要使用到MyBatis提供的SQL构建器来完成。详情请阅读官方SQL构建器文档：MyBatis文档——SQL语句构建器。 动态SQL 动态 SQL 是 MyBatis 的强大特性之一。 MyBatis提供的动态SQL元素有： &lt;if&gt; &lt;choose&gt; (&lt;when&gt;, &lt;otherwise&gt;) &lt;trim&gt; (&lt;where&gt;, &lt;set&gt;) &lt;foreach&gt; 更多与动态SQL请查看官方文档：MyBatis文档——动态SQL SqlSessionFactory工具类抽取 MyBatis重复代码会造成一些问题: 不利于后期的维护。 SqlSessionFactory工厂类进行重复创建。 对于Mybatis的基础操作出现的重复代码，可以使用一个静态代码块来自动加载： public class SqlSessionFactoryUtils { private static SqlSessionFactory sqlSessionFactory; static { // 静态代码块会随着类的加载而自动执行，且只执行一次 try { String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } public static SqlSessionFactory getSqlSessionFactory(){ return sqlSessionFactory; } } 工具类抽取以后，以后在对Mybatis的SqlSession进行操作的时候，就可以直接使用： SqlSessionFactory sf = SqlSessionFactoryUtils.getSqlSessionFactory(); ","link":"https://linna-cy.github.io/old-blog/MyBatis/"},{"title":"Druid 数据库连接池","content":" 在阅读该文章前, 最好先学会使用数据库 (如MySQL) 和JDBC. 相关文章链接: SQL语句 MySQL 环境配置 JDBC 数据库连接池 数据库连接池是个容器, 负责分配, 管理数据库连接 (Connection). 数据库连接池允许应用程序重复使用一个现有的数据库连接, 而不是再重新建立一个. 从而减少资源浪费. 数据库连接池会自动释放超过最大空闲时间的数据库连接 (强制释放), 来避免因为没有释放数据库连接而引起的数据库连接遗漏. 使用数据库连接池的好处: 资源可以重用 提升系统响应速度 避免数据库连接遗漏 在通常情况下使用JDBC, 有可能会反复地创建和销毁 Connection对象. 这样重复创建销毁的过程特别耗费计算机的性能和时间. 而数据库使用了数据库连接池后，就能达到Connection对象的复用. 连接池是在一开始就创建好了一些连接 (Connection) 对象存储起来. 用户需要连接数据库时, 不需要自己创建连接, 而只需要从连接池中获取一个连接进行使用, 使用完毕后再将连接对象归还给连接池; 这样就可以起到资源重用, 也节省了频繁创建连接销毁连接所花费的时间, 从而提升了系统响应的速度. 常见的数据库连接池有: DBCP C3P0 Druid Druid 配置 Druid 下载Druid jar包, 并导入: 在项目中, 将下载好的jar包放入项目的 lib目录中. 然后点击鼠标右键--&gt;Add as Library (添加为库). 在添加为库文件的时候，有如下三个选项: Global Library: 全局有效 Project Library: 项目有效 Module Library: 模块有效 选择Module Library. 在项目目录下定义Druid配置文件 druid.properties: driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true username=root password=1234 # 初始化连接数量 initialSize=5 # 最大连接数 maxActive=10 # 最大等待时间 maxWait=3000 加载配置文件: Properties prop = new Properties(); prop.load(new FileInputStream(&quot;demo/src/druid.properties&quot;)); 使用 Druid Java中从数据库连接池获取连接对象, 使用的是官方提供的数据库连接池标准接口, 由第三方组织实现此接口. 该接口提供了获取连接的功能: Connection getConnection() throws SQLException 因此, 使用Druid获取数据库连接还需要以下两步: 获取数据库连接池对象: DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); 从数据库连接池中获取连接 (Connection): Connection connection = dataSource.getConnection(); 操作实例 需求分析 完成商品品牌数据的增删改查操作 查询：查询所有数据 添加：添加品牌 修改：根据id修改 删除：根据id删除 环境准备 创建数据库表: -- 删除tb_brand表 DROP TABLE IF EXISTS tb_brand; -- 创建tb_brand表 CREATE TABLE tb_brand ( id INT PRIMARY KEY AUTO_INCREMENT, -- id 主键 brand_name VARCHAR(20), -- 品牌名称 company_name VARCHAR(20), -- 企业名称 ordered INT, -- 排序字段 description VARCHAR(100), -- 描述信息 status INT -- 状态：0：禁用 1：启用 ); -- 添加数据 INSERT INTO tb_brand (brand_name, company_name, ordered, description, status) VALUES ('三只松鼠', '三只松鼠股份有限公司', 5, '好吃不上火', 0), ('华为', '华为技术有限公司', 100, '华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界', 1), ('小米', '小米科技有限公司', 50, 'are you ok', 1); 创建 pojo包, 并在包中添加 Brand实体类: package pojo; /** * 品牌 */ public class Brand { private Integer id; // id 主键 private String brandName; // 品牌名称 private String companyName; // 企业名称 private Integer ordered; // 排序字段 private String description; // 描述信息 private Integer status; // 状态：0：禁用 1：启用 public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getBrandName() { return brandName; } public void setBrandName(String brandName) { this.brandName = brandName; } public String getCompanyName() { return companyName; } public void setCompanyName(String companyName) { this.companyName = companyName; } public Integer getOrdered() { return ordered; } public void setOrdered(Integer ordered) { this.ordered = ordered; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Integer getStatus() { return status; } public void setStatus(Integer status) { this.status = status; } @Override public String toString() { return &quot;Brand{&quot; + &quot;id=&quot; + id + &quot;, brandName='&quot; + brandName + '\\'' + &quot;, companyName='&quot; + companyName + '\\'' + &quot;, ordered=&quot; + ordered + &quot;, description='&quot; + description + '\\'' + &quot;, status=&quot; + status + '}'; } } 实现操作 package dao; import pojo.Brand; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import java.io.FileInputStream; import java.sql.*; import java.util.ArrayList; import java.util.Properties; /** * 品牌数据的增删改查操作 */ public class BrandDAO { private static DataSource dataSource; // 获取Connection: static { try { // - 导入jar包 &amp; 定义配置文件 // - 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(&quot;demo/src/druid.properties&quot;)); // - 获取连接池对象 dataSource = DruidDataSourceFactory.createDataSource(prop); } catch (Exception e) { e.printStackTrace(); } } /** * 查询所有 * 1. SQL: SELECT * FROM tb_brand * 2. 参数: 不需要 * 3. 结果: ArrayList&lt;Brand&gt; */ public ArrayList&lt;Brand&gt; selectAll() throws Exception{ // 1. 获取数据库连接Connection Connection conn = dataSource.getConnection(); // *2. 定义SQL String sql = &quot;SELECT * FROM tb_brand&quot;; // 3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); // *4. 设置参数 // 5. 执行SQL ResultSet rs = pstmt.executeQuery(); // *6. 处理结果: ArrayList&lt;Brand&gt; Brand brand = null; ArrayList&lt;Brand&gt; brands = new ArrayList&lt;&gt;(); // - 遍历结果集 while (rs.next()) { // 1. 获取数据 int id = rs.getInt(&quot;id&quot;); String brandName = rs.getString(&quot;brand_name&quot;); String companyName = rs.getString(&quot;company_name&quot;); int ordered = rs.getInt(&quot;ordered&quot;); String description = rs.getString(&quot;description&quot;); int status = rs.getInt(&quot;status&quot;); // 2. 封装Brand对象 brand = new Brand(); brand.setId(id); brand.setCompanyName(companyName); brand.setOrdered(ordered); brand.setDescription(description); brand.setStatus(status); // 3. 装载ArrayList集合 brands.add(brand); } // 7. 释放资源 rs.close(); pstmt.close(); conn.close(); // 8. 返回结果 return brands; } /** * 添加 * 1. SQL: INSERT INTO tb_brand( brand_name, company_name, ordered, description, status) VALUES(?,?,?,?,?) * 2. 参数: 除了id之外的所有参数信息 * 3. 结果: boolean */ public boolean add(Brand brand) throws Exception{ // 1. 获取数据库连接Connection Connection conn = dataSource.getConnection(); // *2. 定义SQL String sql = &quot;&quot;&quot; INSERT INTO tb_brand( brand_name, company_name, ordered, description, status) VALUES(?,?,?,?,?)&quot;&quot;&quot;; // 3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); // *4. 设置参数 pstmt.setString(1, brand.getBrandName()); pstmt.setString(2, brand.getCompanyName()); pstmt.setInt(3, brand.getOrdered()); pstmt.setString(4, brand.getDescription()); pstmt.setInt(5, brand.getStatus()); // 5. 执行SQL int count = pstmt.executeUpdate(); // 返回影响的行数 // 6. 释放资源 pstmt.close(); conn.close(); // 7. 返回结果 return count &gt; 0; } /** * 修改 * 1. SQL: UPDATE tb_brand SET brand_name=?, company_name=?, ordered=?, description=?, status=? WHERE id=? * 2. 参数: 所有 * 3. 结果: boolean */ public boolean update(Brand brand) throws Exception{ // 1. 获取数据库连接Connection Connection conn = dataSource.getConnection(); // *2. 定义SQL String sql = &quot;&quot;&quot; UPDATE tb_brand SET brand_name=?, company_name=?, ordered=?, description=?, status=? WHERE id=?&quot;&quot;&quot;; // 3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); // *4. 设置参数 pstmt.setString(1, brand.getBrandName()); pstmt.setString(2, brand.getCompanyName()); pstmt.setInt(3, brand.getOrdered()); pstmt.setString(4, brand.getDescription()); pstmt.setInt(5, brand.getStatus()); pstmt.setInt(6, brand.getId()); // 5. 执行SQL int count = pstmt.executeUpdate(); // 返回影响的行数 // 6. 释放资源 pstmt.close(); conn.close(); // 8. 返回结果 return count &gt; 0; } /** * 删除 * 1. SQL:DELETE FROM tb_brand WHERE id=? * 2. 参数: id * 3. 结果: boolean */ public boolean deleteById(int id) throws Exception{ // 1. 获取数据库连接Connection Connection conn = dataSource.getConnection(); // *2. 定义SQL String sql = &quot;DELETE FROM tb_brand WHERE id=?&quot;; // 3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); // *4. 设置参数 pstmt.setInt(1, id); // 5. 执行SQL int count = pstmt.executeUpdate(); // 返回影响的行数 // 6. 释放资源 pstmt.close(); conn.close(); // 7. 返回结果 return count &gt; 0; } } ","link":"https://linna-cy.github.io/old-blog/Druid/"},{"title":"Maven","content":"Maven 简介 Apache Maven是专门用于管理和构建Java项目的工具, 它基于项目对象模型 (POM) 的概念, 通过一小段描述信息来管理项目的构建, 报告和文档. Maven的主要功能有: 提供了一套标准化的项目结构. 提供了一套标准化的构建流程 (编译, 测试, 打包, 发布...). 提供了一套依赖管理机制. Maven 模型 Maven模型包含: 项目对象模型 (Project Object Model) 依赖管理模型 (Dependency) 插件 (Plugin) Maven模型图示: 其中紫色框框起来的部分, 就是用来完成标准化构建流程. 仓库 Maven仓库是项目中依赖的第三方库, 这个库所在的位置叫做仓库 (在Maven的术语中，仓库是一个位置, place). Maven中, 任何一个依赖、插件或者项目构建的输出，都可以称之为构件. Maven仓库能帮助我们管理构件 (主要是JAR), 它就是放置所有JAR文件 (WAR, ZIP, POM等等) 的地方. 仓库有三种类型: 本地 (local) 中央 (central) 远程 (remote) 在项目中使用坐标引入对应依赖jar包后, Maven会按照本地仓库 --&gt; 远程仓库--&gt; 中央仓库的顺序去查找相应的jar包. 只要jar包存在, 如果是在本地仓库则直接使用, 而如果在远程仓库或中央仓库, Maven则将jar包自动下载到本地仓库. 本地仓库 本地仓库在第一次执行maven命令的时候才被创建. 运行 Maven 的时候, Maven 所需要的任何构件都是直接从本地仓库获取的. 如果本地仓库没有, 它会首先尝试从远程仓库下载构件至本地仓库, 然后再使用本地仓库的构件. Maven 本地仓库默认为用户主目录 (USER HOME) 中的 .m2/repository. 中央仓库 Maven 中央仓库是由 Maven 社区提供的仓库, 其中包含了大量常用的库. 中央仓库包含了绝大多数流行的开源Java构件, 以及源码、作者信息、SCM、信息、许可证信息等. 一般来说，简单的Java项目依赖的构件都可以在这里下载到. Maven 社区提供了一个 URL: search.maven.org/#browse, 来浏览中央仓库的内容. 远程仓库 远程仓库是开发人员自己定制的仓库, 包含了所需要的代码库或者其他工程中用到的 jar 文件. 一般是由公司团队搭建的私有仓库. Maven标准化项目结构 Maven提供了一套标准化的项目结构, 所有的IDE使用Maven构建的项目完全一样. 所以, 使用Maven创建的项目在所有IDE中可以通用. 使用Maven构建的项目结构示例: 📁project_name --- 项目主目录 📁src --- 源代码和测试代码文件目录 📁main --- 源代码文件目录 📁java --- 源代码Java文件目录 📁resourcs --- 源代码配置文件目录 📁test --- 测试代码文件目录 📁java --- 测试代码Java文件目录 📁resource --- 测试代码配置 📄pom.xml --- 项目核心配置文件 项目核心配置文件 pom.xml &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- The Basics --&gt; &lt;!-- 公司或者组织的唯一标志 --&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;!-- 当前项目唯一ID --&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;!-- 本项目目前所处的版本号 --&gt; &lt;version&gt;...&lt;/version&gt; &lt;!-- 打包的机制 --&gt; &lt;packaging&gt;...&lt;/packaging&gt; &lt;!-- 项目依赖关系 --&gt; &lt;dependencies&gt;...&lt;/dependencies&gt; &lt;parent&gt;...&lt;/parent&gt; &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt; &lt;modules&gt;...&lt;/modules&gt; &lt;!-- pom常量 --&gt; &lt;properties&gt;...&lt;/properties&gt; &lt;!-- Build Settings --&gt; &lt;build&gt;...&lt;/build&gt; &lt;reporting&gt;...&lt;/reporting&gt; &lt;!-- More Project Information --&gt; &lt;!-- 项目的名称 --&gt; &lt;name&gt;...&lt;/name&gt; &lt;!-- 项目的详细描述 --&gt; &lt;description&gt;...&lt;/description&gt; &lt;!-- 项目主页的URL --&gt; &lt;url&gt;...&lt;/url&gt; &lt;inceptionYear&gt;...&lt;/inceptionYear&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;contributors&gt;...&lt;/contributors&gt; &lt;!-- Environment Settings --&gt; &lt;issueManagement&gt;...&lt;/issueManagement&gt; &lt;ciManagement&gt;...&lt;/ciManagement&gt; &lt;mailingLists&gt;...&lt;/mailingLists&gt; &lt;scm&gt;...&lt;/scm&gt; &lt;prerequisites&gt;...&lt;/prerequisites&gt; &lt;!-- 发现依赖和扩展的远程仓库列表 --&gt; &lt;repositories&gt;...&lt;/repositories&gt; &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; &lt;distributionManagement&gt;...&lt;/distributionManagement&gt; &lt;profiles&gt;...&lt;/profiles&gt; &lt;/project&gt; pom.xml中描述符的根为&lt;project&gt;. Maven坐标 Maven 中的坐标是资源的唯一标识. 使用坐标来定义项目或引入项目中需要的依赖. Maven坐标的主要组成 (在pom.xml文件中): &lt;groupId&gt;: 公司或者组织的唯一标志. 配置时生成的路径也是由此生成. 如com.linner.blog (通常是域名反写), Maven会将该项目打成的jar包放本地路径：/com/linner/blog. &lt;artifactId&gt;: 当前项目的唯一ID (通常是模块名称). 一个groupId下面可能多个项目, 就是靠&lt;artifactId&gt;来区分. &lt;version&gt;: 本项目目前所处的版本号. Maven 中, 根据 groupId、artifactId、version 组合成 groupId:artifactId:version 来唯一识别一个 jar 包. 这三个标签构成了Maven坐标. 其他基本配置 &lt;modelVersion&gt;: 指定pom.xml符合哪个版本的描述符. Maven2和3只能为4.0.0. &lt;packaging&gt;: 打包的机制. 有以下几种: pom jar --- 默认值 maven-plugin ejb war ear rar par &lt;dependencies&gt;: 定义本项目的依赖关系. Maven依赖管理 依赖管理是指管理项目中所依赖的第三方资源 (jar包, 插件). 而Maven使用标准的坐标配置来管理各种依赖, 只需要简单的配置就可以完成依赖管理. Maven的依赖资源是在pom.xml配置文件中的&lt;dependencies&gt;描述的. 其结构如下: &lt;project&gt; ... &lt;dependencies&gt; &lt;dependency&gt;: 一个&lt;dependency&gt;代表一个依赖项. &lt;groupId&gt;, &lt;artifactId&gt;和&lt;version&gt;的含义与&lt;project&gt;的子标签&lt;groupId&gt;, &lt;artifactId&gt;和&lt;version&gt;的含义相同. &lt;groupId&gt; &lt;artifactId&gt; &lt;version&gt; &lt;type&gt;: 依赖的打包机制. 对应&lt;packaging&gt;的类型, 有pom, jar(默认), maven-plugin, ejb, war, ear, rar, par. &lt;scope&gt;: 任务的类路径 (编译和运行时, 测试等) 以及如何限制依赖关系的传递性. scope取值 有效范围(compile, runtime, test) 依赖传递 compile all 是 provided compile, test 否 runtime runtime, test 是 test test 否 system compile, test 是 &lt;optional&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt; &lt;artifactId&gt; &lt;exclusion&gt; ... 多个&lt;exclusion&gt;... 多个&lt;dependency&gt;... ... &lt;scope&gt;取值说明: Maven常用命令 compile: 编译 clean: 清理 test: 测试 package: 打包 install: 安装 使用Maven命令需要先配置PATH, 然后在项目目录下执行. 例如项目路径为~/project: cd ~/project 编译 mvn compile 第一次执行该命令, Maven会自动从仓库 (中央仓库或远程仓库, 介绍常用命令时, 如无特别指出, 仓库均指中央仓库或远程仓库) 下载编译所需的jar插件包. 然后在项目下会生成一个 target 目录. 编译后的字节码文件就放在该目录下. 清理 mvn clean 第一次执行该命令, Maven会从仓库下载清理所需要的jar插件包. 接着便使用插件清除项目下的target目录. 打包 mvn package 第一次执行该命令, Maven会从仓库下载打包所需要的jar插件包. 然后在项目的 terget 目录下生成一个jar包 (将当前项目打成的jar包). 测试 mvn test 该命令会执行所有的测试代码, 即project/scr/text下的代码. 安装 mvn install 该命令会将当前项目打成jar包, 并安装到本地仓库. 执行完上述命令后可以到本地仓库查看结果. 仓库中的路径为pom.xml文件中&lt;groupId&gt;相应的路径, 生成的jar包名为&lt;artifactId&gt;和&lt;version&gt;组成的内容. Maven生命周期 Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件. Maven对项目构建的生命周期划分为3套: clean: 清理工作. default: 核心工作, 例如编译, 测试, 打包, 安装等. site: 产生报告, 发布站点等. 这套声明周期一般不会使用. 同一套生命周期内, 执行后边的命令, 前面的所有命令会自动执行. default 生命周期如下: 如执行install命令, maven会按照上图中从左到右的顺序先执行compile, 再执行test, package, 最后执行install; 如果执行package, 除了install命令, 其它命令按照上图左到右顺序执行. 默认的生命周期其实有对应的很多命令, 上图中只展示了常用的. ","link":"https://linna-cy.github.io/old-blog/Maven/"},{"title":"SSH 公钥配置","content":"创建.ssh目录并生成公钥: ssh-keygen -t rsa 所有选项全部回车, 使用默认选项即可. 然后切换到用户目录下的.ssh目录: cd ~/.ssh 该目录下默认有三个文件: id_rsa: 用户私钥, 不要复制发送给任何人. id_rsa.pub: 公钥, 将里面内容发送给客户端. authorized_keys: 信任的公钥. 只需要将id_rsa.pub里的内容以 (ssh-rsa开头的一行内容) 复制到客户端的authorized_keys的目录下即可. 接着在客户端使用: ssh username@ip -p port 即可连接到服务器. ","link":"https://linna-cy.github.io/old-blog/SSH 公钥配置/"},{"title":"JDBC","content":" 在阅读该文章前, 最好先学会使用数据库 (如MySQL). 相关文章链接: SQL语句 MySQL 环境配 JDBC 简介 JDBC (Java DataBase Connectivity, Java 数据库连接) 是使用Java语言操作关系型数据库的一套 API. JDBC其实是SUN公司制订的一套操作数据库的标准接口. JDBC中定义了所有操作关系型数据库的规则. 由各自的数据库厂商给出实现类 (驱动jar包). Java, JDBC和各种数据库的关系如下图: 使用JDBC的好处: 不需要针对不同数据库分别开发. 可随时替换底层数据库, 访问数据库的Java代码基本不变. JDBC 使用的基本步骤 导入JDBC驱动jar包: 下载MySQL jar驱动包, 菜鸟教程 Java MySQL 连接. 在项目中, 将下载好的jar包放入项目的 lib目录中. 然后点击鼠标右键--&gt;Add as Library (添加为库). 在添加为库文件的时候，有如下三个选项: Global Library: 全局有效 Project Library: 项目有效 Module Library: 模块有效 选择Global Library. 注册驱动: Class.forName(&quot;com.mysql.jdbc.Driver&quot;); MySQL提供的 Driver的静态代码块会自动执行 DriverManager.registerDriver() 方法来注册驱动. 所以我们只需加载 Driver即可. MySQL5之后的驱动包, 可以省略注册驱动的步骤. 获取数据库连接: Connection conn = DriverManager.getConnection(url, username, password); 其中, url, username和 password都是 String类型. url格式: jdbc:数据库软件名称://ip地址或域名:端口/数据库名称?参数键值对1&amp;参数键值对2... 例如, 连接本地mysql中名为test的数据库: jdbc:mysql://127.0.0.1:3306/test 本地mysql, 且端口为3306, url可简写为: jdbc:mysql:///数据库名称?参数键值对 常用的参数键值对有: useSSL=false // 禁用安全连接方式, 解决警告提示 useServerPrepStmts=true // 开启预编译(默认为false) serverTimezone=GMT%2B8 // 设置时区, 东八区(即GMT+8) serverTimezone=Asia/Shanghai // 设置时区东八区 useUnicode=true&amp;characterEncoding=UTF-8 // 设置字符集为UTF-8 获取执行SQL对象: 执行SQL语句需要SQL执行对象 (Statement对象): Statement stmt = conn.createStatement(); Statement对象存在安全问题 (SQL注入等问题), 而使用 PreparedStatement不仅可以提升查询速度, 而且还能防止SQL注入问题. String sql = &quot;...SQL语句...&quot;; PreparedStatement pstmt = conn.prepareStatement(sql); 执行SQL语句: int count = pstmt.executeUpdate(sql); 用于执行DML, DDL语句. 或者: ResultSet rs = pstmt.executeQuery(sql); 用于执行DQL语句. 处理返回结果 释放资源: ResultSet、Statement和 Connection对象都要 &lt;i&gt;按照顺序 &lt;/i&gt;释放资源. rs.close(); stmt.close(); conn.close(); 大致代码如下: import java.sql.*; public class JDBCDemo { public static void main(String[] args) throws Exception { // - 接收用户输入的用户名和密码 String name = &quot;...&quot;; String pwd = &quot;...&quot;; // 1. 注册驱动（装载类，并实例化） Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2. 获取连接 String url = &quot;jdbc:mysql://127.0.0.1:3306/test&quot; + &quot;?useServerPrepStmts=true&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); // 3. 定义SQL语句 (用?作占位符) String sql = &quot;SELECT id,username,password&quot; + &quot; FROM tb_user&quot; + &quot; WHERE username = ?&quot; + &quot; AND password = ?&quot;; // 4. 获取执行SQL的PreparedStatement对象 PreparedStatement pstmt = conn.prepareStatement(sql); // 设置参数（?）的值 pstmt.setXxx(index, value) pstmt.setString(1, name); pstmt.setString(2, pwd); // 5. 执行SQL ResultSet rs = pstmt.executeQuery(); // 6. 处理结果 while (rs.next) { /* ... */ } // 7. 释放资源 rs.close(); pstmt.close(); conn.close(); } } PreparedStatement 对象 PreparedStatement 对象可以: 预编译SQL语句并执行 预防SQL注入问题 获取 PreparedStatement需要先传入SQL语句: // SQL语句中的参数值,使用 ? 占位符替代 String sql = &quot;SELECT id,username,password&quot; + &quot; FROM tb_user&quot; + &quot; WHERE username = ?&quot; + &quot; AND password = ?&quot;; // 通过Connection对象获取PreparedStatement, 并传入对应的SQL语句 PreparedStatement pstmt = conn.prepareStatement(sql); 接着我们需要设置SQL对象中的参数值: 使用 pstmt.setXxx(index, value), 给 ? 赋值. 其中, index的值从 1开始, value的类型为 Xxx或 xxx. 例如, 给 int类型的 value赋值使用 setInt(), String类型使用 setString(). 除此之外还有 setFloat(), setDouble(), setArray(), setByte()等. 如果 prepareStatement()方法传入的是DML, DDL语句, 则使用 executeUpdate() 方法: int executeUpdate() throws SQLException 如果该方法执行的是DML语句 (INSERT, UPDATE和 DELETE), 则返回DML语句操作的行数; 如果是DDL语句则返回 0. 需要注意, 在开发中很少使用java代码操作DDL语句. 如果 prepareStatement()方法传入的是DQL语句 (SELECT), 使用的是 executeQuery() 方法: ResultSet executeQuery() throws SQLException 该方法返回的是DQL语句查询后的结果集. 在使用 PreparedStatement对象后, 需要使用 close()方法释放资源. Statement 和 PreparedStatement Statement 对象的一般用法如下: String sql = &quot;UPDATE tb_user SET password = \\&quot;abc\\&quot; WHERE id = 1&quot;; Statement stmt = conn.createStatement(); int count = stmt.executeUpdate(sql); Statement的SQL语句是作为 executeUpdate()和 executeQuery()的参数传入, 而 PreparedStatement则是在创建对象就已经作为 prepareStatement()方法的参数传入. 这是因为 PreparedStatement需要预先传入SQL语句, 来起到预编译SQL语句和预防SQL注入问题. 预编译 一般情况下, java执行SQL语句的过程如下: java程序请求数据库执行SQL语句后: 检查: 数据库接收指令, 检查SQL语法 编译: 如果SQL语句无语法错误, 则将该语句编译成可执行的函数 执行: 编译完成后执行SQL语句 而检查SQL和编译SQL花费的时间比执行SQL的时间还要长, 如果需要一次性执行多条SQL语句, 那会浪费大量时间和资源. 所以, PreparedStatement的出现解决了这个问题. 通过使用 PreparedStatement对象, 并且在连接数据库的 url中添加 useServerPrepStmts=true参数来开启SQL语句预编译功能. 预编译功能会将我们设置的SQL语句 (如 &quot;SELECT id,username,password FROM tb_user WHERE username = ? AND password = ?&quot;) 预先传给数据库, 让其先完成检查和编译的工作 (先完成耗时的工作), 然后再一次性执行所有SQL语句 (这些SQL语句都是相同的, 只是占位符处设置的值不同). SQL注入 SQL注入是指通过把SQL命令插入到Web表单提交, 或输入域名或页面请求的查询字符串, 最终达到欺骗服务器执行恶意的SQL命令. 而 PreparedStatement通过在SQL语句中使用 ?占位符, 并且使用相应的 setXxx()方法来设置值 (设置的值如果含有特殊字符, 如 &quot; 和 ' 等, 则会进行转义), 防止了SQL注入的发生. 下面代码说明了 PreparedStatement如何防止SQL注入: class Demo { public static void main(String[] args) { // useServerPrepStmts=true开启预编译 String url = &quot;jdbc:mysql:///test?useSSL=false&amp;useServerPrepStmts=true&quot;; String username = &quot;root&quot;; String password = &quot;n546,Lin0&quot;; Connection conn = DriverManager.getConnection(url, username, password); // - 接收用户输入的用户名和密码 String name = &quot;zhangsan&quot;; String pwd = &quot;' OR '1' = '1&quot;; // - 定义SQL（用?作占位符） String sql = &quot;SELECT id,username,password&quot; + &quot; FROM tb_user&quot; + &quot; WHERE username = ?&quot; + &quot; AND password = ?&quot;; // - 获取PreparedStatement对象 // - 预编译SQL，性能更高 // 默认关闭，在url加上参数useServerPrepStmts=true开启 // - 防止SQL注入 PreparedStatement pstmt = conn.prepareStatement(sql); // - 设置参数（?）的值 // - 防注入原理： // 字符串参数在setString中会被转义， // 即整个参数被当成sql里面的字符串，而不是java的字符串 pstmt.setString(1, name); // 从mysql日志文件可以发现： // ' OR '1' = '1 转义成了 \\' OR \\'1\\' = \\'1 pstmt.setString(2, pwd); // - 执行SQL ResultSet rs = pstmt.executeQuery(); // - 判读登录是否成功 if (rs.next()) { System.out.println(&quot;登录成功！&quot;); } else { System.out.println(&quot;登陆失败！&quot;); } rs.close(); pstmt.close(); conn.close(); } } 下面代码演示了把SQL代码片段插入到SQL命令, 来进行免密登录: class LoginInject { public static void main(String[] args) throws Exception { String url = &quot;jdbc:mysql:///test&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); // 接收用户输入的用户名和密码 String name = &quot;abcdefg&quot;; // 用户名随意 String pwd = &quot;' OR '1' = '1&quot;; // 密码传入SQL代码片段 String sql = &quot;SELECT id,username,password&quot; + &quot; FROM tb_user&quot; + &quot; WHERE username = '&quot; + name + &quot;' AND password = '&quot;+ pwd + &quot;'&quot;; // 将sql语句where部分展开： // WHERE username = 'abcdefg' AND password = '' OR '1' = '1' // 发现where语句条件始终为真 System.out.println(sql); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql); // 判读登录是否成功 if (rs.next()) { System.out.println(&quot;登录成功！&quot;); } else { System.out.println(&quot;登陆失败！&quot;); } // 返回的是登录成功 rs.close(); stmt.close(); conn.close(); } } ResultSet 对象 ResultSet (结果集对象) 作用: 封装了SQL查询语句的结果, 是 executeQuery()方法的返回值类型. ResultSet对象有三个方法: next(): boolean next() throws SQLException 每次执行时, 将光标从当前位置向前移动一行 (光标从第0行开始), 并且判断当前行是否为有效行 (返回 true则代表为有效行). getXxx(): xxx getXxx(arg) throws SQLException arg类型: int: 代表列的编号 (按照 SELECT语句中的查询顺序), 从1开始 String: 列的名称 close(): void close() throws SQLException 释放 ResultSet对象. 下面演示了 ResultSet的使用: class Demo { public static void main(String[] args) { // ... String sql = &quot;SELECT id,username,password FROM tb_user&quot;; Statement stmt = conn.createStatement(); PreparedStatement pstmt = conn.prepareStatement(sql); // - 处理结果，遍历rs中的所有数据 // - rs.next()：光标向下移动一行，并判断当前行是否有效 while (rs.next()) { // - 获取数据 getXxx() int id = rs.getInt(1); // getXxx()方法可以使用列索引（从1开始）也可以使用列名 String usrname = rs.getString(&quot;username&quot;); String passwd = rs.getString(3); System.out.println(&quot;id: &quot; + id); System.out.println(&quot;username: &quot; + usrname); System.out.println(&quot;passwd: &quot; + passwd); System.out.println(&quot;-----------------------&quot;); } // - 释放资源 // ResultSet、Statement和Connection都要按照顺序释放资源 // 先释放ResultSet, 再释放Statement, 最后是Connection rs.close(); stmt.close(); conn.close(); } } 操作实例 用户账号密码增删改操作. 在编写JDBC代码之前需要先完成创建数据库, 创建 pojo包并编写 User实体类的工作: 创建数据库并运行下方SQL代码: -- 删除tb_user表 DROP TABLE IF EXISTS tb_user; -- 创建tb_user表 CREATE TABLE tb_user( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20), password VARCHAR(32) ); -- 添加数据 INSERT INTO tb_user VALUES(NULL, 'zhangsan', '123'), (NULL, 'lisi', '234'); 创建 pojo包, 并在包中添加 User实体类: package pojo; // pojo包存放实体类 public class User { private Integer id; private String username; private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return &quot;Account{&quot; + &quot;id=&quot; + id + &quot;, username='&quot; + username + '\\'' + &quot;, password='&quot; + password + '\\'' + '}'; } } 增删改操作 JDBC数据访问层的代码放在 DAO包下: package dao; import pojo.User; import java.sql.*; public class UserDAO { private static String URL = &quot;jdbc:mysql:///test&quot; + &quot;?useSSL=false&amp;useServerPrepStmts=true&quot;; private static String USERNAME = &quot;root&quot;; private static String PASSWORD = &quot;1234&quot;; /** * 根据用户名和密码查询 * @param username * @param password * @return User * @throws SQLException */ public User select(String username, String password) throws SQLException { // 参数有null值时 if (username == null || password == null) { return null; } // 连接数据库 Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); // 获取PreparedStatement对象, 并设置SQL语句 String sql = &quot;SELECT id, username, password&quot; + &quot; FROM tb_user&quot; + &quot; WHERE username = ?&quot; + &quot; AND password = ?&quot;; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); pstmt.setString(2, password); // 获取ResultSet ResultSet rs = pstmt.executeQuery(); User user = null; if (rs.next()) { user = new User(); Integer id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;username&quot;); String pw = rs.getString(&quot;password&quot;); user.setId(id); user.setUsername(name); user.setPassword(pw); } rs.close(); pstmt.close(); conn.close(); return user; } /** * 根据用户名和密码添加数据 * @param username * @param password * @return boolean * @throws SQLException */ public boolean add(String username, String password) throws SQLException { Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = &quot;INSERT INTO tb_user&quot; + &quot; VALUE(null, ?, ?)&quot;; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); pstmt.setString(2, password); int count = pstmt.executeUpdate(); pstmt.close(); conn.close(); return count &gt; 0; } /** * 根据用户名和密码删除数据 * @param username * @param password * @return boolean * @throws SQLException */ public boolean delete(String username, String password) throws SQLException { Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql = &quot;DELETE FROM tb_user&quot; + &quot; WHERE username = ?&quot; + &quot; AND password = ?&quot;; PreparedStatement pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); pstmt.setString(2, password); int count = pstmt.executeUpdate(); pstmt.close(); conn.close(); return count &gt; 0; } } ","link":"https://linna-cy.github.io/old-blog/jdbc/"},{"title":"搭建 code-server","content":" 下载code-server： wget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz 可以访问code-server GitHub 页面获取下载连接。 解压： tar -zxvf code-server-4.5.1-linux-amd64.tar.gz 将解压后的文件移动到/opt目录下，并重命名： mv code-server-4.5.1-linux-amd64 /opt/code-server 创建软链到/usr/bin目录下： ln -s /opt/code-server/code-server /usr/bin/code-server 修改配置文件~/.config/code-server/config.yaml： vim ~/.config/code-server/config.yaml 添加code-server服务： vim /lib/systemd/system/codeweb.service 写入如下内容： [Unit] Description=The nginx HTTP and reverse proxy server After=network.target remote-fs.target nss-lookup.target [Service] Type=simple ExecStart=/usr/bin/code-server KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=process PrivateTmp=true StandardOutput=syslog StandardError=inherit [Install] WantedBy=multi-user.target ","link":"https://linna-cy.github.io/old-blog/搭建code-server/"},{"title":"搭建 frp 服务","content":" 下载frp： wget https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz 或者访问frp项目获取自己需要的版本。 解压： tar -zxvf frp_0.44.0_linux_amd64.tar.gz 进入目录后，配置frps.ini和frpc.ini： cd frp_0.44.0_linux_amd64 服务端： vim frps.ini 将文件按照下面修改： [common] # frp监听的端口，默认是7000，可以改成其他的 bind_port = 7000 # 授权码，请改成更复杂的 token = 123456 # 这个token之后在客户端会用到 # frp管理后台端口，请按自己需求更改 dashboard_port = 7500 # frp管理后台用户名和密码，请改成自己的 dashboard_user = admin dashboard_pwd = admin enable_prometheus = true # frp日志配置 log_file = /var/log/frps.log log_level = info log_max_days = 3 客户端： vim frpc.ini 将文件按照下面修改： # 客户端配置 [common] server_addr = 服务器ip server_port = 7000 # 与frps.ini的bind_port一致 token = 52010 # 与frps.ini的token一致 # 配置ssh服务 [ssh] type = tcp local_ip = 127.0.0.1 # 默认本地ip local_port = 22 remote_port = 6000 # 这个自定义，之后再ssh连接的时候要用 # 配置http服务，可用于小程序开发、远程调试等，如果没有可以不写下面的 [web] type = http local_ip = 127.0.0.1 local_port = 8080 subdomain = test.hijk.pw # web域名 remote_port = 自定义的远程服务器端口，例如8080 接着需要在防火墙开启相应的端口。 启动服务： 服务端： ./frps -s frps.ini 或者配置frps.server文件： sudo vim /lib/systemd/system/frps.service [Unit] Description=The nginx HTTP and reverse proxy server After=network.target remote-fs.target nss-lookup.target [Service] Type=simple # 根据实际情况修改这条命令或者将frps、frps.ini移动到相应位置 ExecStart=/usr/bin/frps -c /etc/frp/frps.ini KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=process PrivateTmp=true StandardOutput=syslog StandardError=inherit [Install] WantedBy=multi-user.target 客户端： ./frpc -c frpc.ini 如果是Linux也可以配置frpc.service： [Unit] Description=Frp Client Service After=network.target [Service] Type=simple #User=nobody Restart=on-failure RestartSec=5s # 根据实际情况修改以下两条命令或者将frps、frps.ini移动到相应位置 ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini ExecReload=/usr/bin/frpc reload -c /etc/frp/frpc.ini [Install] WantedBy=multi-user.target 更多请见Frp官方文档。 ","link":"https://linna-cy.github.io/old-blog/搭建frp服务/"},{"title":"MySQL 环境配置","content":"Ubuntu MySQL 8 安装： 首先更新本地存储库索引： sudo apt update 从 APT 存储库安装 MySQL： sudo apt install MySQL-server -y 查看 MySQL 版本，验证是否安装成功： mysql --version 检查 MySQL 是否正在运行： systemctl status mysql.service 如果服务未运行： sudo systemctl start mysql MySQL 安装完成后需要更改密码。 查看默认账户和密码： 执行后找到 user 和 password，如： sudo vim /etc/mysql/debian.cnf 或： sudo cat /etc/mysql/debian.cnf 找到如下： user = debian-sys-maint password = 12E0cDBeusG6vANp 使用默认账户登录： 然后输入默认密码： mysql -udebian-sys-maint -p 12E0cDBeusG6vANp 输入以下命令修改 root 密码： ALTER USER 'root'@'localhost' identified WITH mysql_native_password BY 'your_password'; 修改完成后执行： FLUSH privileges; QUIT 最后重启 MySQL 后就可以使用 root 用户了： sudo service mysql restart mysql -uroot -p ","link":"https://linna-cy.github.io/old-blog/MySQL 环境配置/"},{"title":"Ubuntu 安装 Oh my zsh","content":"oh-my-zsh主页： https://ohmyz.sh/ 安装并设置zsh 安装zsh： sudo apt install zsh 查看系统中所有的shell： cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/bash /usr/bin/bash /bin/rbash /usr/bin/rbash /bin/dash /usr/bin/dash /usr/bin/tmux /usr/bin/screen /bin/zsh /usr/bin/zsh 将zsh设置为默认的shell： sudo chsh -s /bin/zsh 重新连接到Ubuntu，然后查看当前默认shell： echo $SHELL 如果显示/bin/zsh则配置成功。 安装 oh-my-zsh 下载install.sh： wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh 给install.sh添加权限： chmod +x install.sh 执行install.sh： ./install.sh 📌在执行install.sh之前还需要安装git。否则会报错。 安装git： sudo apt install git 如果安装速度慢，可以换成gitee： vim install.sh # Default settings ZSH=${ZSH:-~/.oh-my-zsh} REPO=${REPO:-ohmyzsh/ohmyzsh} REMOTE=${REMOTE:-https://github.com/${REPO}.git} BRANCH=${BRANCH:-master} 将2，3行改为： REPO=${REPO:-mirrors/oh-my-zsh} REMOTE=${REMOTE:-https://gitee.com/${REPO}.git} 然后:wq保存退出。重新执行install.sh。 配置zsh zsh的配置文件为：~/.zshrc。 vim ~/.zshrc 修改主题 主题配置项为：ZSH_THEME。 默认主题配置为： ZSH_THEME=&quot;robbyrussell&quot; 可以修改为其中之一： ZSH_THEME=&quot;ys&quot; ZSH_THEME=&quot;geoffgarside&quot; 还可以访问https://github.com/ohmyzsh/ohmyzsh/wiki/Themes 查看更多主题。 ","link":"https://linna-cy.github.io/old-blog/Ubuntu安装Oh my zsh/"},{"title":"两数交换算法","content":"临时变量 通过建立一个临时变量来实现两数交换： def swap(x, y): print(x, y) tmp = x x = y y = tmp print(x, y) return x, y if __name__ == '__main__': swap(1, 2) 缺点： 需要消耗额外的内存。 优点： 不限制类型，大多数类型都能使用该操作。 加减交换 通过加减法实现： def swap(x, y): print(x, y) x = x + y y = x - y x = x - y print(x, y) return x, y if __name__ == '__main__': swap(1, 2) 假设两个数保存在x和y中： 先将y中的值加到x中。 即这两个数一同保存在同一内存空间x中。 然后用x的值减去y的值，再将其保存到内存y中。 x-y即为x最初的值。 最后再用x的值减去y的值，赋给内存x。 x最初的值已经在y中，所以x-y的值为y最初的值。 缺点： 该方法只适用于数值不大的数，如果数值过大，可能会越界（对于某些语言来说）。 异或交换 通过异或的操作实现： def swap(x, y): print(x, y) x = x ^ y y = x ^ y x = x ^ y print(x, y) return x, y if __name__ == '__main__': swap(1, 2) 缺点： 只能对整数类型执行位操作，不能对实数类型进行位操作。 ","link":"https://linna-cy.github.io/old-blog/两数交换算法/"},{"title":"Python 基础","content":"Python 语法 注释 Python 的注释风格： # 行注释 ''' 块注释1 ''' &quot;&quot;&quot; 块注释2 &quot;&quot;&quot; 注释中的内容将不会被执行。 标识符 首字母必须是大写或小写的英文字母或者下划线 _。 其他部分由大写或小写的英文字母、数字和下划线组成。 大小写敏感（区分大小写）。 Python3 中允许使用非 ASCII 标识符，即中文也可作为标识符： &gt;&gt;&gt; 变量 = 5 &gt;&gt;&gt; print(变量) 5 关键字 Python 关键字（keyword）不能作为标识符使用，关键字又称保留字。 使用 keyword 模块输出 Python 的所有关键字： &gt;&gt;&gt; import keyword &gt;&gt;&gt; print(keyword.kwlist) ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 变量的赋值 Python 中的变量并不需要声明，直接赋值后就可使用。还可以同时为多个变量赋值。 pai, e = 3.14, 2.72 a = b = c = 1 代码规范 Python 代码中的所有块都是使用空格缩进来表示。同一块中的所有语句都必须包含相同的缩进空格数，一般使用 4 个空格作为缩进，并且最好在代码编辑器中设置将 Tab 转化为空格。 total = 0 # 输出数字 1~9 的平方数 for n in range(1, 10): # 块的开始 square = n * n total += square print(square) # 块的结束 # 输出数字 1~9 的所有平方数的总和 print(total) 缩进相同的一组语句构成一个代码块，或称之为代码组。 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行是程序代码的一部分，但并不是 Python 语法的一部分。空行的作用在于分割两段不同功能或含义的代码，便于日后代码的维护或重构，有无空行并不影响程序运行。 反斜杠 \\ 作为续行符，表示下一行是上一行的延续。对于过长的语句，Python 使用反斜杠、换行再加上缩进来将长语句分为多行。 total = item_one + \\ item_two + \\ item_three 在 [],{}, 或 () 中的多行语句，不需要使用反斜杠 \\ 来换行。 total = ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割。 &gt;&gt;&gt; str = '123'; print(str) 123 标准数据类型 Python 支持 6 种基本数据类型： Number —— 数字类型 String —— 字符串类型 List —— 列表 Tuple —— 元组 Set —— 集合 Dictionary —— 字典 List、Dictionary、Set 是 Python 内置的数据结构。 Python 变量分为可变和不可变数据类型，以下是它们的定义： 不可变（immutable）数据类型：当该数据类型对应的变量的值发生了改变，它对应的内存地址也会发生改变（重新分配内存空间），如 Number、String、Tuple。即，数据中的元素不能被更改。 # 测试 Number 类型是否是不可变数据类型 n = 1 # 赋值 print(id(n), type(n)) n = 2 # 改变值 print(id(n), type(n)) # 可能输出： # 1562536992 &lt;class 'int'&gt; # 1562537024 &lt;class 'int'&gt; 可变（mutable）数据类型：当该数据类型对应的变量的值发生了改变，它对应的内存地址不发生改变，如 List、Dictionary、Set。即，数据中的元素可以被更改。 可迭代对象：List、Tuple、Set 、 Dictionary 和 String。 Number类型 Python 支持的数字类型： int —— 整数类型。 float —— 浮点数类型（实数类型），如 3.14、3E-2。 bool —— 布尔类型（True 和 False）。 complex —— 复数类型，如 1.1 + 2.2j、complex(a, b)。 Python 2 中有 long 型，Python 3 中没有。 数字函数 数字函数需要导入 math 模块：import math 函数 描述 abs(x) 返回数字 x（可以是复数）的绝对值（内置函数，不用导入 math 模块）。 ceil(x) 返回数字 x 的上入整数（向上取整）。 cmp(x, y) 如果 x &lt; y 返回 -1，如果 x == y 返回 0，如果 x &gt; y 返回 1。 Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换。 exp(x) 返回 e 的 x 次幂 exe^xex。 fabs(x) 返回数字 x（不能是复数）的绝对值。 floor(x) 返回数字的下舍整数（向下取整）。 log(x[, y]) log(x) —— 返回 x 的自然对数； log(x, y) —— 返回以 y 为基数的 x 的对数：log⁡yx\\log_y{x}logy​x。 log10(x) 返回以 10为基数的 x 的对数。 max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回 x 的整数部分与小数部分，两部分的数值符号与 x 相同，整数部分以浮点型表示。 pow(x, y[, z]) pow(x, y) —— x**y 运算后的值； pow(x, y, z) —— 相当于 pow(x, y) % z。 通过内置方法调用，会把参数作为整型，而 math 会把参数转换为 float。 round(x [, n]) 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。 其实准确的说是保留值将保留到离上一位更近的一端。 sqrt(x) 返回数字 x 的平方根。 String类型 Python 的字符串（String）有以下特点： 字符串常量可以使用单引号 ' 和双引号 &quot; 指定。 &gt;&gt;&gt; str1 = 'Hello' &gt;&gt;&gt; str2 = 'World' &gt;&gt;&gt; print(str1, str2, '!') Hello World ! &gt;&gt;&gt; str1 = '打印 &quot;双引号&quot; ' &gt;&gt;&gt; str1 += &quot;要用 '单引号' 将其括起来&quot; &gt;&gt;&gt; print(str1) 打印 &quot;双引号&quot; 要用 '单引号' 将其括起来 使用三个引号可指定一个多行字符串常量。 &gt;&gt;&gt; str1 = &quot;&quot;&quot;这是一个段落， ... 可以由多行组成&quot;&quot;&quot; &gt;&gt;&gt; print(str1) 这是一个段落， 可以由多行组成 转义符用 \\ 开头。单个反斜杠依然可以作为续行符。 &gt;&gt;&gt; str = 'str\\ ... ing' &gt;&gt;&gt; print(str) string 使用 r 或 R 可以让反斜杠不发生转义。这样的字符串被称为原始字符串。 &gt;&gt;&gt; print(r&quot;this is a line with \\n&quot;) this is a line with \\n 按字面意义级联字符串。 &gt;&gt;&gt; print('this ' 'is ' 'string') this is string 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 &gt;&gt;&gt; print('this ' + 'is ' + 'string') this is string &gt;&gt;&gt; str = 'Hello World!' * 3 &gt;&gt;&gt; print(str) Hello World!Hello World!Hello World! 有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。 字符串的截取的语法格式：变量[头下标:尾下标:步长]。字符串被截取后返回一个包含所需字符的新字符串。遵循左闭右开原则。 尾下标从 1 开始。 步长是指输出字符串中第 nnn 个字符后，接着输出第 (n+步长)(n + 步长)(n+步长) 个字符，直至到达尾下标指定处。 省略步长代表按字符串顺序输出，省略尾下标代表截取到字符串的最后一个字符，省略头下标代表从第一个字符开始截取。 &gt;&gt;&gt; str='123456789' &gt;&gt;&gt; print(str[0]) # 输出字符串第一个字符 1 &gt;&gt;&gt; print(str[2:5]) # 输出从第三个开始到第五个的字符 345 &gt;&gt;&gt; print(str[0:-1]) # 输出第一个到倒数第二个的所有字符 12345678 &gt;&gt;&gt; print(str[2:]) # 输出从第三个开始后的所有字符 3456789 &gt;&gt;&gt; print(str[:3]) # 输出从第一个开始到第三个的字符 123 &gt;&gt;&gt; print(str[1:5:2]) # 输出从第二个开始到第五个且每隔一个的字符（步长为2） 24 &gt;&gt;&gt; print(str[:]) # 同时省略头下标和尾，创建了一个str的副本 字符串不能改变。即，字符串的切片不能被赋值。 &gt;&gt;&gt; str = 'string' &gt;&gt;&gt; str[0] = 'S' Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: 'str' object does not support item assignment &gt;&gt;&gt; str = 'string' &gt;&gt;&gt; print(str) string &gt;&gt;&gt; str = 'String' # 修改字符串只能重新进行赋值 &gt;&gt;&gt; print(str) String Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 在Python2中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 unicode 字符串。使用的语法是在字符串前面加上前缀 u。 在Python3中，所有的字符串都是 Unicode 字符串。 转义符 转义字符 描述 \\（在代码行尾时） 续行符。 \\\\ 反斜杠符号。 \\' 单引号。 \\&quot; 双引号。 \\a 响铃 print(&quot;\\a&quot;)执行后电脑有响声。 \\b 退格（Backspace）。 \\000 空。 \\n 换行。 \\v 纵向制表符。 \\t 横向制表符。 \\r 回车，将 \\r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \\r 后面的内容完全替换完成。 \\f 换页。 \\yyy 八进制数，y 代表 0~7 的字符，如 \\012 代表换行。 \\xyy 十六进制数，以 \\x 开头，y 代表的字符，例 \\x0a 代表换行。 \\other 其它的字符以普通格式输出。 格式化字符串 print() 函数能够使用 % 来进行格式化字符串的输出。例如： &gt;&gt;&gt; print('%e' % 3.14) 3.140000e+00 字符串格式化符号： 符 号 描述 %c 格式化字符及其 ASCII 码。 %s 格式化字符串。 %d 格式化整数。 %u 格式化无符号整型。 %o 格式化无符号八进制数。 %x 格式化无符号十六进制数。 %X 格式化无符号十六进制数（大写）。 %f 格式化浮点数字，可指定小数点后的精度。 %e 或 %E 用科学计数法格式化浮点数。 %e 中显示的字母为小写，%E 则为大写。 %g %f和%e的简写。 %G %f 和 %E 的简写。 %p 用十六进制数格式化变量的地址。 格式化操作符辅助符号： 符号 功能 * 定义宽度或者小数点精度。 - 用做左对齐。 + 在正数前面显示加号。 &lt;sp&gt; 在正数前面显示空格。 # 在八进制数前面显示零 '0'，在十六进制前面显示 '0x' 或者 '0X'（取决于用的是 'x' 还是 'X'）。 0 显示的数字前面填充 '0' 而不是默认的空格。 % '%%' 输出一个单一的 '%'。 (var) 映射变量(字典参数)。 m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)。 辅助符号在格式字符串 % 和符号中间使用，如需指定其它参数需要在字符串后的 % 使用括号 () 指定参数和要显示的值。如： &gt;&gt;&gt; print('%*d' % (10, 2)) 2 f-string f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。f-string格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去。 &gt;&gt;&gt; name = 'World!' &gt;&gt;&gt; f'Hello {name}' # 替换变量 'Hello World!' &gt;&gt;&gt; f'{1+2}' # 使用表达式 '3' str.format() str.format() 是用于格式化字符串的字符串方法。旧式的格式化最终会从该语言中移除，应该更多的使用 str.format()。 format() 将 str 中的格式化字段（{} 及其里面包含的字符）替换为 format() 中的参数。它的用法如下： &gt;&gt;&gt; print('{} and {}'.format('a', 'b')) # 按照参数顺序 a and b &gt;&gt;&gt; print('{1} and {0}'.format('a', 'b')) # 指定参数位置（从 0 开始） b and a &gt;&gt;&gt; print('{} and {b}'.format('a', b = 'b')) # 指定关键字 a and b !a（使用 ascii())，!s（使用 str()）和 !r（使用 repr()）可以用于在格式化某个值之前对其进行转化： &gt;&gt;&gt; import math &gt;&gt;&gt; print('常量 PI 的值近似为： {}。'.format(math.pi)) 常量 PI 的值近似为： 3.141592653589793。 &gt;&gt;&gt; print('常量 PI 的值近似为： {!r}。'.format(math.pi)) 常量 PI 的值近似为： 3.141592653589793。 可以使用 :，在右边指定输出形式，在 : 左边的是 format() 参数位置： &gt;&gt;&gt; import math &gt;&gt;&gt; print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi)) 常量 PI 的值近似为 3.142。 在 : 后传入一个整数, 可以保证该域至少有这么多的宽度。 &gt;&gt;&gt; table = {'a': 1, 'b': 2, 'c': 3} &gt;&gt;&gt; for name, number in table.items(): ... print('{0:10} ==&gt; {1:10d}'.format(name, number)) ... a ==&gt; 1 b ==&gt; 2 c ==&gt; 3 传入一个字典，然后使用方括号 [] 来访问键值： &gt;&gt;&gt; table = {'a': 1, 'b': 2, 'c': 3} &gt;&gt;&gt; print('b: {0[b]:d}; a: {0[a]:d}; c: {0[c]:d}'.format(table)) b: 2; a: 1; c: 3 也可以通过在变量前使用 ** 来实现相同的功能： &gt;&gt;&gt; table = {'a': 1, 'b': 2, 'c': 3} &gt;&gt;&gt; print('b: {b:d}; a: {a:d}; c: {c:d}'.format(**table)) b: 2; a: 1; c: 3 字符串方法 方法 说明 str.capitalize() 将字符串的第一个字符转换为大写。 str.center(width[, fillchar]) 返回一个指定的宽度 width 居中的字符串。 fillchar 为填充的字符，默认为空格。 str.count(sub[, start= 0, end=len(string)]) 返回 sub 在 str 的指定范围里面出现的次数。 sub —— 搜索的子字符串。 start —— 字符串开始搜索的位置。默认为第一个字符（索引为 0）。 end —— 字符串中结束搜索的位置。默认为字符串的最后一个位置。 str.encode(encoding='UTF-8',errors='strict') 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是 'ignore' 或者 'replace'。 bytes.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;) 以指定的编码格式解码 bytes 对象。 encoding —— 要使用的编码，默认为 &quot;utf-8&quot;。 errors —— 设置不同错误的处理方案。默认为 &quot;strict&quot;，意为编码错误引起一个 UnicodeError。 其他可能的值有 &quot;ignore&quot;，&quot;replace&quot;，&quot;xmlcharrefreplace&quot;，&quot;backslashreplace&quot; 以及通过 codecs.register_error() 注册的任何值。 Python3 中没有 decode() 方法，但可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回↩。 str.endswith(suffix[, start=0, end=len(string)]) 检查字符串指定范围是否以 suffix 结束，如果是，返回 True，否则返回 False。 suffix —— 可以是一个字符串或者是一个元素。 start —— 指定的开始位置。默认为字符串第一个字符（索引为 0）。 end —— 指定的结束位置。默认为字符串的最后一个字符。 str.expandtabs(tabsize=8) 把字符串 str 中的 Tab 符号 \\t 转为空格。 tabsize —— Tab 符号的长度，默认为 8。 str.find(sub[, beg=0, end=len(str)]) 检测 sub 是否包含在字符串 str 的指定范围中，如果包含则返回开始的索引值，否则返回 -1。 sub —— 字符串。 beg —— 指定的开始位置。默认为字符串第一个字符（索引为 0）。 end —— 指定的结束位置。默认为字符串的最后一个字符。 str.index(sub[, beg=0, end=len(string)]) 同 find()方法一样，只不过如果 sub 不在字符串中会报一个异常。 str.isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False。 str.isalpha() 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False。 str.isdigit() 如果字符串只包含数字则返回 True，否则返回 False。 str.islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False。 str.isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False。 str.isspace() 如果字符串中只包含空白，则返回 True，否则返回 False。 str.istitle() 如果字符串是标题化的（见 title()），则返回 True，否则返回 False。 str.isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False。 str.join(sequence) 字符串 str 作为分隔符，将 sequence 中所有的元素（的字符串表示）合并为一个新的字符串。 len(string) 返回字符串长度。 str.ljust(width[, fillchar]) 返回一个原字符串左对齐，并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。如果指定的长度小于原字符串的长度则返回原字符串。 str.lower() 转换字符串中所有大写字符为小写。 str.lstrip([chars]) 截掉字符串左边的空格或指定字符。 chars —— 指定截取的字符。 str.maketrans(intab, outtab) 创建字符映射的转换表。↩intab —— 字符串，表示需要转换的字符。 outtab —— 字符串表示转换的目标。 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 str.replace(old, new[, max]) 将字符串中的 old 替换成 new，如果 max 指定，则替换不超过 max 次。 str.rfind(sub[, beg=0,end=len(string)]) 类似于 find() 函数，不过是从右边开始查找。即，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。 str.rindex(sub[, beg=0, end=len(string)]) 类似于 index()，不过是从右边开始。即，返回子字符串 sub 在字符串中最后出现的位置，如果没有匹配的字符串会报异常。 str.rjust(width[, fillchar]) 返回一个原字符串右对齐，并使用 fillchar（默认空格）填充至长度 width 的新字符串。 str.rstrip([chars]) 删除字符串末尾的指定字符 chars，默认为空格。 str.split([str1=&quot;&quot;, num=string.count(str1)]) 以参数 str1 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串↩。 str.splitlines([keepends]) 按照行（'\\r'，'\\r\\n'，\\n'）分隔，返回一个包含各行作为元素的列表。如果参数 keepends 为 False，返回的列表则不包含换行符；如果为 True，则保留换行符。 str.startswith(substr[, beg=0, end=len(string)]) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果 beg 和 end 指定值，则在指定范围内检查。 str.strip([chars]) 在字符串上执行 lstrip() 和 rstrip()。即移除字符串头尾指定的字符 chars（默认为空格）。 str.swapcase() 将字符串中大写转换为小写，小写转换为大写。 str.title() 返回 “标题化” 的字符串，即转化为所有单词都是以大写开始，其余字母均为小写的形式。 str.translate(table[, deletechars=&quot;&quot;]) 根据 str 给出的表（包含 256 个字符）转换 str 的字符，要过滤掉的字符放到 deletechars 参数中。 str.upper() 转换字符串中的小写字母为大写。 str.zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充 0。 str.isdecimal() 检查字符串是否只包含十进制字符（只存在于 unicode 对象。），如果是返回 True，否则返回 False。 encode() 和 decode() 用法实例： &gt;&gt;&gt; str = &quot;Hello World!&quot;; &gt;&gt;&gt; str_utf8 = str.encode(&quot;UTF-8&quot;) &gt;&gt;&gt; str_gbk = str.encode(&quot;GBK&quot;) &gt;&gt;&gt; print(str) Hello World! &gt;&gt;&gt; print(&quot;UTF-8 编码：&quot;, str_utf8) UTF-8 编码： b'Hello World!' &gt;&gt;&gt; print(&quot;GBK 编码：&quot;, str_gbk) GBK 编码： b'Hello World!' &gt;&gt;&gt; print(&quot;UTF-8 解码：&quot;, str_utf8.decode('UTF-8','strict')) UTF-8 解码： Hello World! &gt;&gt;&gt; print(&quot;GBK 解码：&quot;, str_gbk.decode('GBK','strict')) GBK 解码： Hello World! maketrans() 的用法： &gt;&gt;&gt; intab = &quot;aeiou&quot; &gt;&gt;&gt; outtab = &quot;12345&quot; &gt;&gt;&gt; trantab = str.maketrans(intab, outtab) &gt;&gt;&gt; str = &quot;this is string example....wow!!!&quot; &gt;&gt;&gt; print (str.translate(trantab)) th3s 3s str3ng 2x1mpl2....w4w!!! split() 的用法： &gt;&gt;&gt; str = &quot;this is string example....wow!!!&quot; &gt;&gt;&gt; print (str.split( )) # 以空格为分隔符 ['this', 'is', 'string', 'example....wow!!!'] &gt;&gt;&gt; print (str.split('i',1)) # 以 i 为分隔符 ['th', 's is string example....wow!!!'] &gt;&gt;&gt; print (str.split('w')) # 以 w 为分隔符 ['this is string example....', 'o', '!!!'] byte样式字符串 在字符串前面加上字符 b，可以得到该字符串的字节类型对象： b'Hello World!' 使用 16 进制 ASCII 码赋值： &gt;&gt;&gt; b'\\x48\\x65\\x6C\\x6C\\x20\\x57\\x6F\\x72\\x6C\\x64\\x21' b'Hell World!' &gt;&gt; b&quot;\\x01\\x02\\x03&quot; b'\\x01\\x02\\x03' Python 会自动将可读的部分按照转换为文字。如果数据是不可读的，则使用 16 进制来表示。 byte 对象的元素是字节： &gt;&gt;&gt; bt = b'Hello World!' &gt;&gt;&gt; bt[2] 108 可以使用 bin() 查看每个字节在内存中的存储方式： &gt;&gt;&gt; bin(bt[2]) '0b1101100' 除字面量表示之外，还可以用 bytes() 函数来得到字节类型。 List 列表（List）由一系列按特定顺序排列的元素组成，它是写在方括号 [] 之间、用逗号分隔开的元素列表。列表其实更像是 Python 中的线性数据结构的实现，它具有绝大多数常见的线性数据结构的操作。 列表中元素的类型可以不相同，它支持数字，字符串，甚至可以包含列表（嵌套）。 &gt;&gt;&gt; list = [1, '2', 3.4, [5, 6], (7, 8), {9, 10}] &gt;&gt;&gt; print(list) [1, '2', 3.4, [5, 6], (7, 8), {9, 10}] 有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。 列表的截取的语法格式：变量[头下标:尾下标:步长]。遵循左闭右开原则。 尾下标从 1 开始。 步长是指输出字符串中第 nnn 个元素后，接着输出第 (n+步长)(n + 步长)(n+步长) 个元素，直至到达尾下标指定处。 省略尾下标代表截取到字符串的最后一个字符，省略头下标代表从第一个字符开始截取。 &gt;&gt;&gt; list = [1, '2', 3.4, [5, 6], (7, 8), {9, 10}] &gt;&gt;&gt; print (list[0]) # 输出列表第一个元素 1 &gt;&gt;&gt; print (list[1:3]) # 从第二个开始输出到第三个元素 ['2', 3.4] &gt;&gt;&gt; print (list[2:]) # 输出从第三个元素开始的所有元素 [3.4, [5, 6], (7, 8), {9, 10}] &gt;&gt;&gt; print(list[:]) # 同时省略头下标和尾，创建了一个list的副本 &gt;&gt;&gt; tinylist = [123, 'list'] &gt;&gt;&gt; print (list + tinylist) # 连接列表 [1, '2', 3.4, [5, 6], (7, 8), {9, 10}, 123, 'list'] &gt;&gt;&gt; double = tinylist * 2 # 重复列表 &gt;&gt;&gt; print(double) [123, 'list', 123, 'list'] &gt;&gt;&gt; print(list[::-1]) # 步长为-1，表示逆向 [{9, 10}, (7, 8), [5, 6], 3.4, '2', 1] &gt;&gt;&gt; list[len(list):] = [6] # 在列表末尾插入元素 &gt;&gt;&gt; print(list) [1, '2', 3.4, [5, 6], (7, 8), {9, 10}, 6] 列表中的元素是可更改的，并且列表长度也是可改变的。List 内置了许多方法来支持这种特性。 &gt;&gt;&gt; list = [1, 2, 3] &gt;&gt;&gt; list[1] = 6 &gt;&gt;&gt; print(list) [1, 6, 3] 列表可以用 + 运算符拼接，用 * 运算符重复。 &gt;&gt;&gt; list1 = [1, 2, 3] &gt;&gt;&gt; list2 = [4, 5, 6] &gt;&gt;&gt; list = list1 + list2 &gt;&gt;&gt; print(list) [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; list = list1 * 2 &gt;&gt;&gt; print(list) [1, 2, 3, 1, 2, 3] 虽然列表和字符串有一些特性很相似，但它们是两个完全不同的类型。 删除列表或列表元素： &gt;&gt;&gt; list = [1, 2, 3] &gt;&gt;&gt; del list[3] &gt;&gt;&gt; print(list) [1, 2, 3] 列表方法 方法 说明 list.append(obj) 在列表末尾添加新的对象 obj，无返回值。相当于 list[len(list):] = [x] list.count(obj) 返回 obj 在列表中出现的次数。 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。 seq —— 元素列表，可以是列表、元组、集合、字典，若为字典，则仅会将键（key）作为元素依次添加至原列表的末尾。 list.index(x[, start[, end]]) 从列表中找出某个值第一个匹配项的索引位置。如果没有找到对象则抛出异常。 x—— 查找的对象； start —— 可选，查找的起始位置； end —— 可选，查找的结束位置。 list.insert(index, obj) 将对象插入列表，无返回值。 index —— 对象 obj 需要插入的索引位置； obj —— 要插入列表中的对象。 list.pop([index=-1]) 移除列表中 index 指定的元素（默认最后一个元素），并且返回该元素的值。 list.remove(obj) 移除列表中值与 obj 相同的第一个匹配项，无返回值。 list.reverse() 反向列表中元素。 list.sort(key=None, reverse=False) 对原列表进行排序。 key —— 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序；↩ reverse —— 排序规则，reverse = True 降序， reverse = False 升序（默认）。 list.clear() 清空列表，类似于 del list[:]。 list.copy() 返回复制后的新列表，类似于 list[:]。 list.sort() 指定排序元素： # 获取列表的第二个元素 def takeSecond(elem): return elem[1] # 列表 random = [(2, 2), (3, 4), (4, 1), (1, 3)] # 指定第二个元素排序 random.sort(key=takeSecond) # 输出类别 print ('排序列表：', random) # 输出：排序列表：[(4, 1), (2, 2), (1, 3), (3, 4)] Python 列表的特性可以很方便地将其封装成其他线性数据结构。 列表推导式 列表推导式是指在方括号 [] 中使用 for 语句生成一串序列，这个 for 语句可以有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。 &gt;&gt;&gt; [x**2 for x in range(10)] [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] &gt;&gt;&gt; [str(round(355/113, i)) for i in range(1, 6)] ['3.1', '3.14', '3.142', '3.1416', '3.14159'] Tuple 元组（tuple）与列表类似，不同之处在于元组的元素可修改。元组写在小括号 () 里，元素之间用逗号隔开。 元素的类型可以不相同。 元组中只包含一个元素时，需要在元素后面添加逗号 , ，否则括号会被当作运算符使用。 有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。 列表的截取的语法格式：变量[头下标:尾下标:步长]。遵循左闭右开原则。 元组元素不可修改是指元组中每个元素的指向永远不变。 无法对元组的元素进行增删操作，但并非所有类型的元素都不可修改。 对于不可变数据类型的元素，的确不能修改。 对于可变数据类型的元素，可以按照其规则修改。 &gt;&gt;&gt; tuple = (1, [1, 2, 3]) &gt;&gt;&gt; print(tuple) (1, [1, 2, 3]) &gt;&gt;&gt; tuple[1][0] = 2 &gt;&gt;&gt; print(tuple) (1, [2, 2, 3]) 可以用 + 运算符拼接，用 * 运算符重复。 元组的某些操作可以参照列表，除了增加和删除元素的操作。 元组支持推导式： &gt;&gt;&gt; tuple(x**2 for x in range(10)) (0, 1, 4, 9, 16, 25, 36, 49, 64, 81) Set 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。集合的基本功能是进行成员关系测试和删除重复元素。可以使用大括号 {} 或者构造函数 set() 创建集合。 集合是一个无序不重复元素的集。 元素的类型可以不相同。 元素是可更改的。 创建空集： 使用不带参数的构造函数 set() 创建，不可使用 {} 创建（{} 代表空字典）。 &gt;&gt;&gt; s = set() &gt;&gt;&gt; print(s) set() 不包含多余的重复元素。在集合中，不会多次出现的相同元素。 不可使用索引或截取等操作。 可以使用集合运算。 &gt;&gt;&gt; set1 = {1, 2, 3, 4, 5, 7} &gt;&gt;&gt; set2 = {2, 4, 6, 7, 8} &gt;&gt;&gt; print(set1 - set2) # set1 和 set2 的差集 {1, 3, 5} &gt;&gt;&gt; print(set1 | set2) # set1 和 set2 的并集 {1, 2, 3, 4, 5, 6, 7, 8} &gt;&gt;&gt; print(set1 &amp; set2) # set1 和 set2 的交集 {2, 4, 7} &gt;&gt;&gt; print(set1 ^ set2) # set1 和 set2 的对称差集 {1, 3, 5, 6, 8} 集合支持推导式： &gt;&gt;&gt; {x**2 for x in range(10)} {0, 1, 64, 4, 36, 9, 16, 49, 81, 25} 集合的成员测试： avengers = {'captain america', 'iron man', 'thor', 'doctor strange', 'star-Lord', 'hulk', 'black widow', 'black panther', 'spider man'} if 'spider man' in avengers: print('蜘蛛侠是复仇者') else: print('蜘蛛侠不是复仇者') if 'thanos' in avengers: print('灭霸是复仇者') else: print('灭霸不是复仇者') 集合方法 方法 描述 set.add() 为集合添加元素。 set.clear() 移除集合中的所有元素。 set.copy() 拷贝一个集合。 set.difference(set1, set2, ...) 返回集合 (set−set1)∩(set−set2)∩⋯(set - set1)\\cap(set - set2)\\cap\\cdots(set−set1)∩(set−set2)∩⋯。 set.difference_update(set1, set2, ...) 移除集合 set 中的元素，该元素在指定的集合 set1, set2, ... 也存在。 即，将集合 set 更新为集合 (set−set1)∩(set−set2)∩⋯(set - set1)\\cap(set - set2)\\cap\\cdots(set−set1)∩(set−set2)∩⋯。 set.discard(value) 删除集合 set 中指定的元素 value。 与 remove() 不同的是，如果 value 不存在 set 中，并不会发生错误。 set.intersection(set1, set2, ...) 返回集合 set∩set1∩set2∩⋯set \\cap set1 \\cap set2 \\cap \\cdotsset∩set1∩set2∩⋯。 set.intersection_update(set1, set2, ...) 将集合 set 更新为集合 set∩set1∩set2∩⋯set \\cap set1 \\cap set2 \\cap \\cdotsset∩set1∩set2∩⋯。 set1.isdisjoint(set2) 判断集合 set1 和 set2 是否包含相同的元素，如果没有返回 True，否则返回 False。 set1.issubset(set2) 判断集合 set1 是否是集合 set2 的子集。如果是，则返回 True；否则返回 False。 set1.issuperset(set2) 判断集合 set1 是否是集合 set2 的父集。如果是，则返回 True；否则返回 False。 set.pop() 随机移除元素，并返回该元素。 set.remove(item) 移除指定元素 item。如果 item 不存在 set 中，会发生错误。 set1.symmetric_difference(set2) 返回集合 set1 和 set2 的对称差集 set1⊕set2set1 \\oplus set2set1⊕set2。 set1.symmetric_difference_update(set2) 将集合 set1 更新为 set1⊕set2set1 \\oplus set2set1⊕set2。 set.union(set1, set2...) 返回集合 set∪set1∪set2∪⋯set \\cup set1 \\cup set2 \\cup \\cdotsset∪set1∪set2∪⋯。 set.update(added_set) 添加新的元素或集合到当前集合中。 added_set —— 可以是元素或集合。 Dictionary 字典是一种映射类型，用 {} 标识，是一个无序的 key:value （键 - 值对）的集合。字典当中的元素是通过键来存取的，而不是通过偏移存取。字典还可以使用构造函数 dict() 创建。 # 一般方法： dic = { 'name': 'tom', 'age': 20, 'height': 185, # cm 'weight': 71 # kg } print(dic) # 输出：{'name': 'tom', 'age': 20, 'height': 185, 'weight': 71} # 构造函数： # 1. dic = dict( name = 'lucy', age = 18, height = 169, weight = 56 ) print(dic) # 输出：{'name': 'lucy', 'age': 18, 'height': 169, 'weight': 56} # 2. dic = dict([ ('name', 'jiessie'), ('age', 25), ('height', 178), ('weight', 63) ]) print(dic) # 输出：{'name': 'jiessie', 'age': 25, 'height': 178, 'weight': 63} # 使用 for 循环： dic = { x: x**2 for x in (2, 4, 6) } print(dic) # 输出：{2: 4, 4: 16, 6: 36} 更多构造字典的方法↩。 键（key）必须使用不可变类型，且是唯一的。 &gt;&gt;&gt; dic = {1:20, 'a':50, (1, 2, 3):6} &gt;&gt;&gt; print(dic) {1: 20, 'a': 50, (1, 2, 3): 6} &gt;&gt;&gt; print(dic[1]) 20 &gt;&gt;&gt; print(dic['a']) 50 &gt;&gt;&gt; print(dic[(1, 2, 3)]) 6 值（value）可以是任何类型的元素。 使用键作为索引。 使用 in 操作符判断键是否存在字典中，如 key in dict ，如果键在字典dict里返回 True，否则返回 False。not in 操作符与 in 相反。 字典方法 方法 说明 radiansdict.clear() 删除字典内所有元素，无返回值。 radiansdict.copy() 返回一个字典的浅复制。 radiansdict.fromkeys(seq[, value]) 创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值（可选）。 radiansdict.get(key, default=None) 返回指定键 key 的值，如果键不在字典中返回 default 设置的默认值。 radiansdict.items() 以列表返回一个视图对象，视图对象中的元素以键-值对 (key, value) 的形式显示。 视图对象不是列表，不支持索引，其中的元素是键-值对。字典的视图对象都是只读的，但字典改变，视图也会跟着变化。 radiansdict.keys() 返回一个只包含键的视图对象。 radiansdict.setdefault(key, default=None) 和 get() 类似，如果 key 存在于 radiandict 中，就返回其值；但如果 key 不存在于字典中，将会添加键并将值设为 default。 radiansdict.update(dict2) 把字典 dict2 的键-值对更新到 dict 里，无返回值。 radiansdict.values() 返回一个只包含值的视图对象。 radiansdict.pop(key[, default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key 值必须给出。否则，返回 default 值。如果 key 不存在字典中，返回 default 值（default 值必须给出，否则会报错。 radiansdict.popitem() 随机返回并删除字典中的最后一对键和值 (key, value)。 如果字典已经为空，却调用了此方法，就报出 KeyError 异常。 函数操作 函数 说明 len(obj) 返回对象的元素个数 max(x1[, x2[, x3[, ...]]]) 返回参数中最大值，参数还可以是集合、列表或元组。 min(x1[, x2[, x3[, ...]]]) 返回参数中最小值，参数还可以是集合、列表或元组。 数据类型转换 将数据类型作为函数名即可进行数据类型的转换。以下内置的数据类型转换函数返回一个新的对象，表示转换的值。 函数 描述 int(x, base = 10) 将 x 转换为一个整数。 x —— 字符串或数字； base —— 基数（进制数），默认 10。 float(x = 0.0) 将 x 转换为一个浮点数。 x —— 字符串或数字，默认为 0.0。 complex(real[, imag]) 创建一个值为 real + imag * j 的复数。 real —— 为字符串时不需要指定第二个参数，还可以为 int 或 float； imag —— int、float。 str(object = '') 将对象 object 转换为字符串，默认为空字符串。 repr(object) 将对象 object 转换为表达式字符串。↩ eval(expression[, globals[, locals]]) 用来执行字符串中的有效表达式，并返回表达式的值。 expression —— 表达式字符串； globals —— 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象； locals —— 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。 tuple(iterable) 将序列 iterable 转换为一个元组。 iterable —— 可迭代对象，如列表、字典、元组等等。 list(seq) 将序列 seq 转换为一个列表。 seq —— 元组或字符串。 set([iterable]) 将 iterable 转换为可变集合，默认创建空集。 iterable —— 可迭代对象。 dict(**kwarg)、 class dict(mapping, **kwarg) 、 class dict(iterable, **kwarg) 创建一个字典，默认创建空集。↩**kwargs —— 关键字，如 key=value； mapping —— 元素的容器； iterable —— 可迭代对象。 frozenset([iterable]) 将 iterable 转换为不可变集合，默认创建空集。 iterable —— 可迭代的对象。 chr(i) 将一个整数 i（in rang(256)）转换为一个字符。 返回值是当前整数对应的 ASCII 字符。 ord(c) 将一个字符 c 转换为它的整数值（ASCII 数值，或者 Unicode 数值）。 c —— 字符（长度为 1 的字符串）。 如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。 hex(x) 将整数 x 转换为一个十六进制字符串（以 0x 为前缀）。 oct(x) 将整数 x 转换为一个八进制字符串。 Python2.x 版本的 8 进制以 0 作为前缀表示； Python3.x 版本的 8 进制以 0o 作为前缀表示。 repr 的用法： &gt;&gt;&gt; dic = [1, 2, 3] &gt;&gt;&gt; repr(dic) '[1, 2, 3]' dict() 的用法： &gt;&gt;&gt;dict() # 创建空字典 {} &gt;&gt;&gt; dict(a='a', b='b', t='t') # 传入关键字 {'a': 'a', 'b': 'b', 't': 't'} &gt;&gt;&gt; dict(zip(['one', 'two', 'three'], [1, 2, 3])) # 映射函数方式来构造字典 {'one': 1, 'two': 2, 'three': 3} &gt;&gt;&gt; dict([('one', 1), ('two', 2), ('three', 3)]) # 可迭代对象方式来构造字典 {'one': 1, 'two': 2, 'three': 3} 其他操作 使用 Python 的 type() 函数查看变量的类型： &gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j &gt;&gt;&gt; print(type(a), type(b), type(c), type(d)) &lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt; 使用 isinstance 判断数据类型是否正确： &gt;&gt;&gt; a = 111 &gt;&gt;&gt; isinstance(a, int) True isinstance() 和 type() 的区别在于： type() 不会认为子类是一种父类类型。 isinstance() 会认为子类是一种父类类型。即，子类和父类被认为是同一类型。 &gt;&gt;&gt; class A: ... pass ... &gt;&gt;&gt; # B 是 A 的子类 &gt;&gt;&gt; class B(A): ... pass ... &gt;&gt;&gt; isinstance(A(), A) True &gt;&gt;&gt; type(A()) == A True &gt;&gt;&gt; isinstance(B(), A) True &gt;&gt;&gt; type(B()) == A False Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加。 &gt;&gt;&gt; True == 1 True &gt;&gt;&gt; False == 0 True 可以通过 is 来判断： &gt;&gt;&gt; True is 1 False &gt;&gt;&gt; flag = True &gt;&gt;&gt; flag is True True 使用 del 删除对象： del var # 删除一个对象 del var_1, var_2 # 删除多个对象 print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=&quot;&quot;： &gt;&gt;&gt; str1 = 'Hello ' &gt;&gt;&gt; str2 = 'World!' &gt;&gt;&gt; print(str1); print(str2) Hello World! &gt;&gt;&gt; print(str1, end = ''); print(str2) Hello World! 运算符 算术运算符 Operators Explains + 加 操作对象为字符串、列表或元组时，表示将两个对象拼接在一起。 - 减 * 乘 a * b，若 a 为字符串、列表或元组，b 为整数时，表示将 b 个 a 拼接在一起。 / 除 % 取模 ** 幂，如 a**b 返回 a 的 b 次方 // 整除，向下取整 比较（关系）运算符 所有比较运算符返回 1（或 True）表示真，返回 0（或 False）表示假。 Operators Explains == 相等 != 不等于 Python 3 已不支持 &lt;&gt; &gt; 大于 &lt; 小于 &gt;= 大于等于 - 返回x是否大于等于y。 &lt;= 小于等于 - 返回x是否小于等于y。 赋值运算符 Operators Explains = 赋值运算符 += 加法赋值运算符 -= 减法赋值运算符 *= 乘法赋值运算符 /= 除法赋值运算符 %= 取模赋值运算符 **= 幂赋值运算符 //= 取整除赋值运算符 := 海象运算符，可在表达式内部为变量赋值，然后直接进行判断。Python3.8 版本新增运算符。 位运算符 Operators Explain &amp; 按位与运算符： 参与运算的两个值，如果两个相应位都为 1，则该位的结果为 1，否则为 0。 | 按位或运算符： 只要对应的两个二进位有一个为 1 时，结果位就为 1。 ^ 按位异或运算符： 当两对应的二进位相异时，结果为 1。 ~ 按位取反运算符： 对数据的每个二进制位取反，即把 1 变为 0，把 0 变为 1。~x 类似于 x-1 &lt;&lt; 左移动运算符： 运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数指定移动的位数，高位丢弃，低位补 0。 &gt;&gt; 右移动运算符： 把 &gt;&gt; 左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数指定移动的位数。 逻辑运算符 Operators Expressions Explains and x and y 布尔 “与” 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。 or x or y 布尔 “或” 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 not not x 布尔 “非” 如果 x 为 True，返回 False；如果 x 为 False，它返回 True。 成员运算符 Operators Explains in 如果在指定的序列中找到值返回 True，否则返回 False。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 身份运算符 Operators Explains is 判断两个标识符是不是引用自一个对象。 x is y，类似 id(x) == id(y)。 如果引用的是同一个对象则返回 True，否则返回 False is not 判断两个标识符是不是引用自不同对象。 x is not y，类似 id(a) != id(b)。 如果引用的不是同一个对象则返回结果 True，否则返回 False。 is 和 == 的区别： &gt;&gt;&gt;a = [1, 2, 3] &gt;&gt;&gt; b = a &gt;&gt;&gt; b is a True &gt;&gt;&gt; b == a True &gt;&gt;&gt; b = a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b == a True 运算符优先级 优先级按从高到底排列： Operators Explains ** 指数 ~ + - 按位翻转，一元加号和减号（最后两个的方法名为 +@ 和 -@） * / % // 乘，除，求余数和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 按位与 ^ | 按位异或，按位与 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 if条件控制 if 语句的形式： if condition_1: statement_block_1 elif condition_2: statement_block_2 else: statement_block_3 if 语句的条件通常由关系运算符或返回值为布尔值的语句组成，使用逻辑运算符在一条 if 语句中连接多个条件。 条件运算符 Python 提供了条件运算符（三目运算符）： statement_1 if condition else statement 如果 condition 为 True，执行 statement_1 并且返回 staement_1 的结果。 如果 condition 为 False，执行 statement_2 并且返回 statement_2 的结果。 循环语句 Python 有 while 和 for 两种循环语句。 while条件循环 while 循环的一般用法是，当指定条件成立时执行一次 while 后的代码块。 while condition: statements_block while 语句后可接 else 语句。当指定条件不成立时，执行一次 while 后面的 else 语句。 while condition: statements_block_1 else: statements_block_2 for循环遍历 for 循环的一般用法是，遍历任何可迭代对象。每次循环，都会从指定的可迭代对象中选取一个赋给指定的变量。如此循环下去，直到遍历完指定的可迭代对象中所有元素。 for variables in sequence: statements_block for 语句后可接 else 语句。当指定的可迭代对象为空时，执行一次 for 后面的 else 语句。 for variable in sequence: statements_block_1 else: statements_block_2 for 循环经常与 range() 函数一起使用。当需要遍历数字序列时，可以使用 range() 函数生成数列。 # 输出数字 5~12 for i in range(5, 13): print(i, end=' ') print('') # 输出一个换行符 遍历技巧 在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来： &gt;&gt;&gt; dict = {'one':1, 'two': 2, 'three': 3} &gt;&gt;&gt; for key, val in dict.items(): ... print(key, ' = ', val) ... one = 1 two = 2 three = 3 在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到： &gt;&gt;&gt; for index, val in enumerate(['one', 'two', 'three']): ... print(index, ': ', val) ... 0 : one 1 : two 2 : three 同时遍历两个或更多的序列，可以使用 zip() 组合： &gt;&gt;&gt; questions = ['name', 'quest', 'favorite color'] &gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue'] &gt;&gt;&gt; for q, a in zip(questions, answers): ... print('What is your {0}? It is {1}.'.format(q, a)) ... What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. 反向遍历序列，可以调用 reversed() 函数： &gt;&gt;&gt; for i in reversed(range(10)): ... print(i, end = '') ... 9876543210 要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值： &gt;&gt;&gt; basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana'] &gt;&gt;&gt; for f in sorted(set(basket)): ... print(f) ... apple banana orange pear 列表推导式 列表推导式（又称列表解析式）的基本语法如下： [val for val in sequence if_or_for_statement] # if_or_for_statement是一个if判断语句或for循环 # 如果是if语句，那么只有条件位真时val才会在列表中 Example： &gt;&gt;&gt; [x for x in range(10)] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 列表推导式中的for语句和if语句是可嵌套的： [x*y for x in range(1,5) if x &gt; 2 for y in range(1,4) if y &lt; 3] 上面语句的执行顺序是： for x in range(1,5) if x &gt; 2 for y in range(1,4) if y &lt; 3 x*y 列表推导式除了list还可以被转化成其它对象： &gt;&gt;&gt; (x for x in range(10)) &lt;generator object &lt;genexpr&gt; at 0x0000026F7A655BA0&gt; &gt;&gt;&gt; tuple(x for x in range(10)) (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) break and continue break 语句 —— 跳出（终止）循环。不执行当前循环块中 break 语句以下的语句，并且将控制转移到当前循环语句的下一条语句。 continue 语句 —— 进入下一轮循环。不执行当前循环块中 continue 语句以下的语句，并且将控制转义到循环语句的开头。 break 和 continue 在循环语句中使用。一般在循环中的 if 条件语句中使用。即，达到某个条件便结束或进入下一次循环。 pass语句 pass 语句是空语句，即不执行任何操作。pass 是为了保持 Python 程序结构的完整性。 pass 一般作为占位语句，当操作都在条件语句或循环语句中完成时，在语句块中使用 pass 占位。如： if condition_1: pass while condition_2: pass for variable in sequence: pass 迭代器与生成器 迭代器 迭代是一种访问集合元素的方式。迭代器是一个可以记住遍历位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 字符串、列表或元组对象都可用于创建迭代器。 &gt;&gt;&gt; list = [1, 2, 3, 4] &gt;&gt;&gt; it = iter(list) # 创建迭代器对象 &gt;&gt;&gt; print(next(it)) # 输出迭代器的下一个元素 1 &gt;&gt;&gt; print(next(it)) 2 迭代器对象可以使用常规 for 语句进行遍历： list = [1, 2, 3, 4] it = iter(list) # 创建迭代器对象 for x in it: print(x, end = ' ') 使用 next() 迭代： import sys # 引入 sys 模块 list=[1, 2, 3, 4] it = iter(list) # 创建迭代器对象 while True: try: print (next(it)) except StopIteration: sys.exit() 创建迭代器 把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。 __iter__() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__()方法并通过 StopIteration 异常标识迭代的完成。 __next__() 方法（Python 2 里是 next()）会返回下一个迭代器对象。 class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers() myiter = iter(myclass) i = 0 while i &lt; 10: print(next(myiter), end = ' ') i += 1 # 输出：1 2 3 4 5 6 7 8 9 10 迭代结束标志 StopIteration 异常用于标识迭代的完成，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 # 迭代 10 次后停止 class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration myclass = MyNumbers() myiter = iter(myclass) for x in myiter: print(x, end = ' ') # 输出：1 2 3 4 5 6 7 8 9 10 生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator），生成器是一个返回迭代器的函数，只能用于迭代操作。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 1, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() # 输出：1 1 2 3 5 8 13 21 34 55 89 函数 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。 函数的定义形式： def function_name(arguments): &quot;&quot;&quot;explain&quot;&quot;&quot; statements_block return [expression] # end function_name explain 是使用文档字符串存放的函数说明。 return 代表一个函数的结束，并且返回一个值给调用方，这个值放在 return 后面，可以是具体的值也可以是一条有确切值的表达式。不带值或表达式的 return 相当于返回 None。当函数不需要返回值时，可以省略 return。 调用一个函数时需要使用该函数名并根据其定义指定参数： def function_name(arguments): &quot;&quot;&quot;explain&quot;&quot;&quot; statements_block return [expression] # end function_name function_name(arguments) 参数 不可变类型的参数传递：类似 C++ 的值传递。传递的只是参数的值，没有影响参数对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。即，修改参数之前函数内部参数的地址和函数外部参数的地址相同，一旦修改了变量，参数的地址将会发生变化。如 Number、String、Tuple。 可变类型的参数传递：类似 C++ 的引用传递。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响。无论是否对参数进行修改，参数地址都不会发生改变。如 List、Dictionary、Set。 参数类型： 必须参数：须以正确的顺序传入函数。调用时，必须参数的数量必须和声明时一样。 关键字参数：函数调用时使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 def func(a, b): print('a = ', a, 'b = ', b) return func(b = 2, a = 1) 默认参数：调用函数时，如果没有传递参数，则会使用默认参数。默认参数在定义函数时定义。 def func(a, b = 1) print('a = ', a, 'b = ', b) return func(2) 不定长参数： 加了星号 * 的参数会以元组的形式导入，存放所有未命名的变量参数。 def func(atg1, *vartuple): print(atg1, vartuple) return func(1, 2, 3) # 输出：1 (2, 3) 加了两个星号 ** 的参数会以字典的形式导入。 def func(atg1, **vartuple): print(atg1, vartuple) return func(1, a = 2, b = 3) # 输出：1 {'a': 2, 'b': 3} 如果参数单独出现星号 * 后的参数必须用关键字传入。 &gt;&gt;&gt; def f(a,b,*,c): ... return a+b+c ... &gt;&gt;&gt; f(1,2,3) # 报错 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: f() takes 2 positional arguments but 3 were given &gt;&gt;&gt; f(1,2,c=3) # 正常 6 强制位置参数：Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。 def f(a, b, /, c): print(a, b, c) return # 形参 a 和 b 必须使用指定位置参数，c 可以是位置形参或关键字形参 f(1, 2, c = 3) lambda匿名函数 Python 使用 lambda 来创建匿名函数。 lambda 的主体是一个表达式，而不是一个代码块（比 def 简单很多）。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 lambda 函数的语法： lambda [arg1 [,arg2,.....argn]]: expression 用法： &gt;&gt;&gt; sum = lambda arg1, arg2: arg1 + arg2 &gt;&gt;&gt; sum(1, 2) 3 模块 模块是一个包含函数定义和变量的文件，其后缀名是 .py。 模块可以被别的程序引入，以使用该模块中的函数等功能。 Python 标准库也是一个个内置的模块。 这些模块会根据不同的操作系统进行不同的配置，不同的操作系统可能会有一些不同的模块。 每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用，可以使用 dir() 查看。 在导入模块后，可以通过 modname.itemname 这样的表示法来访问模块内的函数。 模块可以被导入其他模块。被导入的模块的名称将被放入当前操作的模块的符号表中。 模块除了方法定义，还可以包括可执行的代码。 这些代码一般用来初始化这个模块，只有在第一次被导入时才会被执行。 包 包是一种管理 Python 模块命名空间的形式，采用 “点模块名称”。如一个模块的名称是 A.B， 那么他表示一个包 A 中的子模块 B。优点是不用担心不同模块之间的名称冲突。 包结构实例： sound/ 顶层包 __init__.py 初始化 sound 包 formats/ 文件格式转换子包 __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ 声音效果子包 __init__.py echo.py surround.py reverse.py ... filters/ filters 子包 __init__.py equalizer.py vocoder.py karaoke.py ... 包还提供一个额外的属性 __path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的 __init__.py，得在其他 __init__.py 被执行前定义。可以修改这个变量，用来影响包含在包里面的模块和子包。这个功能并不常用，一般用来扩展包里面的模块。 import语句 import module1[, module2[,... moduleN] 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。import 命令一般放在脚本顶端，如： #!/usr/bin/python3 # Filename: support.py def print_hello(): print ('Hello World！') return #!/usr/bin/python3 # Filename: test.py # 导入模块 import hello # 使用 . 运算符调用模块中的函数 hello.print_hello() 对于同一个模块，无论执行了多少次 import 语句，一个模块只会被导入一次。 搜索路径是一个解释器会先进行搜索的所有目录的列表，由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块（很像环境变量）。搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在 sys 模块中的 path 变量。 以 Windows 系统为例（在 VS2017 中安装的 Python3）： &gt;&gt;&gt; import sys &gt;&gt;&gt; print(sys.path) ['', 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\\\\python36.zip', 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\\\\DLLs', 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\\\\lib', 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64', 'C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\Python36_64\\\\lib\\\\site-packages'] sys.path 输出是一个列表，其中第一项是空串，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），即我们执行 Python 解释器的目录（对于脚本的话就是运行的脚本所在的目录）。 如果要引入一些不在搜索路径中的模块，可以在脚本中修改 sys.path。 如果要经常使用一个模块中的函数，可以赋给它一个本地名称： import module func = module.func func(arg) from ... import语句 使用 from ... import 语句可以从模块中导入一个指定的部分到当前命名空间中。这种导入的方法不会把被导入的模块的名称放在当前的字符表中。 from modname import item1[, item2[, ... itemN]] 这样只会把 modname 中的指定的部分 item1[, item2[, ... itemN]] 导入到当前命名空间中，并且可以直接使用它们的名称来调用它们（无需使用 . 运算符）。item1[, item2[, ... itemN]] 可以是子模块、函数、类或变量等。 使用 from package import item 这种形式的时候，import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。 把一个模块的所有内容全都导入到当前的命名空间（不推荐使用），但是那些由单一下划线 _ 开头的名字不在此例： from modname import * Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。 为了解决这个问题，需要提供一个精确包的索引。导入语句遵循如下规则： 如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。 以下实例在 file:sounds/effects/_init_.py 中包含如下代码： __all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;] from ... import ... as语句 import ... as 可以将导入的模块、函数或者变量等重命名： import name as new_name 该语句也可以接在 from 语句后面： from modname import name as new_name __name__ 属性 一个模块被另一个程序第一次引入时，其主程序将运行。可以用 __name__ 属性来使该程序块仅在该模块自身运行时执行（被其它程序或模块引入时不执行）。 每个模块都有一个 __name__ 属性，当其值是 '__main__' 时，表明该模块自身在运行，否则是被引入。 #!/usr/bin/python3 # Filename: using_name.py if __name__ == '__main__': print('程序自身在运行') else: print('我来自另一模块') $ python using_name.py 程序自身在运行 $ python &gt;&gt;&gt; import using_name 我来自另一模块 dir() 函数 内置的函数 dir() 可以找到指定模块内定义的所有名称，以一个字符串列表的形式返回。 &gt;&gt;&gt; import math &gt;&gt;&gt; dir(math) ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc'] 如果没有给定参数，dir() 函数会罗列出当前定义的所有名称。 &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = 4 &gt;&gt;&gt; dir() ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'b'] 输入输出 标准输出 在 Python 中使用 print() 来将其参数输出到标准输出上。默认的标准输出是屏幕。 可以使用 str.format() 函数等方式⤴ 来格式化输出值。 可以使用 repr() 或 str() 函数来将输出的值转成字符串。 str()：函数返回一个用户易读的表达形式。 repr()：产生一个解释器易读的表达形式。 标准输入 Python 提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。 Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。Python3.x 没有 raw_input()。 input() 函数的语法： input([prompt]) # prompt —— 输出到标准输出的提示信息 用法示例： &gt;&gt;&gt; a = input('输入一个整数：') 输入一个整数：123 &gt;&gt;&gt; type(a) &lt;class 'str'&gt; # input() 返回的是 string &gt;&gt;&gt; a = int(a) # 使用 int() 类型转换 &gt;&gt;&gt; print(type(a), a) &lt;class 'int'&gt; 123 # 此时 a 才是 int input() 接收多个值： #输入三角形的三边长 a, b, c = (input(&quot;请输入三角形三边的长：&quot;).split()) a = int(a) b = int(b) c = int(c) #计算三角形的半周长p p = (a + b + c) / 2 #计算三角形的面积s s = (p * (p - a) * (p - b) * (p - c))**0.5 #输出三角形的面积 print(&quot;三角形面积为：&quot;, format(s, '.2f')) 读写文件 open() 将会返回一个 file 对象，基本语法格式如下： open(filename[, mode='r']) # filename —— 包含了要访问的文件名称的字符串值 # mode —— 打开文件的模式的字符串值，默认文件访问模式为只读（r） 打开文件的模式： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新（可读可写）。 U 通用换行模式（不推荐）。 r 以只读方式打开文件（默认模式）。文件的指针将会放在文件的开头。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。 如果该文件已存在，则清空原文件内容，并从开头开始编辑。 如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。 打开方式与 w 相同（会覆盖原有的文件）。 w+ 打开一个文件用于读写。 打开方式与 w 相同。 wb+ 以二进制格式打开一个文件用于读写。 打开方式与 w 相同。 a 打开一个文件用于追加。 如果该文件已存在，文件指针将会放在文件的结尾。 即，新的内容将会被写入到已有内容之后。 如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。 打开方式与 a 相同。 a+ 打开一个文件用于读写。 打开方式与 a 相同。 ab+ 以二进制格式打开一个文件用于追加。 打开方式与 a 相同。 下图总结了这几种模式： 模式 r r+ w w+ a a+ 读 + + + + 写 + + + + + 创建 + + + + 覆盖 + + 指针在开始 + + + + 指针在结尾 + + open() 函数的完整语法格式： open(file[, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None]) # file —— 必需，文件路径（相对或者绝对路径）。 # mode —— 可选，文件打开模式 # buffering —— 设置缓冲 # encoding —— 一般使用 utf8 # errors —— 报错级别 # newline —— 区分换行符 # closefd —— 传入的 file 参数类型 # opener —— 自定义打开文件方式 打开文件后，要进行的就是写入和读取操作，这些操作都是对 file 对象进行操作。 file 对象方法： 方法 说明 file.close() 关闭文件。关闭后文件不能再进行读写操作。 在执行完文件的读写操作后，有必要执行该方法。 file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 file.fileno() 返回一个整型的文件描述符（file descriptor FD 整型），可以用在如 os 模块的 read 方法等一些底层操作上。 file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。 file.next() 返回文件下一行。 file.read([size=-1]) 从文件读取指定的字节数，默认为 -1，为负数时表示读取所有。 file.readline([size=-1]) 读取整行（size 默认为 -1，为负数表示读取整行），包括 '\\n' 字符。 如果指定了 size 则读取该行的前 size 字符。 第一次调用时读取第一行，第二次调用时读取第二行，以此类推。 file.readlines([sizeint]) 读取所有行并返回列表，若给定 sizeint &gt; 0，则是设置一次读多少字节，这是为了减轻读取压力。 file.seek(offset[, whence=0]) 设置文件当前位置。 offset —— 开始的偏移量。 whence —— 给 offset 参数一个定义，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1代表从当前位置开始算起，2 代表从文件末尾算起。默认为 0。 file.tell() 返回文件当前位置。 file.truncate([size=file.tell()]) 截取文件，截取的字节通过 size 指定，默认为当前文件位置。 file.write(str) 将字符串写入文件，返回的是写入的字符长度。 如果文件打开模式带 b，那写入文件内容时，str 要用 encode() 方法转为 bytes 形式，否则报错：TypeError: a bytes-like object is required, not 'str'。 file.writelines(sequence) 向文件写入一个序列字符串列表（这一序列字符串可以是由迭代对象产生的，如一个字符串列表），如果需要换行则要自己加入每行的换行符。 file.write() 用法： f = open('test.txt', 'w+') f.write('test1') f.seek(0) print('从文件中读取到的字符串：', f.read()) f.close() # 输出： # 从文件中读取到的字符串： test1 f = open('test.txt', 'wb+') f.write('test1'.encode()) f.seek(0) print('从二进制文件中读取到的内容：', f.read()) f.seek(0) print('将其转化为字符串输出：', f.read().decode()) f.close() # 输出： # 从二进制文件中读取到的内容： b'' # 将其转化为字符串输出： test1 os模块 os 模块提供了非常丰富的方法用来处理文件和目录。以下是一些常用的方法： os.access(path, mode) 检验权限模式（使用当前的 UID/GID 尝试访问路径）。 path —— 要用来检测是否有访问权限的路径。 mode —— 参数取值如下： os.F_OK —— 测试 path 是否存在； os.R_OK —— 测试 path 是否可读； os.W_OK —— 测试 path 是否可写； os.X_OK —— 测试 path 是否可执行。 在相应模式下，如果存在/可读/写/执行返回 True ，否则返回 False。 方法 描述 os.chdir(path) 改变当前工作目录到 path 指定的路径。如果允许访问返回 True，否则返回 False。 os.chflags(path, flags) 设置路径 path 的标记为数字标记。多个标记可以使用 OR 来组合起来。 flags —— 参数取值如下： stat.UF_NODUMP —— 非转储文件； stat.UF_IMMUTABLE —— 文件是只读的； stat.UF_APPEND —— 文件只能追加内容； stat.UF_NOUNLINK —— 文件不可删除； stat.UF_OPAQUE —— 目录不透明，需要通过联合堆栈查看； 以下参数值是超级用户可设置的： stat.SF_ARCHIVED —— 可存档文件； stat.SF_IMMUTABLE —— 文件是只读的； stat.SF_APPEND —— 文件只能追加内容； stat.SF_NOUNLINK —— 文件不可删除； stat.SF_SNAPSHOT —— 快照文件。 os.chmod(path, mode) 更改权限 os.chown(path, uid, gid) 更改文件所有者 os.chroot(path) 改变当前进程的根目录 os.close(fd) 关闭文件描述符 fd os.closerange(fd_low, fd_high) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 os.dup(fd) 复制文件描述符 fd os.dup2(fd, fd2) 将一个文件描述符 fd 复制到另一个 fd2 os.fchdir(fd) 通过文件描述符改变当前工作目录 os.fchmod(fd, mode) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 os.fchown(fd, uid, gid) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 os.fdatasync(fd) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 os.fdopen(fd[, mode[, bufsize]]) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 os.fpathconf(fd, name) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 os.fstat(fd) 返回文件描述符fd的状态，像stat()。 os.fstatvfs(fd) 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。 os.fsync(fd) 强制将文件描述符为fd的文件写入硬盘。 os.ftruncate(fd, length) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 os.getcwd() 返回当前工作目录 os.getcwdb() 返回一个当前工作目录的Unicode对象 os.isatty(fd) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 os.lchflags(path, flags) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 os.lchmod(path, mode) 修改连接文件权限 os.lchown(path, uid, gid) 更改文件所有者，类似 chown，但是不追踪链接。 os.link(src, dst) 创建硬链接，名为参数 dst，指向参数 src os.listdir(path) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 os.lseek(fd, pos, how) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 os.lstat(path) 像stat(),但是没有软链接 os.major(device) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 os.makedev(major, minor) 以major和minor设备号组成一个原始设备号 os.makedirs(path[, mode]) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 os.minor(device) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 os.mkdir(path[, mode]) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 os.mkfifo(path[, mode]) 创建命名管道，mode 为数字，默认为 0666 (八进制) os.mknod(filename[, mode=0600, device]) 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 os.open(file, flags[, mode]) 打开一个文件，并且设置需要的打开选项，mode参数是可选的 os.openpty() 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 os.pathconf(path, name) 返回相关文件的系统配置信息。 os.pipe() 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 os.popen(command[, mode[, bufsize]]) 从一个 command 打开一个管道 os.read(fd, n) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 os.readlink(path) 返回软链接所指向的文件 os.remove(path) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 os.removedirs(path) 递归删除目录。 os.rename(src, dst) 重命名文件或目录，从 src 到 dst os.renames(old, new) 递归地对目录进行更名，也可以对文件进行更名。 os.rmdir(path) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 os.stat(path) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 os.stat_float_times([newvalue]) 决定stat_result是否以float对象显示时间戳 os.statvfs(path) 获取指定路径的文件系统统计信息 os.symlink(src, dst) 创建一个软链接 os.tcgetpgrp(fd) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 os.tcsetpgrp(fd, pg) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 os.tempnam([dir[, prefix]]) Python3 中已删除。 返回唯一的路径名用于创建临时文件。 os.tmpfile() Python3 中已删除。 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 os.tmpnam() Python3 中已删除。 为创建一个临时文件返回一个唯一的路径 os.ttyname(fd) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 os.unlink(path) 删除文件路径 os.utime(path, times) 返回指定的path文件的访问和修改的时间。 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]]) 输出在文件夹中的文件名通过在树中游走，向上或者向下。 os.write(fd, str) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 os.path 模块 获取文件的属性信息。 os.pardir() 获取当前目录的父目录，以字符串形式显示目录名。 错误和异常 Python 中的语法错误也可称之为解析错。即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。 异常以不同的类型出现，这些类型都作为信息的一部分打印出来： &gt;&gt;&gt; 10 * (1/0) # 0 不能作为除数，触发异常 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? ZeroDivisionError: division by zero &gt;&gt;&gt; 4 + spam*3 # spam 未定义，触发异常 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? NameError: name 'spam' is not defined &gt;&gt;&gt; '2' + 2 # int 不能与 str 相加，触发异常 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: can only concatenate str (not &quot;int&quot;) to str 错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。 异常处理 try/except 异常捕捉可以使用 try/except 语句： # 执行一次 try 子句，并尝试捕捉异常 # 如果没有异常发生，忽略 except 子句 # 当捕捉到异常时，将执行对应的 except 子句 # 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中 # 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。但最多只有一个分支会被执行。 try: statement_1 except Error1: statement_2 except Error2: statement_3 ...... except: # 省略异常的名称，将被当作通配符使用 statement_n # 2. 一次处理多个异常 try: statement_1 except (Error1, Error2, ...): # 这里是一个元素为“异常”的元组 statement_2 Example： while True: try: x = int(input(&quot;请输入一个数字: &quot;)) break except ValueError: print(&quot;您输入的不是数字，请再次尝试输入！&quot;) import sys try: f = open('myfile.txt') s = f.readline() i = int(s.strip()) except OSError as err: print(&quot;OS error: {0}&quot;.format(err)) except ValueError: print(&quot;Could not convert data to an integer.&quot;) except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise # 再次将触发的异常抛出 try/except ... else try/except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。else 子句将在 try 子句没有发生任何异常的时候执行。 try: statement_1 except Error1: statement_2 except Error2: statement_3 ...... except: statement_n else: statement_e 判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容： for arg in sys.argv[1:]: try: f = open(arg, 'r') except IOError: print('cannot open', arg) else: print(arg, 'has', len(f.readlines()), 'lines') f.close() 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。 try-finally try-finally 语句无论是否发生异常都将执行 finally 子句的代码。 try: statement_1 except Error1: statement_2 except Error2: statement_3 ...... except: statement_n else: statement_e finally: statement_f Example： try: runoob() except AssertionError as error: print(error) else: try: with open('file.log') as file: read_data = file.read() except FileNotFoundError as fnf_error: print(fnf_error) finally: print('这句话，无论异常是否发生都会执行。') finally 子句通常用作定义任何情况下都会执行的清理行为。 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。 抛出异常 Python 使用 raise 语句抛出一个指定的异常。raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。raise 语法格式如下： raise [Exception [, args [, traceback]]] Example： x = 10 if x &gt; 5: raise Exception('x 不能大于 5。x 的值为: {}'.format(x)) 执行以上代码会触发异常： Traceback (most recent call last): File &quot;test.py&quot;, line 3, in &lt;module&gt; raise Exception('x 不能大于 5。x 的值为: {}'.format(x)) Exception: x 不能大于 5。x 的值为: 10 用户自定义异常 异常类都是直接或间接地继承自 Exception 类。 &gt;&gt;&gt; class MyError(Exception): ... def __init__(self, value): ... self.value = value ... def __str__(self): ... return repr(self.value) ... &gt;&gt;&gt; try: ... raise MyError(2*2) ... except MyError as e: ... print('My exception occurred, value:', e.value) ... My exception occurred, value: 4 &gt;&gt;&gt; raise MyError('oops!') Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? __main__.MyError: 'oops!' 预定义清理行为 with 语句可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法： with open(&quot;myfile.txt&quot;) as f: for line in f: print(line, end=&quot;&quot;) assert 断言 Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。 断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。 语法格式如下： assert expression # expression 值为 True 时，正常执行； # 为 False 时，触发异常 它等价于： if not expression: raise AssertionError assert 后面也可以紧跟参数: assert expression [, arguments] 等价于： if not expression: raise AssertionError(arguments) Example： &gt;&gt;&gt; assert True # 条件为 true 正常执行 &gt;&gt;&gt; assert False # 条件为 false 触发异常 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AssertionError &gt;&gt;&gt; assert 1==1 # 条件为 true 正常执行 &gt;&gt;&gt; assert 1==2 # 条件为 false 触发异常 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AssertionError &gt;&gt;&gt; assert 1==2, '1 不等于 2' Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; AssertionError: 1 不等于 2 # 判断当前系统是否为 Linux，如果不满足条件则直接触发异常，不必执行接下来的代码 import sys assert ('linux' in sys.platform), &quot;该代码只能在 Linux 下执行&quot; # ... 接下来要执行的代码 面向对象 类（Class）：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。继承是模拟 “是一个（is-a）” 关系。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 类定义和类对象 创建类 创建类的语法格式如下： class ClassName(): &lt;statement-1&gt; . . . &lt;statement-N&gt; 创建实例对象 类对象支持两种操作：属性引用和实例化。 在 Python 中，类的实例化类似函数调用方式，其语法格式如下： obj = ClassName([arg1, arg2, ...]) 访问对象属性 类的属性是指在类中定义的变量和方法等。 属性引用使用 obj.name 语法。类对象创建后，类命名空间中所有的命名（如变量、方法等）都是有效属性名。 Example： class MyClass(): var1 = 1 var2 = 2 def method(self): print(&quot;This is my class.&quot;) obj = MyClass() print(obj.var1, obj.var2) print() obj.func() # 输出： # 1 2 # This is my class. __init__() 和self 在类定义中有一个特殊的方法，构造方法 __init__()。如果类定义了 __init__() 方法，那么在类实例化时，会自动调用该方法。 在类定义中，self 代表类的实例，而非类。self 必须存在，且位于其他形参前面。类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，按照惯例它的名称是 self。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数。 Example： class Complex(): &quot;&quot;&quot;复数类&quot;&quot;&quot; def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart def print_complex(self): print('{:f}{:+f}i'.format(self.r, self.i)) x = Complex(3.0, -4.5) # 实例化 print(x.r, x.i) # 输出：3.0 -4.5 x.print_complex() # 输出：3.000000-4.500000i 在 Python 调用 __init__() 来创建实例时，将自动传入实参 self。每个与类相关联的方法调用都自动传递实参 self。 在类的内部使用属性和方法，需要使用 self.attrs 或 self.method()。 修改属性值 通常有两种方法可以修改属性值，一种是直接使用 obj.name 语法修改，另一种是通过方法对属性值进行修改。 Example： class Car(): def __init__(self, make, model, year): &quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot; self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): &quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot; long_name = str(self.year) + ' ' + self.make + ' ' + self.model return long_name.title() def read_odometer(self): &quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot; print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;) def update_odometer(self, mileage): &quot;&quot;&quot; 将里程表读数设置为指定的值 禁止将里程表读数往回调 &quot;&quot;&quot; if mileage &gt;= self.odometer_reading: self.odometer_reading = mileage else: print(&quot;You can't roll back an odometer!&quot;) def increment_odometer(self, miles): &quot;&quot;&quot;将里程表读数增加指定的量&quot;&quot;&quot; self.odometer_reading += miles my_new_car = Car('audi', 'a4', 2016) # 通过方法获取属性 print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() # 输出： # 2016 Audi A4 # This car has 0 miles on it. # 通过方法对属性值进行修改 my_used_car = Car('subaru', 'outback', 2013) print(my_used_car.get_descriptive_name()) my_used_car.update_odometer(23500) my_used_car.read_odometer() my_used_car.increment_odometer(100) my_used_car.read_odometer() # 输出： # 2013 Subaru Outback # This car has 23500 miles on it. # This car has 23600 miles on it. 继承 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。派生类的定义如下所示： class DerivedClassName(BaseClassName): &lt;statement-1&gt; . . . &lt;statement-N&gt; BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。 如果基类定义在另一个模块中，需要使用 . 运算符： class DerivedClassName(modname.BaseClassName): Example： # 类定义 class people: # 定义基本属性 name = '' age = 0 # 定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 # 定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) # 单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): # 调用父类的构函 people.__init__(self,n,a,w) self.grade = g # 覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) s = student('ken',10,60,3) s.speak() 多继承 Python 有限地支持多继承，多继承的类定义如下： class DerivedClassName(Base1, Base2, Base3): &lt;statement-1&gt; . . . &lt;statement-N&gt; 若是父类中有相同的方法名，而在子类使用时未指定，Python 会根据圆括号中父类的顺序从左至右搜索。即方法在子类中未找到时，从左到右查找父类中是否包含方法。 Example： # 接上一个例子 # 另一个类，多重继承之前的准备 class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic)) # 多重继承 class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;) test.speak() # 方法名同，默认调用的是在括号中排前地父类的方法 方法重写 可以在子类中重写其父类的方法： class Parent: # 定义父类 def myMethod(self): print ('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print ('调用子类方法') c = Child() # 子类实例 c.myMethod() # 子类调用重写方法 super(Child,c).myMethod() # 用子类对象调用父类已被覆盖的方法 # 输出： # 调用子类方法 # 调用父类方法 子类继承父类构造函数说明 如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。 子类不重写 __init__，实例化子类时，会自动调用父类定义的 __init__。 Example： class Father(object): def __init__(self, name): self.name = name print (&quot;name: %s&quot; % (self.name)) def getName(self): return 'Father ' + self.name # 重写了 getName 但并没有重写 __init__ class Son(Father): def getName(self): return 'Son ' + self.name if __name__ == '__main__': son = Son('runoob') print(son.getName()) # 输出： # name: runoob # Son runoob 如果重写了__init__ 时，实例化子类，就不会调用父类已经定义的 __init__。 Example： class Father(object): def __init__(self, name): self.name=name print ( &quot;name: %s&quot; %( self.name) ) def getName(self): return 'Father ' + self.name # 重写了 __init__ 和 getName class Son(Father): def __init__(self, name): print ( &quot;hi&quot; ) self.name = name def getName(self): return 'Son '+self.name if __name__=='__main__': son=Son('runoob') print (son.getName()) # 输出： # hi # Son runoob 如果重写了 __init__ 时，要继承父类的构造方法，可以在 __init__ 的定义中使用 super 关键字： super(子类, self).__init__(参数1, 参数2, ....) 另一种写法： 父类名称.__init__(self, 参数1, 参数2, ...) Example： class Father(object): def __init__(self, name): self.name = name print(&quot;name: %s&quot; % (self.name)) def getName(self): return 'Father ' + self.name class Son(Father): def __init__(self, name): super(Son, self).__init__(name) print(&quot;hi&quot;) self.name = name def getName(self): return 'Son ' + self.name if __name__ == '__main__': son=Son('runoob') print (son.getName()) # 输出： # name: runoob # hi # Son runoob 类的私有属性与私有方法 私有属性不能在类的外部被使用或直接访问。使用两个下划线开头，声明该属性为私有： __private_attrs 在类内部的方法中使用私有属性： self.__private_attrs Example： class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter() counter.count() counter.count() print (counter.publicCount) print (counter.__secretCount) # 报错，实例不能访问私有变量 输出结果： 1 2 2 Traceback (most recent call last): File &quot;test.py&quot;, line 16, in &lt;module&gt; print (counter.__secretCount) # 报错，实例不能访问私有变量 AttributeError: 'JustCounter' object has no attribute '__secretCount' 私有方法只能在类的内部调用 ，不能在类的外部调用。使用两个下划线开头，声明该方法为私有方法： def __private_method(self[, ...]): 在类内部的方法中使用私有方法： self.__private_methods([...]) Example： class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print('name : ', self.name) print('url : ', self.__url) def __foo(self): # 私有方法 print('这是私有方法') def foo(self): # 公共方法 print('这是公共方法') self.__foo() x = Site('菜鸟教程', 'www.runoob.com') x.who() # 正常输出 x.foo() # 正常输出 x.__foo() # 报错 输出结果： name : 菜鸟教程 url : www.runoob.com 这是公共方法 这是私有方法 Traceback (most recent call last): File &quot;c:/Users/27120/Documents/MyDocuments/Code/test.py&quot;, line 20, in &lt;module&gt; x.__foo() # 报错，外部不能调用私有方法 AttributeError: 'Site' object has no attribute '__foo' 类的专有方法 方法 描述 __init__ 构造函数，在生成对象时调用 __del__ 析构函数，释放对象时使用 __repr__ 打印，转换 __setitem__ 按照索引赋值 __getitem__ 按照索引获取值 __len__ 获得长度 __cmp__ 比较运算 __call__ 函数调用 __add__ 加运算 __sub__ 减运算 __mul__ 乘运算 __truediv__ 除运算 __mod__ 求余运算 __pow__ 乘方 运算符重载 可以对类的专有方法进行重载： class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self, other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10) v2 = Vector(5,-2) print (v1 + v2) # 输出： # Vector(7,8) 命名空间 命名空间（Namespace）是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。 命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 一般有三种命名空间： 内置名称（built-in names）：Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。 全局名称（global names）：模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。 局部名称（local names）：函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量（类中定义的也是）。 命名空间查找顺序：局部的命名空间 →\\rightarrow→ 全局命名空间 →\\rightarrow→ 内置命名空间。 如果找不到变量，将放弃查找并引发一个 NameError 异常： NameError: name 'runoob' is not defined 命名空间的生命周期：命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，无法从外部命名空间访问内部命名空间的对象。 作用域 作用域就是一个 Python 程序可以直接访问命名空间的正文区域。变量的访问权限取决于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有 4 种，分别是： L（Local）：最内层，包含局部变量。如一个函数/方法内部。 E（Enclosing）：包含了非局部（non-local）也非全局（non-global）的变量。 如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 non-local。 G（Global）：当前脚本的最外层。如当前模块的全局变量。 B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。 作用域查找顺序： L →\\rightarrow→ E →\\rightarrow→ G →\\rightarrow→ B。 g_count = 0 # 全局作用域 def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量： &gt;&gt;&gt; import builtins &gt;&gt;&gt; dir(builtins) Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else、try/except、for/while等）是不会引入新的作用域的： 全局变量和局部变量 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。 global和nonlocal global 和 nonlocal 的作用是让内部作用域修改外部作用域变量。 global —— 修改全局变量： num = 1 def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num) fun1() print(num) # 输出： # 1 # 123 # 123 nonlocal —— 修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量： def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num) outer() # 输出： # 100 # 100 不使用 global 或 nonlocal 修改外部作用域变量： a = 10 def test(): a = a + 1 print(a) test() 结果： Traceback (most recent call last): File &quot;test.py&quot;, line 7, in &lt;module&gt; test() File &quot;test.py&quot;, line 5, in test a = a + 1 UnboundLocalError: local variable 'a' referenced before assignment 局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。 for x in range(1,5) if x &gt; 2 for y in range(1,4) if y &lt; 3 x*y ","link":"https://linna-cy.github.io/old-blog/Python 基础/"},{"title":"Python 进阶 — 正则表达式篇","content":"正则表达式语法 —— Python 正则表达式是一个特殊的字符序列，能方便地检查一个字符串是否与某种模式匹配。 正则表达式可以拼接。 正则表达式可以包含普通或者特殊字符。 绝大部分普通字符，是最简单的正则表达式。它们就匹配自身。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。 重复修饰符（*、+、?、{m,n}, 等）不能直接嵌套。避免了非贪婪后缀 ? 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 特殊字符 序列 说明 . （点）在默认模式，匹配除了换行的任意字符。 如果指定了标签 DOTALL，它将匹配包括换行符的任意字符。 \\ 转义特殊字符（允许你匹配 '*'、'?'，或者其他正则表达式中使用的特殊字符），或者表示一个特殊序列。 […] 用于表示一个字符集合。 字符可以单独列出：[abc]，匹配 'a'、'b'、'c'。可以表示字符范围，通过用 '-' 将两个字符连起来：[a-z] 将匹配任何小写 ASCII 字符； 可以指定多个范围：[a-zA-Z] 将匹配所有英文字符。 如果 - 进行了转义 （比如 [a-z]）或者它的位置在首位或者末尾（如 [-a] 或 [a-]），它就只表示普通字符 '-'。 特殊字符在集合中，失去它的特殊含义：[(+*)] 只会匹配这几个文法字符 '('、'+'、'*' 或 ')'。 字符类如 \\w 或者 \\S 在集合内可以接受，它们可以匹配的字符由 ASCII 或者 LOCALE 模式决定。 不在集合范围内的字符可以通过取反（'^' 作为首字符）来进行匹配：[^a] 将匹配除了 'a' 之外的所有字符。 '^' 如果不在集合首位，就没有特殊含义。在集合内要匹配一个字符 ']'，有两种方法，要么将它进行转义，要么就把它放到集合首位（如 [()[]{}] 和 []()[{}]）。 嵌套集合和集合操作支持可能在未来添加。如果有多以的情况发生，将会抛出 FutureWarning。 | A|B， A 和 B 可以是任意正则表达式，创建一个正则表达式，匹配 A 或者 B。任意个正则表达式可以用 '|' 连接。它可以在集合或组合内使用。 '|' 操作符绝不贪婪：扫描目标字符串时，由 '|' 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。即，一旦 A 匹配成功， B 就不再进行匹配，即便它能产生一个更好的匹配。 如果要匹配 '|' 字符，使用 |， 或者把它包含在字符集里 [|]。 (…) （组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。 定位符 定位符用来描述字符串或单词的边界。 序列 说明 ^ （插入符号）匹配字符串的开头， 并且在 MULTILINE 模式也匹配换行后的首个符号。 $ 匹配字符串尾或者在字符串尾的换行符的前一个字符，在 MULTILINE 模式下也会匹配换行符之前的文本。在 'foo1\\nfoo2\\n' 中搜索 foo.$，通常匹配 'foo2'，但在 MULTILINE 模式下可以匹配到 'foo1'。 在 'foo\\n' 中搜索 $ 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。 \\A 只匹配字符串的开始。相当于默认模式下的 ^。 \\b 匹配一个单词边界。即，匹配空字符串，但只在单词开始或结尾的位置。通常 \\b 定义为 \\w 和 \\W 字符之间，或者 \\w 和字符串开始/结尾的边界。如果使用了 LOCALE 标志，则词的边界由当前语言区域设置。 在字符集合内表示退格（如 [\\b]）。 \\B 非单词边界匹配。即，匹配除了单词边界外的任何其他位置。\\B 是 \\b 的取非。如果使用了 LOCALE 标志，则词的边界由当前语言区域设置。 \\Z 只匹配字符串尾。 重复修饰符（限定符） {m} 对其之前的正则式指定匹配 m 个重复；少于 m 的话就会导致匹配失败。 贪婪修饰符： * 对它前面的正则式匹配 0 到任意次重复， 尽量多地匹配字符串。 等价于：{0,}。 + 对它前面的子表达式匹配 1 到任意次重复， 尽量多地匹配字符串。 等价于：{1,}。 ? 对它前面的子表达式匹配 0 到 1 次重复， 尽量多地匹配字符串。 等价于：{0,1}。 {m,} 对它前面的子表达式进行 m 到任意次重复， 尽量多地匹配字符串。 {m,n}（中间不要有空白字符） 对它前面的子表达式进行 m 到 n 次匹配，在 m 和 n 之间取尽量多。 非贪婪修饰符： *?、+?、??、{m,}?、{m,n}?： 在修饰符之后添加 ? 将使样式以非贪婪方式，或者 :dfn: 最小方式进行匹配； 尽量少的字符将会被匹配。 扩展标记法 (?…)``'?' 仅跟随 '(' 并无含义。'?' 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； (?P&lt;name&gt;...) 是唯一的例外。 (?aiLmsux) 在 (? 后带 'a'、 'i'、'L'、'm'、's'、'u'、'x' 中的一个或多个。(?aimsx) 将会匹配空字符串。 这些字符代表内联标记（与 re 模块中的 RegexFlag 标志常量对应）。 'a' —— re.A 模式； 'i' —— re.I 模式； 'L' —— re.L 模式； 'm' —— re.M 模式； 's' —— re.S 模式； 'u' —— re.U 模式； 'x' —— re.X 模式。 (?:…) 正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串不能在执行匹配后被获取或是之后在模式中被引用。 (?aiLmsux-imsx:…)``'?' 后面 '-' 前面带 'a'、 'i'、'L'、'm'、's'、'u'、'x' 中的 0 个或多个。'-' 后面 ':' 前面带 'i'、'm'、's'、'x' 中的一到多个。表示设置或者去除（'-' 后指定去除的标记）相应标记。 与 (?aiLmsux) 一样，这些字符分别代表了不同的内联标记。 'a'、'L' 和 'u' 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 '-' 。 当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。Python3.7 接受 'a'、'L' 和 'u' 存在于一个组合。 这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。 (?P&lt;name&gt;…) （命名组合）类似正则组合，但是匹配到的子串组在外部可以通过定义的 name 来获取的（也可以通过数字获取）。组合名必须是有效的 Python 标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。 命名组合可以在三种上下文中引用： 引用组合 &quot;quote&quot; 的上下文 引用方法 在正则式自身内 (?P=quote) 或 \\1 处理匹配对象 m m.group('quote') 或 m.end('quote')（等） 传递到 re.sub() 里的 repl 参数中 \\g&lt;quote&gt; 或 \\g&lt;1&gt; 或 \\1 (?P=name) 反向引用一个命名组合；它匹配前面名为 name 的命名组中匹配到的串同样的字串（如上所示）。 (?#…) 注释，里面的内容会被忽略。 (?=…) lookahead assertion，匹配 … 的内容，但是并不消费样式的内容。如，abc(?=def) 当 'abc' 后面是 'def' 的时候，才匹配 'abc'。 (?!…) negative lookahead assertion（前视取反），匹配 … 不符合的情况。如，abc(?!def) 当 'abc' 后面不是 'def' 的时候，才匹配 'abc'。 (?&lt;=…) :dfn:positive lookbehind assertion（正向后视断定），匹配字符串的当前位置，它的前面匹配 … 的内容到当前位置。如，(?&lt;=abc)def 当 'def' 前面是 'abc' 时匹配 'def'，该样式是从 'd' 开始往回搜索的。 包含的匹配样式必须是定长的（ abc 或 a|b 是允许的，但是 a* 和 a{3,4} 不可以）。 (?&lt;!…) negative lookbehind assertion （后视断定取非），匹配当前位置之前不是 … 的样式。 包含的样式匹配必须是定长的。 由 negative lookbehind assertion 开始的样式可以从字符串搜索开始的位置进行匹配。 (?(id/name)yes-pattern|no-pattern) 如果给定的 id 或 name 存在，将会尝试匹配 yes-pattern ，否则就尝试匹配 no-pattern（no-pattern 可选，可以被忽略）。 \\+普通字符 \\ + （ASCII 数字或字母）： 序列 说明 \\number 匹配数字代表的组合。每个正则表达式中的括号是一个组合，组合从 1 开始编号。 如：(.+) \\1 匹配 'the the' 或者 '55 55'。 这个特殊序列只能用于匹配前面 99 个组合。 如果 number 的第一个数位是 0， 或者 number 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。 \\A 只匹配字符串开始。 \\b （单词边界定位符）匹配空字符串，但只在单词开始或结尾的位置。 在字符集合内表示退格（如 [\\b]）。 \\B （非单词边界定位符）匹配空字符串，但不能在词的开头或者结尾。 \\d 对于 Unicode（str）样式： 匹配任何 Unicode 十进制数（就是在 Unicode 字符目录 [Nd] 里的字符，包括了 [0-9] ，和很多其他的数字字符）。如果设置了 ASCII 标志，就只匹配 [0-9] 。 对于8位（bytes）样式： 匹配任何十进制数（[0-9]）。 \\D 匹配任何非十进制数字的字符（\\d 取非）。 如果设置了 ASCII 标志，就相当于 [^0-9] 。 \\s 对于 Unicode（str）样式： 匹配任何 Unicode 空白字符（包括 [ \\t\\n\\r\\f\\v] ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 ASCII 被设置，就只匹配 [ \\t\\n\\r\\f\\v] 。对于8位（bytes）样式： 匹配ASCII中的空白字符（[ \\t\\n\\r\\f\\v]） 。 \\S 匹配任何非空白字符（\\s 取非）。 如果设置了 ASCII 标志，就相当于 [^ \\t\\n\\r\\f\\v] 。 \\w 对于 Unicode（str）样式： 匹配 Unicode 词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 ASCII 标志，就只匹配 [a-zA-Z0-9_] 。对于8位（bytes）样式： 匹配 ASCII 字符中的数字和字母和下划线，就是 [a-zA-Z0-9_] 。如果设置了 LOCALE 标记，就匹配当前语言区域的数字和字母和下划线。 \\W 匹配非单词字符的字符（与 \\w 正相反）。 如果使用了 ASCII 标志，就等价于 [^a-zA-Z0-9_]。如果使用了 LOCALE 标志，则会匹配当前区域中既非字母数字也非下划线的字符。 \\Z 只匹配字符串尾。如果普通字符不是 ASCII 数位或者 ASCII 字母，那么正则样式将匹配第二个字符（如，\\$ 匹配字符 '$'）。 绝大部分 Python 的标准转义字符也被正则表达式分析器支持： \\a \\b \\f \\n \\N \\r \\t \\u \\U \\v \\x \\\\ '\\u'、'\\U' 和 '\\N' 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。 八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。 re 模块 Python 的 re 模块提供了与 Perl 语言类似的正则表达式匹配操作。 函数 匹配一项 在 re 模块中，有三个函数用于查找并返回一个匹配对象： re.match() —— 返回一个从字符串的起始位置匹配的对象。 re.search() —— 返回整个字符串中任意位置第一个成功的匹配。 re.fullmatch() —— 整个字符串与正则表达式完全匹配。 match() 函数 re.match() 尝试从字符串的起始位置匹配一个模式，其语法如下： re.match(pattern, string, flags=0) 参数： 参数 描述 pattern 匹配的正则表达式。 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式。 返回值： 匹配成功，re.match() 函数返回一个匹配对象（Match）；否则返回 None。 Example： &gt;&gt;&gt; import re &gt;&gt;&gt; re.match('abc', 'abcdefg') # 在起始位置匹配 &lt;_sre.SRE_Match object; span=(0, 3), match='abc'&gt; &gt;&gt;&gt; re.match('efg', 'abcdefg') # 不在起始位置匹配 None search() 函数 re.search() 扫描整个字符串并返回第一个成功的匹配，其语法如下： re.search(pattern, string, flags=0) 参数用法与 re.match() 类似。匹配成功，re.search() 方法返回一个匹配对象（Match）；否则返回 None。 Example： &gt;&gt;&gt; import re &gt;&gt;&gt; re.search('abc', 'abcdefg') # 在起始位置匹配 &lt;_sre.SRE_Match object; span=(0, 3), match='abc'&gt; &gt;&gt;&gt; re.search('efg', 'abcdefg') # 不在起始位置匹配 &lt;_sre.SRE_Match object; span=(4, 7), match='efg'&gt; fullmatch() 函数 fullmatch() 将整个字符串与正则表达式匹配，其语法如下： re.fullmatch(pattern, string, flags=0) 参数用法与 re.match() 类似。如果 string 与 pattern 完全匹配，那么返回一个匹配对象（Match）；否则返回 None。 Example： &gt;&gt;&gt; import re &gt;&gt;&gt; re.fullmatch('abc', 'abcdefg') # 在起始位置匹配 None &gt;&gt;&gt; re.fullmatch('abcdefg', 'abcdefg') # 匹配整个字符串 &lt;_sre.SRE_Match object; span=(0, 7), match='abcdefg'&gt; 匹配多项 有两个函数用于查找并返回匹配的多个匹配对象： re.findall —— 在字符串的任意位置匹配，并返回一个包含了所有匹配对象的列表。 re.finditer —— 在字符串的任意位置匹配，并返回一个包含了所有匹配对象的迭代器。 finall() finall() 在字符串中找到正则表达式所匹配的所有子串，其语法如下： re.findall(pattern, string, flags=0) 参数： 参数 描述 pattern 匹配的正则表达式。 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式。 返回值： 返回一个列表，包含了所有匹配对象；如果没有任何匹配项，则返回空列表。 finditer() 与 finall() 类似，其语法如下： re.finditer(pattern, string, flags=0) 该函数返回的是迭代器。 如果可能存在大量的匹配项的话，建议使用 finditer()。 split() 正则分割 re.split() 按照能够匹配的子串对字符串进行分割，其语法如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数： 参数 描述 pattern 匹配的正则表达式。 string 要匹配的字符串。 maxsplit 最大分割次数，maxsplit=1 分割一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式。 返回值： 返回一个用 patterm 模式匹配的字符分割的字符串列表。如果查找不到任何匹配，则返回一个仅包含 string 的列表。 str 模块下也有一个 split() 函数，但它并不支持正则分割。 替换 有两个替换函数：re.sub() 和 re.subn()。 re.sub(pattern, repl, string, count=0, flags=0) re.subn(pattern, repl, string, count=0, flags=0) 参数： 参数 描述 pattern 匹配的正则表达式。 repl 替换内容，可以是字符串，也可以是函数。如果 repl 为函数，只能有一个匹配对象作为参数。 string 要匹配的字符串。 count 最大替换次数。 flags 标志位，用于控制正则表达式的匹配方式。 repl 替换掉 string 中被 pattern 匹配的字符。 返回值： re.sub() 返回一个替换后的字符串。如果 string 中没有任何匹配项，则返回 string。 re.subn() 返回一个元组，包含了替换后的字符串和替换次数：(str, n)。 excape() 转义函数 re.exvape() 函数可以转义参数 pattern 中的特殊字符。 re.exvape(pattern) Example： &gt;&gt;&gt; print(re.escape('http://www.python.org')) http://www\\.python\\.org Python3.3：_ 不再被转义。 Python3.7：只有在正则表达式中具有特殊含义的字符才会被转义。 因此， !、&quot;、%、'、,、/、:、;&lt;'、=&gt;'、@ 和 ` 将不再会被转义。 使用 re.exvape() 函数很容易出现转义错误的问题，所以并不建议使用它转义。 purge() 清除正则表达式缓存 re.purge() 用于清除正则表达式的缓存。它没有参数，没有返回值。 RegexFlag 标志常量 re.ASCII： 简写：re.A。 让 \\w, \\W, \\b, \\B, \\d, \\D, \\s 和 \\S 只匹配 ASCII 编码支持的字符，而不是 Unicode。这只对 Unicode 样式（Python3 默认）有效，会被 byte 样式忽略。 Example： &gt;&gt;&gt; re.search(r'\\w+', '中文字符和ASCII', re.A) &lt;_sre.SRE_Match object; span=(5, 10), match='ASCII'&gt; 对应内联标记：(?a) 。 re.DEBUG： 显示编译时的 debug 信息，没有内联标记。 Example： &gt;&gt;&gt; re.search(r'.*', '显示debug信息', re.DEBUG) MAX_REPEAT 0 MAXREPEAT ANY None &lt;_sre.SRE_Match object; span=(0, 9), match='显示debug信息'&gt; 对应内联标记：(?i) 。 re.IGNORECASE： 简写：re.I。 进行忽略大小写匹配。 Example： &gt;&gt;&gt; re.findall(r'[a-z]', '大写字母：ABCDE 小写字母：abcde', re.I) ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e'] re.LOCALE： 简写：re.L。 语言依赖，由当前语言区域决定 \\w, \\W, \\b, \\B 和大小写敏感匹配。这个标记只能对 byte 样式有效。这个标记官方并不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对 8 位字节有效。 对应内联标记：(?L) 。 re.MULTILINE： 简写：re.M。 多行模式，样式字符 '^' 匹配每一个行开始（字符串的开始和换行符后紧跟的符号）；样式字符 '$' 匹配每一个行结尾（字符串结尾和换行符前面的符号）。 默认情况下不支持换行符特性，'^' 匹配字符串开始，'$' 匹配字符串结尾。 Example： &gt;&gt;&gt; re.findall(r'^.*$', '第1行\\n第2行\\n第3行', re.M) ['第1行', '第2行', '第3行'] 对应内联标记：(?m)。 re.DOTALL： 简写：re.S。 让 '.' 特殊字符匹配全部字符，包括换行符。 默认情况下，'.' 仅匹配除了换行符的其他任意字符。 对应内联标记：(?s) 。 re.VERBOSE： 简写：re.X。 冗长模式，允许在正则表达式中换行和添加注释。 该模式下空白符号会被忽略，除非在一个字符集合中或者由反斜杠转义，或者在 *?、(?:、(?P&lt;…&gt; 分组之内。 当一个行内有 # 不在字符集和转义序列，那么它之后的所有字符都是注释。 Example： &gt;&gt;&gt; re.search(r'''\\d + # the integral part ... \\. # the decimal point ... \\d * # some fractional digits''', ... '圆周率：3.14', re.X) &lt;_sre.SRE_Match object; span=(4, 8), match='3.14'&gt; 对应内联标记：(?x) 。 re.UNICODE： 简写：re.U。 匹配 Unicode 编码支持的字符，是 Python3 默认的字符串模式。虽然保留着，但对 Python3 来说是个冗余的常量。 re.TEMPLATE： 简写：re.T。 re 模块的源码是这样描述该常量的（官方文档中并没有具体的描述）： TEMPLATE = T = sre_compile.SRE_FLAG_TEMPLATE # disable backtracking 正则对象 Pattern 使用 compile() 和 template() 可以将正则表达式编译为正则表达式对象（Pattern，正则对象）。 re.compile() 的语法如下： re.compile(pattern, flags=0) 参数 描述 pattern 要转化为正则对象的正则表达式。 flags 标志位，用于控制正则表达式的匹配方式。 可以通过位的 OR（'|'）操作来结合多个模式。 Example： &gt;&gt;&gt; pattern_obj = re.compile(r'abc') &gt;&gt;&gt; pattern_obj.search('abcdefg') &lt;_sre.SRE_Match object; span=(0, 3), match='abc'&gt; 使用正则对象和函数： 正则对象和函数是一致的。 模块的底层实现中，re.compile() 与其他 re 函数内部调用的是同一个函数 re._compile()。 如果需要多次使用某个正则表达式的话，使用 re.compile() 和保存这个正则对象以便复用，可以让程序更加高效。通过 re.compile() 编译后的样式，和模块级的函数会被缓存。 正则对象方法 正则对象支持以下方法： 方法 说明 Pattern.search(string[, pos[, endpos]]) 扫描整个 string 寻找第一个匹配的位置， 并返回一个相应的匹配对象（Match）。如果没有匹配，就返回 None。pos —— 字符串中开始搜索的位置索引，默认为 0，它不完全等价于字符串切片。^ 样式字符匹配行开头，但不会匹配索引规定开始的位置。endpos —— 字符串搜索的结束。只有从 pos 到 endpos - 1 的字符会被匹配。如果 endpos 小于 pos，就不会有匹配产生。pattern_obj.search(string, 0, 50)等价于pattern_obj.search(string[:50], 0)`。 Pattern.match(string[, pos[, endpos]]) 如果 string 的开始位置能够找到这个正则样式 Pattern 的任意个匹配，就返回一个相应的匹配对象（Match）。如果不匹配，就返回 None。可选参数 pos 和 endpos 指定 string 的查找范围，与 Pattern.search() 含义相同。 Pattern.fullmatch(string[, pos[, endpos]]) 如果整个 string 匹配这个正则表达式，就返回一个相应的匹配对象（Match）。如果不匹配，就返回 None。可选参数 pos 和 endpos 指定 string 的查找范围。 Pattern.findall(string[, pos[, endpos]]) 类似 re.findall()，使用了编译后样式，在 string 中找到 Pattern 所匹配的所有子串，以列表形式返回所有匹配项。可选参数 pos 和 endpos 指定 string 的查找范围。 Pattern.finditer(string[, pos[, endpos]]) 类似函数 finiter() ， 使用了编译后样式，在 string 中找到 Pattern 所匹配的所有子串，以迭代器形式返回所有匹配项。可选参数 pos 和 endpos 指定 string 的查找范围。 Pattern.split(string, maxsplit=0) 等价于 split() 函数，使用了编译后的样式，按照能够匹配的子串对字符串进行分割。 maxsplit —— 最大分割次数。 Pattern.sub(repl, string, count=0) 等价于 sub() 函数，使用了编译后的样式，使用 repl 替换掉 string 中被 Pattern 匹配的字符。count —— 最大替换次数。返回一个替换后的字符串。如果 string 中没有任何匹配项，则返回 string。 Pattern.subn(repl, string, count=0) 等价于 subn() 函数，使用了编译后的样式，使用 repl 替换掉 string 中被 Pattern 匹配的字符。count —— 最大替换次数。返回一个元组，包含了替换后的字符串和替换次数。 正则对象属性 属性 说明 Pattern.flags 正则匹配标记。可以传递给 compile() 的参数。任何 (?…) 内联标记，隐性标记（re.U）的结合。 Pattern.groups 捕获到的模式串中组的数量。 Pattern.groupindex 映射由 (?P&lt;id&gt;) 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。 Pattern.pattern 编译对象的原始样式字符串。 匹配对象 匹配对象（Match）是调用 re 模块中的函数或方法匹配后返回的对象。 匹配对象总是有一个布尔值 True。如果没有匹配的话 re.match() 和 re.search() 返回 None。可以简单的用 if 语句来判断是否匹配： &gt;&gt;&gt; if re.search(r'a', 'abc'): ... print(True) ... True &gt;&gt;&gt; if re.search(r'd', 'abc'): ... print(True) ... else: ... print(False) ... False 匹配对象方法 匹配对象支持以下方法： ： 对 template 进行反斜杠（'\\'）转义替换并且返回。 ： 返回一个或者多个匹配的子组。 如果只有一个参数，结果就是一个字符串； 如果有多个参数，结果就是一个元组（每个参数对应一个项）； 如果没有参数，group1 默认为 0（整个匹配都被返回）。 如果一个 groupN 参数值为 0，相应的返回值就是整个匹配字符串； 如果它是一个范围 [1..99]，结果就是相应的括号组字符串。 如果一个组号是负数，或者大于样式中定义的组数，会抛出一个 IndexError。 Example： &gt;&gt;&gt; m = re.match(r'(\\w+) (\\w+)', 'Python PHP Java C++') &gt;&gt;&gt; m.group() # 返回整个匹配 'Python PHP' &gt;&gt;&gt; m.group(1) # 返回第一个括号组 'Python' &gt;&gt;&gt; m.group(2) # 返回第二个括号组 'PHP' &gt;&gt;&gt; m.group(1, 2) # 多个参数返回一个元组 ('Python', 'PHP') 如果正则表达式使用了 (?P&lt;name&gt;…) 语法， groupN 参数可以是索引值，也可以是组名。 &gt;&gt;&gt; m = re.match(r'(?P&lt;name_1&gt;\\w+) (?P&lt;name_2&gt;\\w+)', 'Python PHP') &gt;&gt;&gt; m.group('name_1', 'name_2') ('Python', 'PHP') &gt;&gt;&gt; m.group(1, 2) ('Python', 'PHP') 如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。 &gt;&gt;&gt; m = re.match(r'(..)+', 'a1b2c3') &gt;&gt;&gt; m.group(1) 'c3' ： Python3.6 新增功能。 等价于 m.group(g)，允许更方便地引用一个匹配。 &gt;&gt;&gt; m = re.match(r'(?P&lt;name_1&gt;\\w+) (?P&lt;name_2&gt;\\w+)', 'Python PHP') &gt;&gt;&gt; m[0] 'Python PHP' &gt;&gt;&gt; m[1] 'Python' &gt;&gt;&gt; m[2] 'PHP' ： 返回一个元组，包含所有匹配的子组，在样式中出现的从 1 到任意多的组合。default 参数用于不参与匹配的情况，默认为 None。 Example： 使小数部分可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 None ，除非指定了 default 参数。 &gt;&gt;&gt; m = re.match(r'(\\d+)\\.(\\d+)', '3.14') &gt;&gt;&gt; m.groups() ('3', '14') &gt;&gt;&gt; m = re.match(r&quot;(\\d+)\\.?(\\d+)?&quot;, '3') &gt;&gt;&gt; m.groups() # 第二个子组默认为 None ('3', None) &gt;&gt;&gt; m.groups('0') # 第二个子组被设置为指定的默认值 '0' ('3', '0') ： 返回一个字典，包含了所有的命名子组。key 就是组名。 default 参数用于不参与匹配的组合；默认为 None。 Example： &gt;&gt;&gt; m = re.match(r'(?P&lt;name_1&gt;\\w+) (?P&lt;name_2&gt;\\w+)', 'Python PHP') &gt;&gt;&gt; m.groupdict() {'name_1': 'Python', 'name_2': 'PHP'} ： 返回 group 匹配到的字串在原字符串的开始和结束索引。group 默认为 0（意思是整个匹配的子串）。如果 group 存在，但未产生匹配，就返回 -1 。 从 email 地址中移除掉 remove_this： &gt;&gt;&gt; email = &quot;tony@tiremove_thisger.net&quot; &gt;&gt;&gt; m = re.search(&quot;remove_this&quot;, email) &gt;&gt;&gt; email[:m.start()] + email[m.end():] 'tony@tiger.net' ： 对于一个匹配 m ， 返回一个二元组 (m.start(group), m.end(group)) 。 如果 group 没有在这个匹配中，就返回 (-1, -1) 。 group 默认为 0，就是整个匹配。 ","link":"https://linna-cy.github.io/old-blog/Python 进阶 — 正则表达式篇/"},{"title":"vbs 后台运行 bat","content":"假设有三个 bat 程序需要后台运行（称为 A.bat、B.bat、C.bat）： Set ws = CreateObject(&quot;Wscript.Shell&quot;) ws.run &quot;cmd /c A.bat&quot;,0 ws.run &quot;cmd /c B.bat&quot;,0 ws.run &quot;cmd /c C.bat&quot;,0 ","link":"https://linna-cy.github.io/old-blog/vbs 后台运行 bat/"},{"title":"经典排序算法","content":"冒泡排序 冒泡排序（Bubble Sort）是一种简单直观的排序算法。 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 时间复杂度：O(n2)O(n^2)O(n2) 算法步骤 假设一个序列长度为n，m（m≤n）是已排序完成的在末尾的数。 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。对比结束后，最后的元素会是最大的数。 对接下来n-m个未排序的数重复步骤1和2，直到没有任何一对数字需要比较。 第一趟对序列中所有n个数进行比对，第二趟对序列中n-1个未排序完成的数进行比对，以此类推。每次比对的数为n-m。 动画演示： 代码实现 Python实现 def bubbleSort(arr): for i in range(len(arr)-1): for j in range(len(arr)-1-i): if arr[j] &gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] bubbleSort(arr) print(arr) C实现 #include &lt;stdio.h&gt; void bubbleSort(int arr[], int len) { for (int i = 0; i &lt; len - 1; i++) for (int j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) { int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bubbleSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 优化算法 有序标志 冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 Python实现： def bubbleSort(arr): for i in range(len(arr)-1): # 有序flag，初始为True isSorted = True for j in range(len(arr)-1-i): if arr[j] &gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] # 发生交换，序列定为无序 isSorted = False # 序列有序，停止循环 if isSorted: break return arr if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] bubbleSort(arr) print(arr) C实现： #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; void bubbleSort(int arr[], int len) { for (int i = 0; i &lt; len - 1; i++) { // 有序flag，初始为True bool isSorted = true; for (int j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) { arr[j] = arr[j] ^ arr[j+1]; arr[j+1] = arr[j] ^ arr[j+1]; arr[j] = arr[j] ^ arr[j+1]; // 发生交换，序列定为无序 isSorted = false; } // 序列有序，停止循环 if (isSorted) break; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bubbleSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 数列有序区 通常，有序区的长度和排序的轮数是相等的。如，第一轮排序后的有序区长度是1，第二轮排序后是2 …… 但实际上，数列的有序区长度可能会大于这个长度，并且每轮增加的有序区长度也不一定仅为1。 该优化算法解决了这个问题，通过在每一轮排序的最后，记录下最后一次元素交换的位置（该位置也就是无序数列的边界，再往后就是有序区），而每轮的交换只要交换到无序区边界。 Python实现： def bubbleSort(arr): # 无序数列的边界 sortBorder = len(arr) - 1 for i in range(len(arr)-1): # 有序flag，初始为True isSorted = True # 每次仅需交换到无序区边界 for j in range(sortBorder): if arr[j] &gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] # 把无序数列的边界更新为最后一次交换元素的位置 sortBorder = j # 发生交换，序列定为无序 isSorted = False # 序列有序，停止循环 if isSorted: break return arr if __name__ == '__main__': arr = [ 22, 5, 50, 3, 32, 37, 34, 35, 9, 55, 64, 70, 82, 89 ] bubbleSort(arr) print(arr) C实现： #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; void bubbleSort(int arr[], int len) { int sortBorder = len - 1; for (int i = 0; i &lt; len - 1; i++) { // 有序flag，初始为True bool isSorted = true; for (int j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) { arr[j] = arr[j] ^ arr[j+1]; arr[j+1] = arr[j] ^ arr[j+1]; arr[j] = arr[j] ^ arr[j+1]; // 把无序数列的边界更新为最后一次交换元素的位置 sortBorder = j; // 发生交换，序列定为无序 isSorted = false; } // 序列有序，停止循环 if (isSorted) break; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bubbleSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 选择排序 选择排序（Selection Sort）是一种简单直观的排序算法，无论什么数据进去都是 O(n²)O(n²)O(n²) 的时间复杂度。 算法步骤 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复步骤2，直到所有元素均排序完毕。 动画演示： 代码实现 Python实现 def selectionSort(arr): for i in range(len(arr) - 1): # 记录最小数的索引 minIndex = i for j in range(i + 1, len(arr)): if arr[j] &lt; arr[minIndex]: minIndex = j # i 不是最小数时，将 i 和最小数进行交换 if i != minIndex: arr[i], arr[minIndex] = arr[minIndex], arr[i] return arr if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] arr = selectionSort(arr) print(arr) C实现 #include &lt;stdio.h&gt; void selectionSort(int arr[], int len) { for (int i = 0 ; i &lt; len - 1 ; i++) { int min = i; for (int j = i + 1; j &lt; len; j++) // 走访未排序的元素 // 找到最小值 if (arr[j] &lt; arr[min]) min = j; // i 不是最小数时，将 i 和最小数进行交换 if (i != min) { int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; } } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); selectionSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 插入排序 插入排序（Insertion Sort）是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序的有一种优化算法，叫做拆半插入。 算法步骤 假设序列的长度为n，其待排序序列第一个元素的位置为m（1≤m≤n，元素位置从0开始）。 将元素m与已排序序列中的每个元素进行比较。如果已排序元素比元素m大（小），将其往后移，直到前面没有比元素m大（小）的元素（或前面已经没有元素）。将元素m插入。 如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。 从头到尾依次扫描未排序序列，直到没有未排序元素。 动画演示： 代码实现 Python实现 def insertionSort(arr): for i in range(len(arr) - 1): preIndex = i current = arr[i + 1] # 找出要插入的位置 while preIndex &gt;= 0 and arr[preIndex] &gt; current: # 将比current大的元素往后移 arr[preIndex + 1] = arr[preIndex] preIndex -= 1 # 将current插入到适当的位置 arr[preIndex + 1] = current return arr if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] insertionSort(arr) print(arr) C实现 #include &lt;stdio.h&gt; void insertionSort(int arr[], int len) { for (int i = 0 ; i &lt; len - 1 ; i++) { int current = arr[i + 1]; int j = i; while (j &gt;= 0 &amp;&amp; arr[j] &gt; current) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = current; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); insertionSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 希尔排序 算法步骤 希尔排序（Shell Sort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 希尔排序的基本思想是：先将整个待排序的增量序列根据增量分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法步骤 选择一个增量序列t1,t2,...,tkt_1,t_2,...,t_kt1​,t2​,...,tk​，其中ti&gt;tj,tk=1t_i &gt; t_j,t_k = 1ti​&gt;tj​,tk​=1； 按增量序列个数kkk，对序列进行kkk趟排序； 每趟排序，根据对应的增量tit_iti​，将待排序列分割成若干长度为mmm的子序列，分别对各子表进行直接插入排序。仅增量因子为111时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动画演示： 详细过程（引用自博客：一个很懒的人）： 代码实现 Python实现 def shellSort(arr): # 将增量d初始化为len(arr)//2 d = len(arr) // 2 while d &gt; 0: # 分别用插入排序排序每个以d为增量的分组 for i in range(d, len(arr)): tmp = arr[i] j = i - d while j &gt;= 0 and tmp &lt; arr[j]: arr[j + d] = arr[j] j -= d arr[j + d] = tmp # 每次将增量d缩小1/2 d //= 2 return arr if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] shellSort(arr) print(arr) C实现 #include &lt;stdio.h&gt; void shellSort(int arr[], int len) { // 将增量d初始化为len/2，每次将增量d缩小1/2 for (int d = len &gt;&gt; 1; d &gt; 0; d &gt;&gt;= 1) { // 分别用插入排序排序每个以d为增量的分组 for (int i = d; i &lt; len; i++) { int tmp = arr[i]; int j; for (j = i - d; j &gt;= 0 &amp;&amp; tmp &lt; arr[j]; j -= d) arr[j + d] = arr[j]; arr[j + d] = tmp; } } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); shellSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归； 自下而上的迭代。 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。 动画演示： 图片演示： 递归演示： 合并演示： 代码实现 Python 实现 def mergeSort(arr): # 结束递归 if(len(arr) &lt; 2): return arr # 计算中间位置下标 middle = len(arr) // 2 # 将序列切分为两半 left, right = arr[:middle], arr[middle:] # 进行归并排序 return merge(mergeSort(left), mergeSort(right)) def merge(left, right): result = [] while left and right: # 将较小的元素放在前面 if left[0] &lt;= right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) # 将某一序列中剩下的元素全部放入 while left: result.append(left.pop(0)) while right: result.append(right.pop(0)) return result if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] arr = mergeSort(arr) print(arr) C实现 非递归实现： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int min(int x, int y) { return x &lt; y ? x : y; } void mergeSort(int arr[], int len) { int* a = arr; int* b = (int*)malloc(len * sizeof(int)); if (!b) return; // 分为约log_2(len)次 for (int seg = 1; seg &lt; len; seg += seg) { // 每次对下标区间为[low,high)的子序列进行归并排序 for (int start = 0; start &lt; len; start += seg * 2) { // 当前排序区间：[low,high) int low = start, mid = min(start + seg, len), high = min(start + seg * 2, len); // 第1段：[low,mid) int start1 = low, end1 = mid; // 第2段：[mid,high) int start2 = mid, end2 = high; // 对子序列进行归并排序 int i = low; // 将两个序列中较小的放在前面 while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) b[i++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++]; // 将某一序列中剩下的元素全部放入 while (start1 &lt; end1) b[i++] = a[start1++]; while (start2 &lt; end2) b[i++] = a[start2++]; } int* tmp = a; a = b; b = tmp; } if (a != arr) { for (int i = 0; i &lt; len; i++) b[i] = a[i]; b = a; } free(b); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int) sizeof(arr) / sizeof(*arr); mergeSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 递归实现： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void merge_sort_recursive(int arr[], int reg[], int start, int end) { // 结束递归 if (start &gt;= end) return; // 当前排序区间：[start,end] int len = end - start, mid = (len &gt;&gt; 1) + start; // 第1段：[start,mid] int start1 = start, end1 = mid; // 第2段：[mid+1,end] int start2 = mid + 1, end2 = end; // 对第1段进行递归地排序 merge_sort_recursive(arr, reg, start1, end1); // 对第2段进行递归地排序 merge_sort_recursive(arr, reg, start2, end2); int i = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) reg[i++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt;= end1) reg[i++] = arr[start1++]; while (start2 &lt;= end2) reg[i++] = arr[start2++]; for (int i = start; i &lt;= end; i++) arr[i] = reg[i]; } void mergeSort(int arr[], int len) { int* reg = (int*)malloc(len * sizeof(int)); merge_sort_recursive(arr, reg, 0, len - 1); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int) sizeof(arr) / sizeof(*arr); mergeSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 快速排序 快速排序在平均状况下，排序nnn个项目是O(nlog⁡n)O(n\\log {n})O(nlogn)。最坏运行情况是O(n2)O(n^2)O(n2)，但这种状况并不常见，比如说数列为顺序数列的情况下。一般，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 事实上，快速排序通常明显比其他O(nlog⁡n)O(n\\log {n})O(nlogn)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。 本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 算法步骤 从序列中选择一个元素作为“基准”（pivot）。 将所有比基准数小的放在基准左边，所有比基准数大的放在基准右边（相同的数可以在任一边）。这个称为分区（partition）操作。 分区完成后，该基准就会归到序列中的相应位置，该位置是排序完成后的位置。 分别递归地把小于基准数的子序列（左边）和大于基准数的子序列（右边）执行1~3操作。 动画演示： 代码实现 Python实现 def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] def partition(arr, left, right): # 设置基准 pivot = left # 索引从基准的下一个元素开始 index = pivot + 1 # 遍历:[index,right] for i in range(index, right + 1): # 将小于基准值的元素全部放到左边 if arr[i] &lt; arr[pivot]: swap(arr, i, index) index += 1 i += 1 # 将基准归位 # 此时index位置上的是比基准值大的元素 # 或者等于right+1 # 即1&lt;=index&lt;=right+1 # 只有index-1才是基准真正的位置 swap(arr, pivot, index - 1) return index - 1 def quickSort(arr, left=None, right=None): # 设定参数值 left = 0 if not isinstance(left, (int, float)) else left right = len(arr) - 1 if not \\ isinstance(right, (int, float)) else right if left &lt; right: # 先进行“治”操作并取得分区索引 partitionIndex = partition(arr, left, right) # 分别对左右两个分区递归地进行快速排序 quickSort(arr, left, partitionIndex - 1) quickSort(arr, partitionIndex + 1, right) return arr if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] quickSort(arr) print(arr) C实现 递归实现： #include &lt;stdio.h&gt; void quick_sort_recursive(int arr[], int start, int end) { if (start &gt;= end) return; // 设置基准 int pivot = arr[start]; int left = start, right = end; while (left &lt; right) { // 先从右边起找出比基准小的 while (arr[right] &gt;= pivot &amp;&amp; left &lt; right) right--; // 把比基准小的放到基准左边 arr[left] = arr[right]; // 再从左边起找出比基准大的 while (arr[left] &lt;= pivot &amp;&amp; left &lt; right) left++; // 把比基准大的放到基准右边 arr[right] = arr[left]; } // 将基准归位 arr[left] = pivot; // 分别递归地排序左右两个分区 quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end); } void quickSort(int arr[], const int len) { quick_sort_recursive(arr, 0, len - 1); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); quickSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 非递归实现： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 范围 typedef struct _stack { int start, end; } Range; // 申请一个新的栈元素 Range new_Range(int start, int end) { Range s = { .start = start, .end = end }; return s; } void quickSort(int arr[], const int len) { if (len &lt;= 1) return; // s模拟栈，p为数量，r[p++]为push，r[--p]为pop0 Range* s = (Range*)malloc(len * sizeof(Range)); int p = 0; // 范围为[0,len-1] s[p++] = new_Range(0, len - 1); while (p) { // pop出当前要排序的范围 Range range = s[--p]; if (range.start &gt;= range.end) continue; // 设置基准 int pivot = arr[range.start]; int left = range.start, right = range.end; while (left &lt; right) { // 先从右边起找出比基准小的 while (arr[right] &gt;= pivot &amp;&amp; left &lt; right) right--; // 把比基准小的放到基准左边 arr[left] = arr[right]; // 再从左边起找出比基准大的 while (arr[left] &lt;= pivot &amp;&amp; left &lt; right) left++; // 把比基准大的放到基准右边 arr[right] = arr[left]; } // 将基准归位 arr[left] = pivot; // 分别设置左右两个分区的范围 if (range.start &lt; left) s[p++] = new_Range(range.start, left - 1); if (range.end &gt; left) s[p++] = new_Range(left + 1, range.end); } free(s); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); quickSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。 堆积是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 堆排序是不稳定的。 算法步骤 将待排序的数组构造出一个堆 H[0……n-1]； 把堆首（堆顶结点，即最大值）和堆尾（堆的最下层最右边的结点）互换； 此时不再对原堆顶（最大值）进行操作，即原堆顶已经被“移出”，堆的长度缩小1。 把新的数组顶端数据调整到相应位置； 重复步骤 2~3，直到堆的尺寸为 1。 动画演示： 代码实现 Python实现 def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] def heapify(arr, len, i): # 子结点 son = 2*i + 1 # 最大值元素位置 largest = i # 将最大值置为堆顶结点 if son &lt; len: if son + 1 &lt; len and arr[son + 1] &gt; arr[son]: son += 1 if arr[son] &gt; arr[largest]: largest = son swap(arr, i, largest) # 重新构造子堆 heapify(arr, len, largest) def buildMaxHeap(arr): # int(len(arr)/2)递减至0 for i in range(int(len(arr)/2) - 1, -1, -1): heapify(arr, len(arr), i) def heapSort(arr, left=None, right=None): global arrLen arrLen = len(arr) # 构造堆 buildMaxHeap(arr) # len(arr)-1递减至1 for i in range(len(arr)-1, 0, -1): # 交换堆顶和最下层最右元素 swap(arr, 0, i) # 将原堆顶移出并重新调整堆 heapify(arr, i, 0) return arr if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] heapSort(arr) print(arr) C实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void swap(int* x, int* y) { int tmp = *x; *x = *y; *y = tmp; } void heapify(int arr[], int len, int i) { // 子节点 int son = i*2 + 1; // 最大值元素位置 int largest = i; // 将最大值置为堆顶结点 if (son &lt; len) { if (son + 1 &lt; len &amp;&amp; arr[son + 1] &gt; arr[son]) son++; if (arr[son] &gt; arr[largest]) { largest = son; swap(&amp;arr[i], &amp;arr[largest]); // 重新构造子堆 heapify(arr, len, largest); } } } void buildMaxHeap(int arr[], int len) { for (int i = len / 2 - 1; i &gt;= 0; i--) heapify(arr, len, i); } void heapSort(int arr[], int len) { // 构造堆 buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) { // 交换堆顶和最下层最右元素 swap(&amp;arr[0], &amp;arr[i]); // 将原堆顶移出并重新调整堆 heapify(arr, i, 0); } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); heapSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是Θ(n+k)Θ(n + k)Θ(n+k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。 算法步骤 找出待排序的数组中最大和最小的元素。 统计数组中每个值为 i的元素出现的次数，存入数组 C的第 i项。 对所有的计数累加（从 C中的第一个元素开始，每一项和前一项相加）。 反向填充目标数组：将每个元素 i放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。 动画演示： 代码实现 Python实现 def countingSort(arr): # 找出最大值 max = arr[0] for i in range(1, len(arr)): if arr[i] &gt; max: max = arr[i] # 构建一个长度为max+1的数组 bucket = [0] * (max + 1) # 计数 for i in range(len(arr)): if not bucket[arr[i]]: bucket[arr[i]] = 0 bucket[arr[i]] += 1 # 反向填充 index = 0 for i in range(len(bucket)): while bucket[i] &gt; 0: arr[index] = i bucket[i] -= 1 index += 1 return arr if __name__ == '__main__': arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] countingSort(arr) print(arr) C实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void countingSort(int arr[], int len) { // 找出最大值 int max = arr[0]; for (int i = 0; i &lt; len; i++) if (arr[i] &gt; max) max = arr[i]; // 构造和初始化 int bucketLen = max + 1; int* bucket = (int*)malloc(bucketLen * sizeof(int)); for (int i = 0; i &lt; bucketLen; i++) bucket[i] = 0; // 计数 for (int i = 0; i &lt; len; i++) if (arr[i] &lt; bucketLen) bucket[arr[i]]++; // 反向填充 for (int i = 0, j = 0; i &lt; bucketLen; i++) while (bucket[i] &gt; 0) { arr[j++] = i; bucket[i]--; } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); countingSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，需要做到两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 最快的情况：当输入的数据可以均匀的分配到每一个桶中。 最慢的情况：当输入的数据被分配到了同一个桶中。 算法步骤 将数列中的数均匀地分布到每个桶中（有时候并不是均匀分布）。 将每个桶中的数进行排序。 这里的排序可以使用桶排序也可以使用其它方法排序。 按照顺序将所有桶中的数据取出。 图片演示： 将元素分布在桶中： 元素在每个桶中排序： 代码实现 Python实现 from quick_sort import quickSort def bucketSort(arr, bucketsize): if len(arr) == 0 or bucketsize &lt;= 0: return arr # 确定最大最小值 maxValue = minValue = arr[0] for i in arr: if i &lt; minValue: minValue = i elif i &gt; maxValue: maxValue = i # 桶数量 count = (maxValue - minValue) // bucketsize + 1 # 对应的桶 buckets = [[] for i in range(count + 1)] # 把数据放入相应的桶 for i in arr: index = (i - minValue) // bucketsize buckets[index].append(i) # 桶内排序并合并数据 arr.clear() for j in buckets: if len(j) != 0: # 桶排序 # bucketSort(j, bucketsize-1) # 快速排序 quickSort(j) # 还可以换其它方法排序 arr.extend(j) return arr if __name__ == &quot;__main__&quot; : arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] bucketSort(arr, 5) print(arr) C实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; extern void quickSort(int arr[], const int len); typedef struct _list { int* bucket; int len; } List; void append(List* pl, int num) { if (!pl-&gt;len) { pl-&gt;bucket = (int*)malloc(sizeof(int)); pl-&gt;bucket[pl-&gt;len++] = num; return; } int* tmp = (int*)malloc((pl-&gt;len + 1) * sizeof(int)); for (int i = 0; i &lt; pl-&gt;len; i++) tmp[i] = pl-&gt;bucket[i]; tmp[pl-&gt;len++] = num; free(pl-&gt;bucket); pl-&gt;bucket = tmp; } void bucketSort(int arr[], int len, int bucketsize) { // 确定最大最小值 int max = arr[0], min = max; for (int i = 0; i &lt; len; i++) if (arr[i] &lt; min) min = arr[i]; else if (arr[i] &gt; max) max = arr[i]; // 桶数量 int count = (max - min) / bucketsize + 1; // 对应的桶 List* buckets = (List*)malloc(count * sizeof(List)); for (int i = 0; i &lt; count; i++) { buckets[i].bucket = NULL; buckets[i].len = 0; } // 方案一：动态数组 // 把数据放入相应的桶 for (int i = 0; i &lt; len; i++) { int index = (arr[i] - min) / bucketsize; append(&amp;buckets[index], arr[i]); } // 方案二：二维数组 // int* size = (int*)malloc(count * sizeof(int)); // // 计算最大宽度 // for (int i = 0; i &lt; count; i++) // size[i] = 0; // for (int i = 0; i &lt; len; i++) // size[(arr[i] - min) / bucketsize]++; // int maxSize = 0; // for (int i = 0; i &lt; count; i++) // if (size[i] &gt; maxSize) // maxSize = size[i]; // // 把数据放入相应的桶 // for (int i = 0; i &lt; len; i++) // { // int index = (arr[i] - min) / bucketsize; // if (!buckets[index].len) // buckets[index].bucket = (int*)malloc(maxSize * sizeof(int)); // buckets[index].bucket[buckets[index].len++] = arr[i]; // } // free(size); // 桶内快排并合并数据 int index = 0; for (int i = 0; i &lt; count; i++) if (buckets[i].len) { quickSort(buckets[i].bucket, buckets[i].len); for (int j = 0; j &lt; buckets[i].len; j++) arr[index + j] = buckets[i].bucket[j]; index += buckets[i].len; free(buckets[i].bucket); buckets[i].bucket = NULL; buckets[i].len = 0; } free(buckets); } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); bucketSort(arr, len, 5); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } 基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序还可以用于其它数据类型的排序（但其本质上还是整型，如字符型）。 基数排序用到了桶的概念，是桶排序的扩展，它是根据键值的每位数字来分配桶。 算法步骤 有两类基数排序： 最低位优先法，简称LSD法：先从最低位开始排序，再对次低位排序，直到对最高位排序后得到一个有序序列； 最高位优先法，简称MSD法：先从最高位开始排序，再逐个对各分组按次高位进行子排序，循环直到最低位。 📌如果位没有数的话，补0。 动画演示： 代码实现 Python实现 def getBit(num, i): return (num // i) % 10 def getMax(arr): max = arr[0] for i in range(len(arr)): if arr[i] &gt; max: max = arr[i] return max def radixSort(arr): if len(arr) &lt;= 1: return arr # 获取最大值 max = getMax(arr) # 根据最大位数排序 index = 1 while max // index: # 桶排序 buckets = [[] for i in range(10)] for x in arr: bit_num = getBit(x, index) buckets[bit_num].append(x) arr.clear() for x in buckets: arr.extend(x) index *= 10 return arr if __name__ == &quot;__main__&quot; : arr = [ 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 ] radixSort(arr) print(arr) C实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct _list { int* bucket; int len; } List; void append(List* pl, int num) { if (!pl-&gt;len) { pl-&gt;bucket = (int*)malloc(sizeof(int)); pl-&gt;bucket[pl-&gt;len++] = num; return; } int* tmp = (int*)malloc((pl-&gt;len + 1) * sizeof(int)); for (int i = 0; i &lt; pl-&gt;len; i++) tmp[i] = pl-&gt;bucket[i]; tmp[pl-&gt;len++] = num; free(pl-&gt;bucket); pl-&gt;bucket = tmp; } int getBit(int num, int i) { return (num / i) % 10; } void radixSort(int arr[], int len) { if (len &lt;= 1) return; // 获取最大值 int max = arr[0]; for (int i = 1; i &lt; len; i++) if (arr[i] &gt; max) max = arr[i]; // 根据最大位数排序 // 方案一：动态数组 for (int i = 1; max / i; i *= 10) { // 桶排序 List buckets[10] = { {NULL, 0} }; for (int j = 0; j &lt; len; j++) append(&amp;buckets[getBit(arr[j], i)], arr[j]); int index = 0; for (int j = 0; j &lt; 10; j++) if (buckets[j].len) { for (int k = 0; k &lt; buckets[j].len; k++) arr[index + k] = buckets[j].bucket[k]; index += buckets[j].len; free(buckets[j].bucket); buckets[j].bucket = NULL; buckets[j].len = 0; } } // 方案二：二维数组 // for (int i = 1; max / i; i *= 10) // { // // 计算最大宽度 // int size[10] = { 0 }; // for (int j = 0; j &lt; len; j++) // size[getBit(arr[j], i)]++; // int maxSize = size[0]; // for (int j = 0; j &lt; 10; j++) // if (size[j] &gt; maxSize) // maxSize = size[j]; // // 桶排序 // List buckets[10] = { {NULL, 0} }; // for (int j = 0; j &lt; len; j++) // { // int index = getBit(arr[j], i); // if (!buckets[index].len) // buckets[index].bucket = (int*)malloc(maxSize*sizeof(int)); // buckets[index].bucket[buckets[index].len++] = arr[j]; // } // int index = 0; // for (int j = 0; j &lt; 10; j++) // if (buckets[j].len) // { // for (int k = 0; k &lt; buckets[j].len; k++) // arr[index + k] = buckets[j].bucket[k]; // index += buckets[j].len; // free(buckets[j].bucket); // buckets[j].bucket = NULL; // buckets[j].len = 0; // } // } } int main(void) { int arr[] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 }; int len = (int)sizeof(arr) / sizeof(*arr); radixSort(arr, len); for (int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, arr[i]); return 0; } ","link":"https://linna-cy.github.io/old-blog/经典排序算法/"},{"title":"SQL语句","content":"基本概念 SQL（Structured Query Language，发音为 sequal）是一种专门用来与数据库沟通的语言。通过 SQL，用户可以对数据库进行各种操作。 标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSISQL。 数据库 数据库（database）是一个用于保存有组织的数据的容器或数据集合。 每个数据库都有唯一的标识符。 表 表（table）是某种特定类型数据的结构化清单，用于存储某种特定类型的数据。 在同一个数据库中的每个表都有一个唯一的标识符来标识自己。因此，在同个数据库中，不能拥有两个名称相同的表，但在不同的数据库中可以使用相同的表名。 模式 模式（schema）是一种关于数据库和表的布局及特性的信息。它是用来描述数据库中表的特性（如，存储的数据类型、数据的分解方式、各部分的信息的命名），或描述整个数据库（和其中表的关系）。 行和列 列 列（column）是表中的一个字段（即，表的组成部分）。所有的表都是由一个或多个列组成的。列存储表中的某部分信息，且这部分信息必须是同一种数据类型（datatype）。 数据类型限制（或允许）该列中存储的数据的种类。它还能帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。 利用特定的列，可以对数据进行分类和过滤。所以，数据分解十分重要。 数据类型及其名称是 SQL 不兼容的重要原因之一。对于不同的 DBMS，大多数基本数据类型都得到了一致的支持，但许多高级数据类型却没有。 行 表中每一条记录的数据都是按行（row）存储的。 主键 主键（primary key）是用来唯一标识表中每一行的列（如国际标准书号 ISBN 就可作为主键），可以是一列或多列。 满足以下条件的列即可作为主键： 任意两行都不具有相同的主键值。 每一行都必须具有一个主键值（主键列不允许空值 NULL）。 主键列中的值不允许修改或更新。 主键值不能重用（即使某行从表中删除，它的主键依然不能赋给以后的新行）。 在使用多列作为主键时，上述条件必须应用到所有列，即所有列值的组合必须是唯一的（但不同列中可以存在相同的值）。 关系数据库 关系数据库由关系表组成，而关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联。 常见的两个关系表都会有至少一个相同类型且表示相同的列，对于其中一个表，该列是这个表的主键，从而能使另一个表甚至关系数据库中的其他表通过这个主键对应到这个表中的行。 一个优秀的关系数据库通常具有以下优点： 关系库中的每个表中的每个行的信息重复很少，减少了时间和空间的浪费。 如果信息有更新，仅需更新对应的表中的数据。 数据是一致的（没有重复的数据），使得处理数据和生成报表更简单。 总结：关系数据库的可伸缩性（scale）远比非关系数据库要好。 可伸缩是指，能够适应不断增加的工作量而不失败。 数据库管理系统 数据库管理系统（DataBase Management System，DBMS）是一种用于创建和操纵数据库的软件。 绝大多数 DBMS 都支持 ANSI SQL，但一些 DBMS 有自己的扩展。不同的 SQL 实现有自己的名称（如 Oracle 的 PL/SQL、微软 SQL Server 的 Transact-SQL 等）。 DBMS 可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体的数据。 数据库管理系统、数据库和表的关系： SQL 语句分类 DDL（Data Definition Language，数据定义语言）：用来定义数据库对象：数据库，表，列等。 关键字：create、drop、alter 等。 DML（Data Manipulation Language，数据操作语言）：用来对数据库中表的数据进行增删改。 关键字：insert、delete、update 等。 DQL（Data Query Language，数据查询语言）：用来查询数据库中表的记录。 关键字：select、where 等。 DCL（Data Control Language，数据控制语言）：用来定义数据库的访问权限和安全级别，及创建用户。 关键字：GRANT、REVOKE 等。 SQL 语法 SQL语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 大多数数据库的 SQL 语句不区分大小写，关键字建议使用大写（可以提高运行速度）。 字段 字段（filed）基本上与列的意思相同，但字段这个术语通常在计算字段这种场合下使用。 SELECT 语句 任何 SQL 语句都是查询（query）。但此术语一般指 SELECT 语句。 检索列： -- 从 tab_name 中检索出filed1, filed2 等列（字段） -- 可以检索单个列或多个列 SELECT filed1, filed2, ... FROM tab_name; 列的顺序是按照指令中指出的列名的顺序显示。行的顺序是按照存储在物理内存中的顺序显示。 使用通配符 * 检索表中的所有列： -- 检索出 tab_name 中所有的列 SELECT * FROM tab_name; 一般情况下，返回的列是按照存储在物理内存中的顺序显示的，并没有特定顺序。可能是按照数据被添加到表中的顺序显示（在没有增删数据的情况下），也可能不是（在有数据进行过更新或删除，这个顺序将会受到 DBMS 重用回收存储空间的方式的影响）。 使用通配符可以很方便地显示表中所有的列（包括名字未知的列），但这么做可能会降低检索速度和应用程序的性能（因为程序会检索所有表中的所有列）。 ALL 和 DISTINCT 可以在列名前指定 ALL（默认）和 DISTINCT 关键字，它们表示： ALL —— 列出当前指定的列的所有行。 DISTINCT —— 列出由当前所有列组合的不重复的行。 可以对聚集函数使用 ALL 和 DISTINCT 关键字指定。 ALL —— 默认选项，包含所有的行，对聚集函数指定 ALL（可忽略）表示对所有的行执行计算。 DISTINCT —— 指定 DISTINCT，包含不重复的行。 对聚集函数指定 DISTINCT 表示只对不重复的行进行计算。 使用 DISTINCT 必须明确指出列名，而不能使用 *。 列出不重复的行： -- filed1, filed2, ... 不重复 SELECT DISTINCT filed1, filed2, ... FROM tab_name; DISTINCT 作用于所有指定的列，该 SELECT 语句会返回所有不重复的 filed1, filed2, ... 组合的行。使用 DISTINCT * 可以返回由所有列组合的不重复的行。 限制返回的行 各 DBMS 实现并不相同： SQL Server：使用 TOP 关键字。 -- 返回前 n 行 -- n 是任一正整数 SELECT TOP n filed1, filed2, ... FROM tab_name; DB2：FETCH FIRST n ROWS ONLY。 -- 返回前 n 行 -- n 是任一正整数 SELECT filed1, filed2, ... FROM tab_name FETCH FIRST n ROWS ONLY; Oracle：基于 ROWNUM（行计数器）。 -- 返回前 n 行 -- n 是任一正整数 SELECT filed1, filed2, ... FROM tab_name WHERE ROWNUM &lt;= n; MySQL、MariaDB、PostgreSQL and SQLite：使用 LIMIT 子句。 -- 返回前 n 行 -- n 是任一正整数 SELECT filed1, filed2, ... FROM tab_name LIMIT n; -- 返回从第 m 行开始的前 n 行 -- n 是任一正整数，m 是任一非负整数 SELECT filed1, filed2, ... FROM tab_name LIMIT n OFFSET m; 在 MySQL、MariaDB 和 SQLite 中，上条指令可简化为： -- 返回从第 m 行开始的前 n 行 -- n 是任一正整数，m 是任一非负整数 -- m 指定开始的行数，n 指定返回的行数 SELECT filed1, filed2, ... FROM tab_name LIMIT m, n; 行是从 0 开始计数。 ORDER BY 排序数据 使用 ORDER BY 子句取一个或多个列的名字，据此对数据进行排序： -- order1, order2, ... 是排序的依据 -- 该语句会先对 order1 进行排序 -- 仅在具有多行相同 order1 值时，才按照 order2 排序 SELECT filed1, filed2, ... FROM tab_name ORDER BY order1, order2, ...; ORDER BY 子句必须是 SELECT 语句中的最后一条子句。默认是升序排序（从 A 到 Z）。 按相对列位置进行排序： -- n1、n2 …… 是小于或等于指定的列的总数的正整数 -- n1、n2 …… 这组数中的每两个数都不相等 SELECT filed1, filed2, ... FROM tab_name ORDER BY n1, n2, ...; 按相对位置排序的好处是不用输入列名，但有可能会造成错用列进行排序（特别是在对 SELECT 清单进行更改时）。 实际列名排序和相对列位置排序可混合使用。 📌最好的排序方式是，对冗长的列名重命名，然后使用列名进行排序。这样可以减少错误的出现。 指定排序方向 指定排序的关键字：ASC —— 升序排序、DESC —— 降序排序。ASC 和 DESC 必须对每一列进行指定，因为它们只会对直接位于其前面的列名指定排序方式。可以对某一列指定 ASC（或 DESC）后对其它列指定 DESC（或 ASC）。 -- order1, order2, ... 是排序的依据，且都被指定了升序排序 SELECT filed1, filed2, ... FROM tab_name ORDER BY order1 ASC, order2, ... DESC 关键字指定降序排序。 -- order1, order2, ... 是排序的依据，且都被指定了降序排序 SELECT filed1, filed2, ... FROM tab_name ORDER BY order1 DESC, order2 DESC, ...; 对某些列指定升序排序，对另外某些列指定升序排序。 -- asc_order1, asc_order2, ... 都是指定升序排序 -- desc_order1, desc_order2, ... 都是指定降序排序 SELECT filed1, filed2, ... FROM tab_name ORDER BY asc_order1 ASC, asc_order2, ..., desc_order1 DESC, desc_order2 DESC, ...; 大多数 DBMS 默认使用字典（dictionary）排序（即大小写字母被视为相同），但许多 DBMS 允许改变这种方式。 WHERE 过滤数据 使用 WHERE 子句能够根据指定的搜索条件（search criteria），检索用户需要的数据。搜索条件也被称为过滤条件（filter condition1）。 检索单一条件： -- condition1 是表中任一列名 -- condition1 的类型和 n 的类型要一致 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 = n; 数据也可以在应用层进行过滤，但当 DBMS 返回的数据超出实际所需的数据时，会影响应用的性能，并且降低应用的可伸缩性，这还会造成网络宽带的浪费（服务器不得不通过网络发送多余的数据）。 WHERE 子句操作符（条件操作符）： 并非所有 DBMS 都支持所有的操作符，某些 DBMS 可能不支持个别操作符。 操作符 说明 操作符 说明 = 等于 &gt; 大于 &lt;&gt; or != 不等于 &gt;= 大于等于 &lt; 小于 !&gt; 不大于 &lt;= 小于等于 BETWEEN 范围在指定的两个值之间 !&lt; 不小于 IS NULL 为 NULL 的值 使用 BETWEEN 在指定范围内检索： -- condition1 是表中任一列名 -- condition1 的类型和 n 、m 的类型要一致 -- n 和 m 为低端值和高端值 -- 检索时匹配的值包括 n 和 m SELECT filed1, filed2, ... FROM tab_name WHERE condition11 BETWEEN n AND m; 使用 IS NULL 检索空值： -- condition1 是表中任一列名 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 IS NULL; IS NOT NULL 检索不为空值的行： -- condition1 是表中任一列名 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 IS NOT NULL; 逻辑操作符 可以在一条 WHERE 子句中包含任意数量的逻辑操作符（logical operator），且允许两者结合以进行复杂、高级的过滤。 AND 操作符检索满足所有给定条件的行： -- condition11，condition12 …… 是包含条件操作符的子句 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 AND condition12 AND ...; OR 操作符检索满足任一条件的行： -- condition11，condition12 …… 是包含条件操作符的子句 SELECT filed1, filed2, ... FROM tab_name WHERE condition11 OR condition12 OR ...; 许多 DBMS 在使用 OR 操作符时，当第 1 个条件满足的情况下，就不再计算第 2 个条件。 NOT 操作符是否定操作符，否定跟随在其后的条件。 -- condition1 是任意条件子句 SELECT filed1, filed2, ... FROM tab_name WHERE NOT condition11; 大多数 DBMS 允许使用 NOT 否定任何条件。 IN 指定条件范围 IN 操作符用来指定条件范围，匹配范围中指定的每个条件。IN 操作符后的括号中的合法值用逗号分隔。 -- condition1 是表中任一列 -- val1, val2, ... 是与 condition1 类型相同的一组合法值 SELECT filed1, filed2, ... FROM tab_name WHERE condition1 IN (val1, val2, ...); IN 操作符和 OR 操作符的功能类似，但在某些方面，IN 操作符有其优点。 在有很多合法选项时，IN 操作符可读性更强。 与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。 IN 操作符一般比一组 OR 操作符执行得更快。 IN 操作符可包含其他 SELECT 语句，能更动态地建立 WHERE 子句。 通配符 通配符（wildcard）是用于匹配值的一部分的特殊字符。 搜索模式（search pattern）由字面值、通配符或两者组合构成的搜索条件。 利用通配符，可以创建比较特定数据的搜索模式。要使用通配符，必须在搜索子句中使用 LIKE 操作符。且通配符只能用于字符串。 使用通配符搜索一般比其他简单搜索耗费更长的处理时间。 不要过度使用通配符。 尽量不要把通配符用在搜索模式的开始处（通配符置于开始处是最慢的）。 不同类型的通配符可以混合使用。 % 通配符：表示任何字符出现任意次数。 -- condition1 是表中任一字符类型的列 -- 该语句表示在 condition1 列中搜索以 ABC 开头的字符串 SELECT filed1, filed2, ... FROM tab_name WHRER condition1 LIKE 'ABC%'; 包含 ABC 的字符串：'%ABC%'； 以 ABC 结尾的字符串：'ABC%'； 以 A 为开头，以 B 为结尾的字符：'A%B'； 某些 DBMS 会用空格来填补字段内容，可能会对该搜索模式造成影响。 包含 AB 和 CD 的字符串：'%AB%CD%'； …… _ 通配符：表示匹配单个任意字符。 -- condition1 是表中任一字符类型的列 -- 该语句表示匹配以 ABC 结尾，开头为任意一个字符的字符串 SELECT filed1, filed2, ... FROM tab_name WHERE condition1 LIKE '_ABC'; [] 通配符：用来指定一个字符集，它必须匹配指定位置的一个字符。 Example: -- condition1 是表中任一字符类型的列 -- 该语句匹配以 A 或 B 其中之一与 C 的组合的字符串（仅有两个字符） SELECT filed1, filed2, ... FROM tab_name WHERE condition1 LIKE '[AB]C'; 使用 ^ 可以来否定 [] 定义的字符集：'[^AB]' —— 该模式会匹配除了 A 和 B 之外的任何一个字符。 拼接 拼接（concatenate）是指将值联结到一起（将一个值附加到另一个值）构成单个值。 SQL Server 使用 + 号拼接： -- filed1, filed2, filed3, ... 可以是任意同类型的字段 SELECT filed1 + filed2 + filed3 + ... FROM tab_name; DB2、Oracle、PostgreSQL 和 SQLite 使用 ||：filed1 || filed2 || filed3 || ...。 MySQL 和 MariaDB 使用 Concat() 函数：Concat(filed1, filed2, filed3, ...)。 某些 DBMS 会用空格填充字段，可以使用 RTRIM() 函数来清除这些空格。 AS 指定别名 使用 AS 关键字赋予字段或值一个别名（alias）。别名既可以是一个单词，也可以是一个字符串，字符串需用引号括起。使用别名时不应使用表中实际的列名，虽然这样做也算合法，但可能会产生模糊的错误消息。 -- filed 是一个字段或值 -- alias 是 filed 的别名 -- 赋予别名后可以在接下来的子句中使用别名来替代这个字段 SELECT filed AS alias FROM tab_name ORDER BY alias; 函数 数值处理函数 数值处理函数仅处理数值数据，是最一致、最统一的函数。 常用的数值处理函数： Functions Explain ABC() 返回一个数的绝对值。 COS() 返回一个角度的余弦。 EXP() 返回一个数的指数值。 PI() 返回圆周率 π\\piπ 值。 SIN() 返回一个角度的正弦。 SQRT() 返回一个数的平方根。 TAN() 返回一个角度的正切。 文本处理函数 常用的文本处理函数： Functions Explain LEFT(str, num) 返回字符串 str 左边前 num 个字符。 LENGTH(str)、 DATALENGTH(str) or LEN(str) 返回字符串的长度。 LOWER(str) 将字符串转换为小写。 LTRIM(str) 去掉字符串左边的空格。 RIGHT(str, num) 返回字符串 str 右边前 num 个字符。 RTRIM(str) 去掉字符串右边的空格。 SUBSTR(str, n, size) or SUBSTRING(str, n, size) 提取字符串的组成部分。 DB2、Oracle、PostgreSQL 和 SQLite 使用 SUBSTR()； MariaDB、MySQL 和 SQL Server 使用 SUBSTRING()。 n 是指字符串中第 n 个字符（从 1 开始计数）， size 是指截取的字符串长度，截取出的字符串包括第 n 个字符。 SOUNDEX(str) 返回字符串的 SOUNDEX 值（描述 str 语音表示的字母数字模式）。 PostgreSQL 不支持。SQLite 要开启 SQLITE_SOUNDEX 编译选项。 使用 SOUNDEX() 函数对两个字符串进行比较， 使得能对字符串进行发音比较而不是字母比较。 如 WHERE SOUNDEX(str1) = SOUNDEX(str2)。 UPPER(str) 将字符串转换为大写。 日期和时间处理函数 日期和时间函数在 SQL 中可移植性最差。 SQL Server 使用 DATEPART(part, date) 返回日期中的一部分，part（不是字符型的参数）指定要返回的成分，date 是要从中国年返回成分的日期。 PostgreSQL 使用 DATE_PART(part_str, date) 返回日期中的一部分，part_str 指定要返回的成分，date 是要从中国年返回成分的日期。 Oracle 和 PostgreSQL 都支持 EXTRACT(part FROM date) 返回日期中的一部分。part（不是字符型）指定要返回的成分，date 是要从中国年返回成分的日期。 Oracle 还支持 to_date(date_str, form_str) 将字符串转化成日期，date_str 是某个带有日期格式的字符串，form_str 指定日期的形式。一般这样使用：WHERE date_column BETWEEN to_date('2020-01-01', 'yyyy-mm-dd') AND todate('2020-12-31', 'yyyy-mm-dd')。 DB2、MySQL 和 MariaDB 中有 YEAR(date) 和 MONTH(date) 等函数用于提取年份和月份等信息。 在 SQLite 可以使用 strftime('%Y', date) 提取年份，也可以提取月份等。 MySQL Date 函数： 函数 描述 NOW() 返回当前的日期和时间。 CURDATE() 返回当前的日期。 CURTIME() 返回当前的时间。 DATE() 提取日期或日期/时间表达式的日期部分。 EXTRACT() 返回日期/时间的单独部分。 DATE_ADD() 向日期添加指定的时间间隔。 DATE_SUB() 从日期减去指定的时间间隔。 DATEDIFF() 返回两个日期之间的天数。 DATE_FORMAT() 用不同的格式显示日期/时间。 SQL Server Date 函数： 函数 描述 GETDATE() 返回当前的日期和时间 DATEPART() 返回日期/时间的单独部分 DATEADD() 在日期中添加或减去指定的时间间隔 DATEDIFF() 返回两个日期之间的时间 CONVERT() 用不同的格式显示日期/时间 汇总数据 使用聚集函数（aggregate function）可以对某些行进行计算并返回一个值。 SQL 聚集函数： Functions Explain AGE(filed) 返回某字段的平均数，类型必须是数值类型，AVG() 会忽略值为 NULL 的行。 COUNT(filed) 返回某字段的行数 MAX(filed) 返回某字段的最大值，允许 filed 是日期值，许多 DBMS 还允许 filed 是字符串，如果 filed 是字符串，那么 MAX() 会返回按该列排序后的最后一行。MAX() 忽略值为 NULL 的行。 MIN(filed) 返回某字段的最小值，与 MAX() 类似，如果 filed 是字符串，那么 MAX() 会返回按该列排序后的最前面一行。 SUM(filed) 返回某列值之和，类型必须是数值类型，SUM() 会忽略值为 NULL 的行。 Usage for Example: SELECT AVG(filed) AS average FROM tab_name WHERE condition1; SELECT 语句可以根据需要包含多个聚集函数。 GROUP BY 数据分组 分组是使用 SELECT 语句的 GROUP BY 子句，将数据分为多个逻辑组，对每个组进行操作。 -- 显示 filed1, filed2, ... 并根据它们进行分组 -- COUNT(*) 表示计算分组中的所有行 -- 该语句是先按照 filed1 进行分组，然后再按照 filed2 进行分组 -- 使用分组后输出的结果可能是根据 filed1, filed2, ... 排序好的 SELECT filed1, filed2, ..., COUNT(*); FROM tab_name GROUP BY filed1, filed2, ...; GROUP BY 子句指示 DBMS 分组数据，然后对每个组（不是整个结果集）进行聚集。 使用 GROUP BY 的规定： GROUP BY 子句可以包含任意数目的列。所以可以对分组进行嵌套，更细致地进行数据分组。 在建立分组后，操作的最小单位只能是分组，而无法再对个别列进行操作。 GROUP BY 子句中列出的每一列都必须是检索列或有效表达式列（但不能是聚集函数）。在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式，而不能使用别名。 大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。 除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句中给出。 分组列中所有包含具有 NULL 值的行，都将 NULL 作为一个分组返回。 GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。 📌并非所有 SQL 实现都支持在使用 GROUP BY 子句时，使用相对位置指定列，并且使用它容易在编辑 SQL 语句时出错。 HAVING 过滤分组 使用 HAVING 子句来过滤分组。HAVING 支持所有 WHERE 子句支持的操作符，两者的区别是 WHERE 仅对行进行过滤，而 HAVING 可以对分组进行过滤（在没有指定 GROUP BY 时，大多数 DBMS 会同等对待 WHERE 和 HAVING，即 HAVING 也可以对行进行过滤）。 -- filed_1, filed_2, ... 是聚集操作 -- condition1 是相对于每行的条件，condition1_ 是相对于每个分组的条件 SELECT filed1, filed2, ... filed_1, filed_2, ...; FROM tab_name WHERE condition1 GROUP BY filed1, filed2, ... HAVING condition1_; 在同时使用 WHERE 和 GROUP BY 时，被 WHERE 过滤掉的行并不会包括在分组中。 分组和排序 ORDER BY 与 GROUP BY 的区别 ORDER BY GROUP BY 对产生的输出排序 对行分组，但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用，即 SELECT 没有给出的列也能使用） 只可能使用选择列或表达式列（SELECT 中给出的列），而且必须使用每个选择列表达式（不能使用别名） 是可选的，任何情况下都能根据需要选择是否使用 在使用聚集函数的情况下， 还要显示列（或表达式），则必须使用 GROUP BY 分组不一定是按照分组顺序输出的，所以应该提供明确的 ORDER BY 子句指定排序方式，以确保在任何情况下输出都能正确地排序。 子查询 子查询（subquery）是指嵌套在其他查询中的查询。 -- 每个子查询中的 SELECT 语句有且仅有一个字段 -- 在子查询中企图检索多个列将返回错误 -- 理论上可以无限嵌套，但实际使用时由于性能的限制，不能嵌套太多的子查询 SELECT filed1, filed2, ... FROM table1 WHERE condition11 IN (SELECT filed_1 FROM table2 WHERE condition12 IN (SELECT filed_2 FROM table3 WHERE condition13 IN (...)); 在 SELECT 语句中，子查询总是从内向外处理（类似递归的处理方式）。 使用计算字段进行子查询 -- filed_1, filed_2, ... 是计算字段，是由其 AS 前的圆括号中的子查询建立的 -- table1._filed1 是 table1 中名为 _filed1 的列或列表达式 -- table2._filed1 是 table2 中名为 _filed2 的列或列表达式 -- table1._filed1 和 table2._filed1 是两个不同表格中同名同类型的列，并不是同一个列 -- table1._filed2 和 table3._filed2 的关系与 table1._filed1 和 table2._filed1 类似 -- 第 1 条子查询的解释是，对所有 table2 中符合 table1._filed1 = table2._filed1 的行进行计数 SELECT filed1, filed2, ... (SELECT COUNT(*) FROM table2 WHERE table1._filed1 = table2._filed1) AS filed_1 (SELECT COUNT(*) FROM table3 WHERE table1._filed2 = table3._filed2) AS filed_2 ... FROM table1; 计算字段用一个句点分隔表名和列名，句点前是表名，句点后是列名，即 tab_name.column，这种写法也叫完全限定列名。在有可能混淆列名时（如使用子查询时）必须使用这种语法。 JOIN 联结表 联结（join）是一种机制，用来在一条 SELECT 语句中关联表，可以联结多个表返回一组输出。 联结不是物理实体，它在实际的数据库表总并不存在，它仅在数据查询的执行期间存在。 对于联结，需要考虑性能，如果联结过多的表，可能会非常耗费资源，使性能下降。 SQL 本身不限制每个联结约束中表的数目，但实际上许多 DBMS 都有限制。 联结类型： 内联结（inner join） 外联结（outer join） 自联结（self-join） 自然联结（natural join） 可以在一个 SELECT 语句中使用联结多个表，而且每个表的联结类型可以不相同。 INNER JOIN 内联结 内联结（inner join）又称为等值联结（equijoin），是基于两个表之间的项等测试。 许多子查询都可以使用内联结来替代，但是子查询与联结同样需要耗费一定的资源，所以在一个语句中，不应使用过多的子查询和联结。 在 FROM 中指定多个列（等值联结）。 对于联结，需要保证所有联结都有 WHERE 子句，并且要保证 WHERE 子句的正确性。 -- filed1, filed2, ... 是存在于 table1, table2, ... 中的任意列或列表达式 -- 如果在不同表中出现名称相同的列，就需要使用完全限定名来指定 -- 完全限定名：tab_name.column_name -- condition1s 中必须给出联结条件 SELECT filed1, filed2, ... FROM table1, table2, ... WHERE condition1s; 如果上述语句没有在 WHERE 中指出配对方式，那么 table1 中的每一行会与 table2 中的每一行进行配对，然后 table1 和 table2 已经配对完成的行会再次与 table3 中的每一行配对，以此类推，直到所有的表都完成了配对。这种由没有联结条件的表联结后返回的结果为笛卡尔积（cartesian product）。 使用 INNER JOIN（内联结）指定要联结的表，联结条件用特定的 ON 子句给出。 同样地，对于这种方式的联结，需要保证所有联结都有有效的 ON 子句。如果没有 ON 子句，也会出现笛卡尔积。 -- filed1, filed2, ... 是存在于 table1, table2, ... 中的任意列或列表达式 -- 如果在不同表中出现名称相同的列，就需要使用完全限定名来指定 -- condition1 中必须给出联结条件 SELECT filed1, filed2, ... FROM table1 INNER JOIN table2 ON condition11 INNER JOIN table3 ON condition12 INNER JOIN ... -- 如果有其他条件的话 WHERE 子句在 INNER JOIN 之后给出 ANSI SQL 规范首选 INNER JOIN 语法。 自联结 自联结（self-join）是指在同一个 SELECT 语句中，多次联结同一个表。 对于自联结来说，由于多次引用同一个表，如果不对表起别名的话，会造成系统混乱（同一个表，表名自然相同，所以系统无法区分究竟指的是哪个表，虽然本质上都是同一个表）。 SELECT T1.filed1, T1.filed2, ... FROM tab_name AS T1, tab_name AS T2 WHERE T1.filed_1 = T2.filed_1 AND T2.filed_2 = value; 虽然自联结也可以用子查询替换，但对于大多数 DBMS 来说，处理联结远比处理子查询快。 SELECT filed1, filed2, ... FROM tab_name WHERE filed_1 = (SELECT filed_1 FROM tab_name WHERE filed_2 = value); 自然联结 自然联结（natural join）指每个含义相同的列仅出现一次的联结。自然联结一般是通过对一个表使用通配符，而对其他表的列使用明确的子集来完成。 SELECT T1.*, T2.filed1, T2.filed2, ... FROM table1 AS T1, table2 AS T2 WHERE T1.filed_1 = T2.filed_1 AND ...; OUTER JOIN 外联结 外联结（outer join）是指包含无关联行的联结。通常，内联结都是将一个表格中的行与另一个表格中的行通过联结条件进行关联，此时两个表格中没有被联结条件关联起来的行将会被忽略。而外联结则会包含这些没有被联结条件所关联起来的行，并根据需要给某些列赋予 NULL 值。 外联结有三种类型： LEFT OUTER JOIN —— 左外联结，包含左表的所有行（即 FROM 后面紧跟的表，示例中为 T1），即使在右表（示例中为 T2）中没有被匹配（结果为 NULL）。 基本上所有的 DBMS 都支持。 SELECT T1.filed1, T1,filed2, ... T2.filed_1, T2.filed_2, ... FROM table1 AS T1 LEFT OUTER JOIN table2 AS T2 ON T1.filed = T2.filed; RIGHT OUTER JOIN —— 右外联结，包含左表的所有行（即 JOIN 关键字后紧跟的表，示例中为 T2），即使在右表（示例中为 T1）中没有被匹配（结果为 NULL）。 SQLite 不支持。 SELECT T1.filed1, T1,filed2, ... T2.filed_1, T2.filed_2, ... FROM table1 AS T1 RIGHT OUTER JOIN table2 AS T2 ON T1.filed = T2.filed; FULL OUTER JOIN —— 全外联结，只要左表和右表其中一个表中存在匹配，就返回。 MariaDB、MySQL 和 SQLite 都不支持。 左外联结和右外联结可以相互转换。 联结、聚合函数与分组 联结的一种用法是使用聚合函数从另一个表格中汇总数据。 -- condition1 是联结条件 SELECT T1.filed1, T2.filed2, ... COUNT(T2.filed_1) AS name_filed FROM table1 AS T1 INNER JOIN table2 AS T2 ON condition1 GROUP BY T1.filed1, T1,filed2, ...; 对于上述语句也可以指定外联结，仅需将 INNER JOIN 替换成外联结的关键字。 使用外联结从另一个表中汇总数据，那些没有被关联的行经过 COUNT() 函数计算后的返回值将会为 0。 UNION 组合查询 组合查询通常称为并（union）或符合查询（compound query）。通过组合查询可以同时执行多条 SELECT 语句，并将结果作为一个查询结果集返回。 需要使用组合查询的情况： 在一个查询中从不同的表返回结构数据； 对一个表执行多个查询，按一个查询返回数据。 📌 组合相同表的查询所完成的工作一般可以用 WHERE 子句替代。 理论上使用 WHERE 子句和组合查询从性能上看并没有太大差别，但各实现之间任有差别。 第一条 SELECT 中的列名或指定的别名作为整个组合查询的结果集的列名。因此组合查询所返回的结果集的列名是第一条 SELECT 中的列名，且在组合查询中的 ORDER BY 子句中指出的列名应是第一条 SELECT 中第列名。 每一个组合查询最多仅能有一条 ORDER BY 子句，且必须位于整个组合查询语句的最后（即最后一条 SELECT 语句）。 即，无法对某条 SELECT 指定一种排序方式，而对另一条 SELECT 指定另一种排序方式，所有的 SELECT 只能用同一种方式排序。 使用组合查询的规则： 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字 UNION 分隔。 每个查询必须包含相同的列、表达式或聚集函数（数量必须要相同，类型必须要兼容）。 使用 UNION 关键字，会自动去除重复的行： -- filed1, filed2, ... 和 filed_1, filed_2, ... 数量必须相同，类型要兼容 -- table1 和 table2 可以是同个表格，也可以是不同的表格 -- ORDER BY 必须位于语句的最后 SELECT filed1, filed2, ... FROM table1 WHERE condition11 UNION SELECT filed_1, filed_2, ... FROM table2 WHERE condition12 UNION ... ORDER BY filed; 在上述语句中，将 UNION 替换成 UNION ALL，返回的结果集将包含重复的行。 INSERT 语句 INSERT 语句用来将行插入（或添加）到数据库表。 插入完整的行 简单但不保险的方法： INSERT INTO tab_name VALUES(value1, value2, value3, ..., NULL, ...); VALUES 后面的括号中，按照表中列的定义次序，指出了要存储到表中的数据，且必须给每一列提供一个值（在没有指定列名的情况下）。如果某列没有值，则该列应该使用 NULL（在允许对该列指定空值的情况下）。各列必须以它们在表定义中出现的次序填充。 这种语法虽然简单但并不安全，因为这种 SQL 语句高度依赖于表中列的定义次序。如果表结构发生变动，那么这样的语句并不能按照预期的情况执行。 📌在某些 SQL 实现中，INTO 关键字是可选的。但为了确保可移植，还是要提供 INTO 关键字。 保险但比较繁琐的方法： -- filed1 与 value1 对应，filed2 与 value2 对应，以此类推 INSERT INTO tab_name(filed1, filed2, filed3, ...) VALUES(value1, value2, value3, ...); 这种方法需要在表名后面，使用括号将表中的所有列名指出（不用按照表中列的定义顺序）。在插入行时，VALUES 必须以其指定的次序匹配指定的列名，这样即使表结构改变，该 INSERT 语句仍能正确工作。不要使用没有明确给出列的 INSERT 语句。 主键的值必须有唯一性，DBMS 不允许插入主键值重复的行。如果确实需要插入，应先删除原有的记录。 插入行的一部分 -- filed1 与 value1 对应，filed2 与 value2 对应，以此类推 INSERT INTO tab_name(filed1, filed2, ...) VALUES(value1, value2, ...); 同样使用表名后面的括号指定列，只不过仅需指出需要插入的部分列，并且只需给这些列提供值。 无论是插入完整的行还是插入行的一部分，都必须确保 VALUES 的数目正确。如果不提供列名，则必须给每个表列提供一个值；如果提供列名，则必须给列出的每一个列一个值。否则，就会产生错误。 在 VALUES 中没有指出的列，DBMS 将赋予它们默认值或空值。这些列必须满足： 列定义为允许 NULL 值。 在表定义中给出了默认值。 INSERT SELECT INSERT 还允许利用 SELECT 语句将检索到的结果插入表中。 -- 将 table2 中满足条件的 filed_1, filed_2, ... 列按照对应顺序插入到 table1 中 -- table1 和 table2 可以是同一个表 INSERT INTO table1(filed1, filed2, ...) SELECT filed_1, filed_2, ... FROM table2 WHERE condition1s; 一般 INSERT 只插入一行。而 INSERT SELECT 可以用一条语句插入多行。 SELECT INTO SELECT ... INTO 用于从一个表中复制数据，然后把数据插入到另一个新表中（INTO 子句后指定的表，该语句执行后会自动创建）。 📌MySQL 不支持 SELECT ... INTO 语句。 -- INTO 后面的 IN 子句代表插入到其他数据库 -- IN 子句可省略，默认代表当前数据库 -- new_table 的表结构与 old_table 指定列 filed1, filed2, ... 的结构相同 SELECT filed1, filed2, ... INTO new_table [IN external_db] FROM old_table; SELECT INTO 语句可以通过使用促使查询没有数据返回的 WHERE 子句创建一个新的空表： SELECT filed1, filed2, ... INTO new_table FROM old_table WHERE 1 = 0; 更新和删除数据 在客户端或服务器的 DBMS 中，使用 UPDATE 和 DELETE 语句可能需要特殊的安全权限。 UPDATE 语句 UPDATE 语句用于更新（修改）表中的数据。 有两种使用 UPDATE 语句的方式： 更新表中的特定行 —— 使用 WHERE 子句过滤： 基本的 UPDATE子句由三部分组成： 要更新的表 —— 使用 UPDATE 关键字指定； 列名和它们的新值 —— 使用 SET 关键字指定更新的内容（即使用 “列=值” 对将新值赋给被更新的列）； 确定要更新哪些行的过滤 —— 使用 WHERE 子句指定过滤条件。 在 UPDATE 中，WHERE 可以使用 SELECT 子查询。 -- filed1, filed2, ... 是 tab_name 中的列 -- value1, value2, ... 是与 filed1, filed2, ... 相对应类型的数据 -- filed1 = value1, filed2 = value2, ... 是 “列=值” 对 -- condition1s 是过滤的条件，指定了要更新的行 UPDATE tab_name SET filed1 = value1, filed2 = value2, ... WHERE condition1s; 更新表中的所有行 —— 不使用 WHERE 子句。 一般的 UPDATE 字句都要使用 WHERE 字句指定过滤条件，否则 SET 子句指定的更新内容将应用到所有的列。 📌有的 SQL 实现支持在 UPDATE 语句中使用 FROM 子句，用一个表的数据更新另一个表的行。 使用 UPDATE 删除某个列的值：将要删除的列置为 NULL（假设表定义允许 NULL）。如： UPDATE tab_name SET del_filed = NULL WHERE condition1s; DELETE 语句 使用 DELETE 语句可以从一个表中删除（去掉）数据。 有两种使用 DELETE 语句的方式： 从表中删除特定的行 —— 使用 WHERE 子句过滤： -- condition1s 是过滤条件，指定了要删除的行 DELETE FROM tab_name WHERE condition1s; 从表中删除所有行 —— 不使用 WHERE 子句： 使用 DELETE 语句时应该指定 WHERE 子句，否则它将会删除表中所有的行。 如果确实想删除表中所有行，应该使用速度更快的 TRUNCATE TABLE 语句。 DELETE 语句删除的是表中的行，即它的操作对象是行而不是列，如果想要删除列，则要使用 UPDATE 语句将该列置为 NULL。 UPDATE 和 DELETE 的使用准则 绝对不要使用不带 子句的 UPDATE 或 DELETE 子句，除非确实打算更新和删除每一行。 应保证每个表都有主键。 在使用 UPDATE 或 DELETE 之前，应先用 SELETE 进行测试，确保 WHERE 子句过滤的是正确的记录。: 使用强制实施引用完整性的数据库，这样 DBMS 将不允许删除其数据与其他表相关的行。 如果 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句的 UPDATE 或 DELETE 子句，那么应该使用它。 📌如果 SQL 没有撤销（undo）按钮，应该更小心地使用 UPDATE 和 DELETE 语句。 创建和删除数据库 创建数据库使用 CREATE DATABASE 语句。 CREATE DATABASE db_name; 删除数据库使用 DROP DATABASE 语句。 DROP DATABASE db_name; 注意：删除数据库后，数据库中的所有数据（表、视图、索引等数据都将会被删除）。 SQL 通用数据类型 数据类型定义列中存放的值的种类。数据库表中的每个列都要求有名称和数据类型。SQL 开发人员必须在创建 SQL 表时决定表中的每个列将要存储的数据的类型。 不同的 DBMS 数据类型有些不同。有的 DBMS 允许自定义数据类型，有的不允许。 以下是 SQL 通用数据类型： 数据类型 描述 CHARACTER(n) 或 CHAR(n) 字符/字符串。固定长度 n。 VARCHAR(n) 或 CHARACTER VARYING(n) 字符/字符串。可变长度。最大长度 n。 BINARY(n) 二进制串。固定长度 n。 BOOLEAN 存储 TRUE 或 FALSE 值 VARBINARY(n) 或 BINARY VARYING(n) 二进制串。可变长度。最大长度 n。 INTEGER(p) 整数值（没有小数点）。精度 p。 SMALLINT 整数值（没有小数点）。精度 5。 INTEGER 整数值（没有小数点）。精度 10。 BIGINT 整数值（没有小数点）。精度 19。 DECIMAL(p,s) 精确数值，精度 p，小数点后位数 s。 例如：DECIAML(5,2) 是一个小数点前有 3 位数，小数点后有 2 位数的数字。 NUMERIC(p,s) 精确数值，精度 p，小数点后位数 s。（与 DECIMAL 相同）. FLOAT(p) 近似数值，尾数精度 p。一个采用以 10 为基数的指数计数法的浮点数。该类型的 size 参数由一个指定最小精度的单一数字组成。 REAL 近似数值，尾数精度 7。 FLOAT 近似数值，尾数精度 16。 DOUBLE PRECISION 近似数值，尾数精度 16。 DATE 存储年、月、日的值。 TIME 存储小时、分、秒的值。 TIMESTAMP 存储年、月、日、小时、分、秒的值。 INTERVAL 由一些整数字段组成，代表一段时间，取决于区间的类型。 ARRAY 元素的固定长度的有序集合。 MULTISET 元素的可变长度的无序集合。 XML 存储 XML 数据。 SQL 数据类型快速参考手册： 数据类型 Access SQL Server Oracle MySQL PostgreSQL boolean Yes/No Bit Byte N/A Boolean integer Number (integer) Int Number Int、 Integer Int、 Integer float Number (single) Float Real Number Float Numeric currency Currency Money N/A N/A Money string (fixed) N/A Char Char Char Char string (variable) Text (&lt;256) Memo (65k+) Varchar Varchar、Varchar2 Varchar Varchar binary object OLE Object Memo Binary (fixed up to 8K) Varbinary (&lt;8K) Image (&lt;2GB) Long Raw Blob Text Binary Varbinary 时间数据格式 MySQL 使用下列数据类型在数据库中存储日期或日期/时间值： DATE - 格式：YYYY-MM-DD DATETIME - 格式：YYYY-MM-DD HH:MM:SS TIMESTAMP - 格式：YYYY-MM-DD HH:MM:SS YEAR - 格式：YYYY 或 YY SQL Server 使用下列数据类型在数据库中存储日期或日期/时间值： DATE - 格式：YYYY-MM-DD DATETIME - 格式：YYYY-MM-DD HH:MM:SS SMALLDATETIME - 格式：YYYY-MM-DD HH:MM:SS TIMESTAMP - 格式：唯一的数字 创建和操纵表格 CREATE TABLE 创建表 一般有两种创建表格的方法： 使用 SQL 语句 CTEATE TABLE 创建表格； 多数 DBMS 都具有交互式创建和管理数据库表的工具。 其本质是交互工具根据用户操作自动生成并执行相应的 SQL 语句。 不同的 SQL 实现中，CREATE TABLE 语句的语法会有所不同（主要区别是在列定义上）。 使用 CREATE TABLE 创建表，必须给出以下信息： 新表的名字，在关键字 CREATE TABLE 之后给出； 表列的名字和定义，在列名后的括号中指出，用逗号分隔； 有的 DBMS 还要求指定表的位置。 CREATE TABLE tab_name ( column_name1 DataType1, column_name2 DataType2, column_name3 DataType3, cluumn_name4 DataType4, ... ); 创建新表时只能指定不存在的表名，SQL 无法通过 CREATE 语句覆盖已有的表。 ALTER TABLE 更新表定义 使用 ALTER TABLE 时需要考虑的事情： 理想情况下，不要在表中包含数据时对表结构进行更新（特别是不要删除已有的列）。 应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。 所有的 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 NULL 和 DEFAULT 的使用）有所限制。 许多 DBMS 不允许删除或更改表中的列。 多数 DBMS 允许重新命名表中的列。 许多 DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。 使用 ALTER TABLE 必须给出的信息： 在 ALTER TABLE 之后给出表名； 列出要更改表的操作。 增加表列： ALTER TABLE tab_name ADD filed DataType; 删除列： ALTER TABLE tab_name DROP COLUMN filed; 复杂的表结构更改一般需要执行以下步骤： 用新的列布局创建一个新表； 使用 INSERT SELECT 语句从旧表复制数据到新表； 检验包含所需数据的新表； 重命名旧表（在确定无误的情况下可删除）； 用旧表原来的名字重命名新表； 根据需要，重新创建触发器、存储过程、索引和外键。 使用 ALTER TABLE 的注意事项： SQLite 对使用 ALTER TABLE 的最重要的限制是：不支持使用 ALTER TABLE 定义主键和外键，必须在最初创建表时指定。 在使用 ALTER TABLE 之前应先做好完整的备份（表结构和数据的备份）。 表结构的更改不能撤销。 如果增加了不需要的列，也许无法删除它们。 如果删除了不应该删除的列，可能会丢失该列中的所有数据。 DROP TABLE 删除表 DROP TABLE 语句用于删除表本身（包括表数据）。 DROP TABLE tab_name; 📌删除表时，没有确认步骤，且不能撤销。 📌使用关系规则防止意外删除： 许多 DBMS 允许强制实施有关规则，防止删除与其他表相关联的表。在实施这些规则时，如果对某个表发布一条 DORP TABLE 语句，且该表是某个关系的组成部分，则 DBMS 将阻止这条语句执行，直到该关系被删除为止。 TRUNCATE TABLE 删除表数据 TRUNCATE TABLE 语句用于删除表内的数据（但并不包括表本身）。 TRUNCATE TABLE tab_name; 重命名表 对于重命名表，每个 DBMS 的支持都有所不同： DB2、MariaDB、MySQL、Oracle 和 PostgreSQL 使用 RENAME 语句。 SQL Server 使用 sp_rename 存储过程。 SQLite 使用 ALTER TABLE 语句。 SQL 约束 SQL 约束（Constraints）用于规定表中如何插入或处理数据的规则。如果存在违反约束的数据行为，行为会被约束终止。 约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。 SQL 有如下几种约束： 关键字 解释 NULL 允许存储 NULL 值。 如果不指定 NOT NULL 或 PRIMARY KEY，则默认为 NULL。 在插入行时允许不给出该列的值。此时，会给该项指定为值 NULL。 对于 DB2，在定义允许 NULL 的列中不能指定 NULL。 NOT NULL 指示某列不能存储 NULL 值。 如果不向字段添加值，就无法插入新记录或者更新记录。 UNIQUE 唯一约束。保证某列的每行必须有唯一的值。 唯一约束可包含 NULL 值，可重复使用，但是不能用来定义外键。 PRIMARY KEY 主键约束。NOT NULL 和 UNIQUE 的结合。 确保某列（或多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY 外键约束。保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK 保证列中的值符合指定的条件。 DEFAULT 规定没有给列赋值时的默认值。 在插入行时如果不给出值，则用默认值赋值。 Example： CREATE TABLE tab_name ( # 主键约束 column1 Type1 PRIMARY KEY, # 默认为允许 NULL，可以不用指出 column2 Type2 [NULL], # 不允许 NULL 的列，必须用 NOT NULL 指出 column3 Type3 NOT NULL, # 用 DEFAULT 指定默认值 # default_val 是 Type4 类型的值 column4 Type4 NOT NULL DEFAULT default_val, ... ); NOT NULL 非空约束 CREATE TABLE tab_name ( column1 Type1 NOT NULL, ... ); 添加 NOT NULL 约束： ALTER TABLE tab_name MODIFY column_name Type1 NOT NULL; UNIQUE 唯一约束 每个表可以有多个 UNIQUE 约束。 创建表时： CREATE TABLE tab_name ( column1 Type1 NOT NULL, # 方法一：直接在列定义中用 UNIQUE 关键字指出 column2 Type2 NOT NULL UNIQUE, ... # 方法二：定义列后使用 UNIQUE() UNIQUE (column1) ); -- 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束 CREATE TABLE tab_name ( column1 Type1 NOT NULL, column2 Type2 NOT NULL, ... # 可以不用定义 u_name CONSTRAINT [u_name] UNIQUE (column1, column2, ...) ); 更新表定义时： ALTER TABLE tab_name ADD UNIQUE (column_name); -- 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束 ALTER TABLE tab_name # name 可以省略 ADD CONSTRAINT u_name UNIQUE (column1, column2, ...); 撤销 UNIQUE 约束： MySQL： ALTER TABLE tab_name DROP INDEX u_name; SQL Server / Oracle / MS Access： ALTER TABLE tab_name DROP CONSTRAINT u_name; PRIMARY KEY 主键约束 只要满足以下条件，就可以被用作主键： 任意两行的主键值都不相同（主键必须包含唯一值）。 每行都具有一个主键值（主键列不能包含 NULL 值）。 包含主键值的列从不修改或更新。 主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。 创建表时： -- 在列定义中直接指出主键 CREATE TABLE tab_name ( column1 Type1 NOT NULL PRIMARY KEY, ... ); -- 通过 PRIMARY KEY () 定义 CREATE TABLE tab_name ( column1 Type1 NOT NULL, ... PRIMARY KEY (column1) ); -- 命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 CREATE TABLE tab_name ( column1 Type1 NOT NULL, column1 Type1 NOT NULL, ... # 可以不用定义 pk_name CONSTRAINT [pk_name] PRIMARY KEY (column1, column2, ...) ); 更新表定义时： ALTER TABLE tab_name ADD PRIMARY KEY (column_name); -- 命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束 ALTER TABLE tab_name # name 可以省略 ADD CONSTRAINT pk_name UNIQUE (column1, column2, ...); 撤销 PRIMARY KEY 约束： MySQL： ALTER TABLE tab_name DROP PRIMARY KEY; SQL Server / Oracle / MS Access： ALTER TABLE tab_name DROP CONSTRAINT pk_name; FOREIGN KEY 外键约束 创建表时： CREATE TABLE tab_name ( # 方法一：使用 REFERENCES 关键字 column1 Type1 NOT NULL REFERENCES table1(column_1), column2 Type2 NOT NULL, column2 Type2 NOT NULL, ... # 方法二：使用 FOREIGN KEY () FOREIGN KEY (column2) REFERENCES table2(column_2), # 命名 FOREIGN KEY 约束 CONSTRAINT [fk_name] FOREIGN KEY (column3) REFERENCES table3(column_3) ); 更新表定义时： ALTER TABLE tab_name ADD FOREIGN KEY (column1) REFERENCES table1(column_1); -- 命名 FOREIGN KEY 约束 ALTER TABLE tab_name ADD CONSTRAINT fk_name FOREIGN KEY (column1) REFERENCES table1(column_1); 撤销 FOREIGN KEY 约束： MySQL： ALTER TABLE tab_name DROP FOREIGN KEY fk_name; SQL Server / Oracle / MS Access： ALTER TABLE tab_name DROP CONSTRAINT fk_name; CHECK 检查约束 CHECK 约束常见用途： 检查最小或最大值。 指定范围。 只允许特定值。 创建表时： CREATE TABLE tab_name ( # 限制 column1 的值大于 0 column1 Type1 NOT NULL CHECK (column1 &gt; 0), column2 Type2 NOT NULL, ... # 限制 column2 只能取 'Y' 或 'N' CHECK (column2 LIKE '[YN]') ); -- 命名 CHECK 约束，并定义多个列的 CHECK 约束 CREATE TABLE tab_name ( column1 Type1 NOT NULL, column2 Type2 NOT NULL, ... CONSTRAINT chk_name CHECK (column1 &gt; 0 AND column2 LIKE '[YN]') ); 修改表定义时： ALTER TABLE tab_name ADD CHECK (column1 &gt; 0); -- 命名 CHECK 约束，并定义多个列的 CHECK 约束 ALTER TABLE tab_name ADD CONSTRAINT chk_name CHECK (column1 &gt; 0 AND column2 LIKE '[YN]'); 撤销 CHECK 约束： MySQL： ALTER TABLE tab_name DROP CHECK chk_name; SQL Server / Oracle / MS Access： ALTER TABLE tab_name DROP CONSTRAINT chk_name; DEFAULT 默认约束 创建表时： CREATE TABLE tab_name ( # default_val 是 Type4 类型的值 column1 Type1 NOT NULL DEFAULT default_val, ... ) -- 可以使用类似 GETDATE() 的函数插入系统值 CREATE TABLE tab_name ( # 默认值为当前的日期 birthday DATE NOT NULL DEFAULT GETDATE(), ... ) 更新表结构时： MySQL： ALTER TABLE tab_name ALTER column1 SET DEFAULT default_val; SQL Server / MS Access： ALTER TABLE tab_name ADD CONSTRAINT name DEFAULT default_val for column1; Oracle： ALTER TABLE tab_name MODIFY column1 DEFAULT default_val; 撤销 DEFAULT 约束： MySQL： ALTER TABLE tab_name ALTER column1 DROP DEFAULT; SQL Server / Oracle / MS Access： ALTER TABLE tab_name ALTER COLUMN column1 DROP DEFAULT; AUTO INCREMENT 字段 在定义表时，在列中添加 auto-increment 字段可以在新纪录插入表时对该列生成一个唯一的数字。 定义为 auto-increment 字段的列必须是整数类型。 定义为 auto-increment 的列常常被定义为 PRIMARY KEY。 MySQL 使用 AUTO_INCREMENT 关键字来执行 auto-increment 任务： CREATE TABLE tab_name ( # 定义 column1 为 AUTO INCREMENT 主键字段 column1 TYPE1 NOT NULL PRIMARY KEY AUTO_INCREMENT, column2 TYPE2, column3 TYPE3, ... ); 定义了 AUTO_INCREMENT 字段后，可以不用对该列指定值，或者对该列指定为 NULL 值（会自动添加一个唯一的值）。 MySQL 的 AUTO_INCREMENT 只能在 key 上被定义。PRIMARY KEY 和 UNIQUE 都是有效的定义。 -- val2 和 val3 是分别与 column2 和 column3 同类型的值 -- 不对 auto-increment 列指定值 INSERT INTO tab_name ( column2, column3 ) VALUES ( val2, val3 ); -- 指定为 NULL 值 INSERT INTO tab_name ( column1, column2, column3) VALUES ( NULL, val2, val3); AUTO_INCREMENT 默认的开始值是 1，每新增一条记录都会递增 1。 让 AUTO_INCREMENT 序列以其他的值起始： -- number 是任意数字 ALTER TABLE tab_name AUTO_INCREMENT=number; MySQL 设定起始值只能在建表后使用 ALTER TABLE 语句。也可以在建表后直接使用 ALTER TABLE 语句定义 AUTO_INCREMENT 以及它的起始值。 CREATE TABLE tab_name ( column1 INT NOT NULL PRIMARY KEY, ... ); ALTER TABLE tab_test AUTO_INCREMENT=number; -- number 是任意数字 MS SQL Server 使用 IDENTITY() 来执行 auto-increment 任务： -- IDENTITY(initial, incremental) 中， -- initial 是初始值，incremental 是递增值 -- 即，以 initial 作为初始值，每新增一条记录递增 incremental CREATE TABLE tab_name ( column1 INT IDENTITY(initial, incremental) PRIMARY KEY, ... ) 插入数据的方法同 MySQL。 Oracle 通过创建 sequence 对象（该对象生成数字序列）创建 auto-increment 字段： CREATE SEQUENCE sp_name MINVALUE 1 # 最小值为 1 START WITH 1 # 起始值为 1 INCREMENT BY 1 # 每次递增 1 CACHE 10 # 缓存 10 个值以提高性能 插入新记录时，必须使用 sequence 对象的 nextval 函数（该函数从 sp_name 序列中取回下一个值）： -- 假设 tab_name 已被创建， -- 且要对 column1 使用 nextval() 函数 INSERT INTO tab_name ( column1, column2, column3) VALUES ( sp_name.nextval, val2, val3); 视图 视图是虚拟的表。视图并不包含数据，它只包含使用时动态检索数据的查询。视图的 SELECT 用法与表的用法基本相同。 使用视图的原因： 重用 SQL 语句。 简化复杂的 SQL 操作（无需知道视图的基本查询细节）。 使用表的一部分而不是整个表。 保护数据。 可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。 更改数据格式和表示。 视图可返回与底层表的表示和格式不同的数据。 视图的使用规则： 视图名必须为一且不能与其他视图或表重名。 对于可创建的视图数目没有限制。 创建视图，必须具有足够的访问权限（通常由数据库管理人员授予）。 视图可以嵌套，但允许的嵌套层数在不同的 DBMS 中有所不同。 嵌套视图、使用多个联结和过滤创建复杂的视图都会使性能下降。在产品环境中使用之前，应该对其进行全面测试。 许多 DBMS 禁止在视图查询中使用 ORDER BY 子句。 有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。 视图不能索引，也不能有关联的触发器或默认值。 有些 DBMS 把视图作为只读的查询（不能将数据写回底层表，如 SQLite）。 有些 DBMS 禁止对视图中的行进行插入或更新后，该行不再属于该视图的操作。 默认情况下，如果删除视图中的某行的某列后，可能会导致该行不属于该视图。但是某些 DBMS 会防止这种情况发生。 CREATE VIEW 创建视图 使用 CREATE VIEW 语句创建视图，通常包含两部分： 视图名； SELECT 查询语句。 视图的用途： 利用视图简化复杂的联结： CREATE VIEW view_name AS SELECT filed1, filed2, ... FROM table1, table2, ... WHERE condition1; 用视图重新格式话检索出的数据： -- filed1, filed2, ... 指需要重命名的字段 ALTER VIEW view_name AS SELECT filed1 AS alias1, filed2 AS alias2, ... FROM tab_name; 用视图过滤不想要的数据。 一般创建的视图都不会绑定特定的数据，这会提高视图的可重用性。 从视图检索数据时如果使用了一条 WHERE 子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。 DROP VIEW 删除视图 通过 DROP VIEW 删除视图（仅删除视图的定义，视图中并包含真实的数据）： DROP VIEW view_name; 索引 索引通过排序数据以加快搜索和排序操作的速度。 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。 索引数据可能要占用大量的存储空间。 用户无法看到索引。 并非所有数据都适合做索引。 索引用于数据过滤和数据排序。如果经常以某种特定的顺序排序数据，则该数据可能适合做索引。 可以在索引中定义多个列。这样的索引仅在以这个列组合排序时有用。 CREATE INDEX 创建索引 索引使用 CREATE INDEX 语句创建（不同的 DBMS 创建索引的语句变化很大）。 创建一个允许使用重复值的索引： CREATE INDEX index_name ON tab_name (column1, column2, ...); 创建唯一索引（不允许两个行拥有相同的索引值）： CREATE INDEX index_name ON tab_name (column1, column2, ...); 索引必须唯一命名。 DROP INDEX 删除索引 MySQL: ALTER TABLE tab_name DROP INDEX index_name; MS Access： DROP INDEX index_name ON tab_name; MS SQL Server： DROP INDEX tab_name.index_name; DB2 / Oracle： DROP INDEX index_name; ","link":"https://linna-cy.github.io/old-blog/SQL语句/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://linna-cy.github.io/old-blog/hello-gridea/"}]}