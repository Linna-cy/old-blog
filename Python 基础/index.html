<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Python 基础 | Linner&#39;s Blog</title>

<!-- 代码高亮： -->
<!-- <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"> -->
<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script> -->

<link rel="shortcut icon" href="https://linna-cy.github.io/old-blog/favicon.ico?v=1684376365462">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://linna-cy.github.io/old-blog/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<link rel="stylesheet" href="https://linna-cy.github.io/old-blog/media/icons/iconfont.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!-- <script src="media/scripts/index.js"></script> -->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
    <script>
      // 计算代码行数
      let pxToNumber = function(px) {
        // let num = Number(px.replace("px", ""));
        let num = parseFloat(px);

        return num;
      };
      let getRow = function(elem) {
          let style = window.getComputedStyle(elem, null);
          // let lineHeight = style.lineHeight === "normal" ? style.fontSize : style.lineHeight;
          let lineHeight = style.lineHeight;

          let height = style.height;
          let padding = style.padding;
          // let isiOS = /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent);
          let row = (pxToNumber(height)-pxToNumber(padding)) / pxToNumber(lineHeight);
          // if (isiOS) {
          //   row = pxToNumber(height) / pxToNumber(lineHeight);
          //   alert('ios!');
          // }
          // else {
          //   row = (pxToNumber(height)-pxToNumber(padding)) / pxToNumber(lineHeight);
          // }
          return parseInt(row);
      };
      
      // 获取行号文字
      let getRowNumString = function (row) {
          let num_str = new String('');
          for (let i = 1; i <= row; i++) {
              let num = new String(i.toString() + '\n');
              num_str = num_str + num;
          }
          return num_str;
      }

      // 指定代码块开启代码行号
      let setCodeNum = function(codeElem) {
          let pre = codeElem.parentElement;
          let span = document.createElement('span');
          span.innerText = getRowNumString(getRow(codeElem));
          let codeElemStyle = window.getComputedStyle(codeElem, null);
          span.style.display = 'inline-block';
          span.style.backgroundColor = "rgba(255,255,255,0)";
          span.style.color = 'rgba(255,255,255,0.4)';
          span.style.margin = 0;
          span.style.padding = 0;
          // span.style.borderRight = '1px #fff solid';
          span.style.paddingRight = 4;
          span.style.userSelect = 'none';
          span.style.textAlign = 'center';
          span.className = 'code-num';

          span.style.font = codeElemStyle.font;
          // span.style.height = codeElemStyle.height;
          span.style.paddingLeft = codeElemStyle.paddingRight;
          span.style.borderTopLeftRadius = codeElemStyle.borderTopRightRadius;
          span.style.borderBottomLeftRadius = codeElemStyle.borderBottomRightRadius;
          span.style.paddingTop = codeElemStyle.paddingTop;

          pre.style.display = 'flex';
          pre.style.overflowX = 'hidden';

          codeElem.style.borderTopLeftRadius = 0;
          codeElem.style.borderBottomLeftRadius = 0;
          codeElem.style.marginLeft = 0;
          codeElem.style.paddingLeft = span.style.paddingRight;
          codeElem.style.overflowX = 'auto';
          codeElem.style.display = 'inline-block';
          pre.insertBefore(span, codeElem);
      }

      // 设置代码块开启代码行号
      let setCodeAllNum = function() {
          let codeElems = document.querySelectorAll('pre > code');
          for (let i = 0; i < codeElems.length; i++) {
              codeElems[i].parentElement.className = 'code-pre';
              setCodeNum(codeElems[i]);
          }
      }
    </script>
</head>
<body>
<div class="main gt-bg-theme-color-first post-main">
    <!-- <div class="top">
    <span id="go-top" class="iconfont icon-shangxiazuoyouTriangle17"></span>
</div>
<script>
    let goTop = document.getElementById("go-top");
    let goTopDisplay = function () {
        let height = document.documentElement.scrollTop 
                    || document.body.scrollTop
        if (height >= (document.body.clientHeight || document.documentElement.clientHeight) * 0.8) {
            goTop.style.display = "block"
        } else {
            goTop.style.display = "none"
        }
        goTop.focus();
    }
    window.onscroll = goTopDisplay;
    window.onload = goTopDisplay;
    window.onresize = goTopDisplay;
    goTop.onclick = function () {
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }
</script> -->
    <nav class="navbar navbar-expand-lg" id="navbar">
    <a class="navbar-brand" href="/">
        <!-- <img class="user-avatar" src="/images/avatar.png" alt="头像"> -->
        <img class="site-icon" src="https://linna-cy.github.io/old-blog/images/favicon.png" alt="icon">
        <div class="site-name gt-c-content-color-first">
            Linner&#39;s Blog
        </div>
    </a>

    <div id="to-top" style="flex: 1; height: 100%;"></div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    <span class="iconfont icon-zhuye"></span>
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    <span class="iconfont icon-guidang"></span>
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    <span class="iconfont icon-biaoqian"></span>
                    标签
                </a>
                
            </div>
            
            <!-- <div class="nav-item" id="toc">
                <a class="menu gt-a-link">
                    <span class="iconfont icon-mulu"></span>
                    目录
                </a>
            </div> -->
            <!-- <div class="nav-item" id="to-top">
                <a href="#top" class="menu gt-a-link">
                    <span class="iconfont icon-fanhuidingbu"></span>
                    返回顶部
                </a>
            </div> -->
        </div>
        <!-- 搜索框 -->
        <!-- <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1684376365462"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 7px; left: 10px;"></i>
            </form>
        </div> -->
        <div class="search-box">
            <i class="fas fa-search gt-c-content-color-first"></i>
            <form id="gridea-search-form" data-update="1684376365462"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'flex';
        } else {
            element.style.display = 'none';
        }
    }

    // 自动显示目录项
    // let toc = document.getElementById('toc');
    // let isPost = document.getElementById('isPost');
    // if (isPost == null) {
    //     toc.style.display = 'none';
    // }
    // else {
    //     toc.style.display = 'block';
    // }

    // toc.onclick = () => {

    // }

    // 点击导航栏转到页面顶部
    let toTop = document.getElementById("to-top");
    toTop.onclick = function () {
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }

    // let goTopDisplay = function () {
    //     let height = document.documentElement.scrollTop 
    //                 || document.body.scrollTop
    //     if (height >= (document.body.clientHeight || document.documentElement.clientHeight) * 0.8) {
    //         navbar.style.position = "fixed !important"
    //     } else {
    //         navbar.style.position = "static !important"
    //     }
    // }
    // window.onscroll = goTopDisplay;
    // window.onload = goTopDisplay;
    // window.onresize = goTopDisplay;
</script>


    <div id="background" class="background" style="background-image: url(https://gitcode.net/qq_22182345/myfiles/-/raw/master/img/4kcityscape.jpg);">
        <div class="post-header">
          <h2 class="post-title">
            Python 基础
          </h2>
          <div class="post-info">
            <span class="meta-item pc-show">
              <!-- icon -->
              <span class="language" data-lan="publish">发布于</span>
              <span class="publish-time">2022-01-12</span>
              <span class="post-meta-divider pc-show">|</span>
            </span>
            
            <span class="meta-item">
              <!-- icon -->
              <span class="pc-show language" data-lan="category-in">标签:</span>
               
              <a href="https://linna-cy.github.io/old-blog/G0NSJyfWTt/">
                <span>#Python </span>
              </a>
               
            </span>
            <span class="post-meta-divider">|</span>
            
            <span class="meta-item">
              <!-- icon -->
              <span
                >98<span class="language" data-lan="minute"
                  >分钟</span
                ></span
              >
            </span>
            <span class="meta-item">
              <span class="post-meta-divider">|</span>
              <!-- icon -->
              <span
                >23606<span class="pc-show language" data-lan="words"
                  >字数</span
                ></span
              >
            </span>
          </div>
        </div>
    </div>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <div class="post-content">
                    <!-- <div id="toc-div">
                        <h1>目录</h1>
                        <ul class="markdownIt-TOC">
<li><a href="#python-%E8%AF%AD%E6%B3%95">Python 语法</a>
<ul>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC">变量的赋值</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">代码规范</a></li>
</ul>
</li>
<li><a href="#%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">标准数据类型</a>
<ul>
<li><a href="#number%E7%B1%BB%E5%9E%8B">Number类型</a>
<ul>
<li><a href="#%E6%95%B0%E5%AD%97%E5%87%BD%E6%95%B0">数字函数</a></li>
</ul>
</li>
<li><a href="#string%E7%B1%BB%E5%9E%8B">String类型</a>
<ul>
<li><a href="#%E8%BD%AC%E4%B9%89%E7%AC%A6">转义符</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2">格式化字符串</a></li>
<li><a href="#f-string">f-string</a></li>
<li><a href="#strformat">str.format()</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95">字符串方法</a></li>
<li><a href="#byte%E6%A0%B7%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2">byte样式字符串</a></li>
</ul>
</li>
<li><a href="#list">List</a>
<ul>
<li><a href="#%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95">列表方法</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F">列表推导式</a></li>
</ul>
</li>
<li><a href="#tuple">Tuple</a></li>
<li><a href="#set">Set</a>
<ul>
<li><a href="#%E9%9B%86%E5%90%88%E6%96%B9%E6%B3%95">集合方法</a></li>
</ul>
</li>
<li><a href="#dictionary">Dictionary</a>
<ul>
<li><a href="#%E5%AD%97%E5%85%B8%E6%96%B9%E6%B3%95">字典方法</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C">函数操作</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">数据类型转换</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C">其他操作</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a>
<ul>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">比较（关系）运算符</a></li>
<li><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></li>
<li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="#%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6">成员运算符</a></li>
<li><a href="#%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6">身份运算符</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">运算符优先级</a></li>
</ul>
</li>
<li><a href="#if%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6">if条件控制</a>
<ul>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符</a></li>
</ul>
</li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">循环语句</a>
<ul>
<li><a href="#while%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF">while条件循环</a></li>
<li><a href="#for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86">for循环遍历</a>
<ul>
<li><a href="#%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7">遍历技巧</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F-2">列表推导式</a></li>
</ul>
</li>
<li><a href="#break-and-continue">break and continue</a></li>
<li><a href="#pass%E8%AF%AD%E5%8F%A5">pass语句</a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8">迭代器与生成器</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%BF%AD%E4%BB%A3%E5%99%A8">创建迭代器</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E7%BB%93%E6%9D%9F%E6%A0%87%E5%BF%97">迭代结束标志</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0">参数</a></li>
<li><a href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">lambda匿名函数</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a>
<ul>
<li><a href="#%E5%8C%85">包</a></li>
<li><a href="#import%E8%AF%AD%E5%8F%A5">import语句</a></li>
<li><a href="#from-import%E8%AF%AD%E5%8F%A5">from ... import语句</a></li>
<li><a href="#from-import-as%E8%AF%AD%E5%8F%A5">from ... import ... as语句</a></li>
<li><a href="#__name__-%E5%B1%9E%E6%80%A7">__name__ 属性</a></li>
<li><a href="#dir-%E5%87%BD%E6%95%B0">dir() 函数</a></li>
</ul>
</li>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">输入输出</a>
<ul>
<li><a href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA">标准输出</a></li>
<li><a href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5">标准输入</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6">读写文件</a></li>
</ul>
</li>
<li><a href="#os%E6%A8%A1%E5%9D%97">os模块</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8">错误和异常</a>
<ul>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a>
<ul>
<li><a href="#tryexcept">try/except</a></li>
<li><a href="#tryexcept-else">try/except ... else</a></li>
<li><a href="#try-finally">try-finally</a></li>
</ul>
</li>
<li><a href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">抛出异常</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">用户自定义异常</a></li>
<li><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E6%B8%85%E7%90%86%E8%A1%8C%E4%B8%BA">预定义清理行为</a></li>
<li><a href="#assert-%E6%96%AD%E8%A8%80">assert 断言</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>
<ul>
<li><a href="#%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1">类定义和类对象</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%B1%BB">创建类</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">创建实例对象</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">访问对象属性</a></li>
<li><a href="#__init__-%E5%92%8Cself">__init__() 和self</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E5%80%BC">修改属性值</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a>
<ul>
<li><a href="#%E5%A4%9A%E7%BB%A7%E6%89%BF">多继承</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">方法重写</a></li>
<li><a href="#%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E">子类继承父类构造函数说明</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">类的私有属性与私有方法</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E4%B8%93%E6%9C%89%E6%96%B9%E6%B3%95">类的专有方法</a>
<ul>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">全局变量和局部变量</a></li>
<li><a href="#global%E5%92%8Cnonlocal">global和nonlocal</a></li>
</ul>
</li>
</ul>

                        <hr>
                    </div> -->
                    
                        <h1>目录</h1>
                        <ul class="markdownIt-TOC">
<li><a href="#python-%E8%AF%AD%E6%B3%95">Python 语法</a>
<ul>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC">变量的赋值</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">代码规范</a></li>
</ul>
</li>
<li><a href="#%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">标准数据类型</a>
<ul>
<li><a href="#number%E7%B1%BB%E5%9E%8B">Number类型</a>
<ul>
<li><a href="#%E6%95%B0%E5%AD%97%E5%87%BD%E6%95%B0">数字函数</a></li>
</ul>
</li>
<li><a href="#string%E7%B1%BB%E5%9E%8B">String类型</a>
<ul>
<li><a href="#%E8%BD%AC%E4%B9%89%E7%AC%A6">转义符</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2">格式化字符串</a></li>
<li><a href="#f-string">f-string</a></li>
<li><a href="#strformat">str.format()</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95">字符串方法</a></li>
<li><a href="#byte%E6%A0%B7%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2">byte样式字符串</a></li>
</ul>
</li>
<li><a href="#list">List</a>
<ul>
<li><a href="#%E5%88%97%E8%A1%A8%E6%96%B9%E6%B3%95">列表方法</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F">列表推导式</a></li>
</ul>
</li>
<li><a href="#tuple">Tuple</a></li>
<li><a href="#set">Set</a>
<ul>
<li><a href="#%E9%9B%86%E5%90%88%E6%96%B9%E6%B3%95">集合方法</a></li>
</ul>
</li>
<li><a href="#dictionary">Dictionary</a>
<ul>
<li><a href="#%E5%AD%97%E5%85%B8%E6%96%B9%E6%B3%95">字典方法</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C">函数操作</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">数据类型转换</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C">其他操作</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a>
<ul>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">比较（关系）运算符</a></li>
<li><a href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">赋值运算符</a></li>
<li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="#%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6">成员运算符</a></li>
<li><a href="#%E8%BA%AB%E4%BB%BD%E8%BF%90%E7%AE%97%E7%AC%A6">身份运算符</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">运算符优先级</a></li>
</ul>
</li>
<li><a href="#if%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6">if条件控制</a>
<ul>
<li><a href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符</a></li>
</ul>
</li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">循环语句</a>
<ul>
<li><a href="#while%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF">while条件循环</a></li>
<li><a href="#for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86">for循环遍历</a>
<ul>
<li><a href="#%E9%81%8D%E5%8E%86%E6%8A%80%E5%B7%A7">遍历技巧</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F-2">列表推导式</a></li>
</ul>
</li>
<li><a href="#break-and-continue">break and continue</a></li>
<li><a href="#pass%E8%AF%AD%E5%8F%A5">pass语句</a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8">迭代器与生成器</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%BF%AD%E4%BB%A3%E5%99%A8">创建迭代器</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E7%BB%93%E6%9D%9F%E6%A0%87%E5%BF%97">迭代结束标志</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0">参数</a></li>
<li><a href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">lambda匿名函数</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a>
<ul>
<li><a href="#%E5%8C%85">包</a></li>
<li><a href="#import%E8%AF%AD%E5%8F%A5">import语句</a></li>
<li><a href="#from-import%E8%AF%AD%E5%8F%A5">from ... import语句</a></li>
<li><a href="#from-import-as%E8%AF%AD%E5%8F%A5">from ... import ... as语句</a></li>
<li><a href="#__name__-%E5%B1%9E%E6%80%A7">__name__ 属性</a></li>
<li><a href="#dir-%E5%87%BD%E6%95%B0">dir() 函数</a></li>
</ul>
</li>
<li><a href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">输入输出</a>
<ul>
<li><a href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA">标准输出</a></li>
<li><a href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5">标准输入</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6">读写文件</a></li>
</ul>
</li>
<li><a href="#os%E6%A8%A1%E5%9D%97">os模块</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8">错误和异常</a>
<ul>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a>
<ul>
<li><a href="#tryexcept">try/except</a></li>
<li><a href="#tryexcept-else">try/except ... else</a></li>
<li><a href="#try-finally">try-finally</a></li>
</ul>
</li>
<li><a href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">抛出异常</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">用户自定义异常</a></li>
<li><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E6%B8%85%E7%90%86%E8%A1%8C%E4%B8%BA">预定义清理行为</a></li>
<li><a href="#assert-%E6%96%AD%E8%A8%80">assert 断言</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>
<ul>
<li><a href="#%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%AF%B9%E8%B1%A1">类定义和类对象</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%B1%BB">创建类</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">创建实例对象</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">访问对象属性</a></li>
<li><a href="#__init__-%E5%92%8Cself">__init__() 和self</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%E5%80%BC">修改属性值</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a>
<ul>
<li><a href="#%E5%A4%9A%E7%BB%A7%E6%89%BF">多继承</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99">方法重写</a></li>
<li><a href="#%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E">子类继承父类构造函数说明</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">类的私有属性与私有方法</a></li>
<li><a href="#%E7%B1%BB%E7%9A%84%E4%B8%93%E6%9C%89%E6%96%B9%E6%B3%95">类的专有方法</a>
<ul>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">全局变量和局部变量</a></li>
<li><a href="#global%E5%92%8Cnonlocal">global和nonlocal</a></li>
</ul>
</li>
</ul>

                        <hr>
                    
                    <h1 id="python-语法">Python 语法</h1>
<h2 id="注释">注释</h2>
<p>Python 的注释风格：</p>
<pre><code class="language-python"># 行注释

'''
块注释1
'''

&quot;&quot;&quot;
块注释2
&quot;&quot;&quot;
</code></pre>
<p>注释中的内容将不会被执行。</p>
<hr>
<h2 id="标识符">标识符</h2>
<ul>
<li>
<p>首字母必须是大写或小写的英文字母或者下划线 <code>_</code>。</p>
</li>
<li>
<p>其他部分由大写或小写的英文字母、数字和下划线组成。</p>
</li>
<li>
<p>大小写敏感（区分大小写）。</p>
</li>
</ul>
<p>Python3 中允许使用非 ASCII 标识符，即中文也可作为标识符：</p>
<pre><code class="language-python">&gt;&gt;&gt; 变量 = 5
&gt;&gt;&gt; print(变量)
5
</code></pre>
<hr>
<h2 id="关键字">关键字</h2>
<p>Python <strong>关键字</strong>（<strong>keyword</strong>）不能作为标识符使用，关键字又称<strong>保留字</strong>。</p>
<p>使用 <code>keyword</code> 模块输出 Python 的所有关键字：</p>
<pre><code class="language-python">&gt;&gt;&gt; import keyword
&gt;&gt;&gt; print(keyword.kwlist)
['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
</code></pre>
<hr>
<h2 id="变量的赋值">变量的赋值</h2>
<p>Python 中的变量并不需要声明，直接赋值后就可使用。还可以同时为多个变量赋值。</p>
<pre><code class="language-python">pai, e = 3.14, 2.72
a = b = c = 1
</code></pre>
<hr>
<h2 id="代码规范">代码规范</h2>
<p>Python 代码中的所有块都是使用空格缩进来表示。同一块中的所有语句都必须包含相同的缩进空格数，一般使用 4 个空格作为缩进，并且最好在代码编辑器中设置将 Tab 转化为空格。</p>
<pre><code class="language-python">total = 0
# 输出数字 1~9 的平方数
for n in range(1, 10):
    # 块的开始
    square = n * n
    total += square
    print(square)
  # 块的结束
# 输出数字 1~9 的所有平方数的总和
print(total)
</code></pre>
<p>缩进相同的一组语句构成一个代码块，或称之为代码组。</p>
<hr>
<p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行是程序代码的一部分，但并不是 Python 语法的一部分。空行的作用在于分割两段不同功能或含义的代码，便于日后代码的维护或重构，有无空行并不影响程序运行。</p>
<hr>
<p>反斜杠 <code>\</code> 作为续行符，表示下一行是上一行的延续。对于过长的语句，Python 使用反斜杠、换行再加上缩进来将长语句分为多行。</p>
<pre><code class="language-python">total = item_one + \
        item_two + \
        item_three
</code></pre>
<p>在 <code>[]</code>,<code>{}</code>, 或 <code>()</code> 中的多行语句，不需要使用反斜杠 <code>\</code> 来换行。</p>
<pre><code class="language-python">total = ['item_one', 'item_two', 'item_three',
        'item_four', 'item_five']
</code></pre>
<hr>
<p>Python 可以在同一行中使用多条语句，语句之间使用分号 <code>;</code> 分割。</p>
<pre><code class="language-python">&gt;&gt;&gt; str = '123'; print(str)
123
</code></pre>
<hr>
<h1 id="标准数据类型">标准数据类型</h1>
<p>Python 支持 6 种基本数据类型：</p>
<ul>
<li>
<p><strong>Number</strong> —— 数字类型</p>
</li>
<li>
<p><strong>String</strong> —— 字符串类型</p>
</li>
<li>
<p><strong>List</strong> —— 列表</p>
</li>
<li>
<p><strong>Tuple</strong> —— 元组</p>
</li>
<li>
<p><strong>Set</strong> —— 集合</p>
</li>
<li>
<p><strong>Dictionary</strong> —— 字典</p>
</li>
</ul>
<p>List、Dictionary、Set 是 Python 内置的数据结构。</p>
<p>Python 变量分为可变和不可变数据类型，以下是它们的定义：</p>
<ul>
<li>
<p><strong>不可变（immutable）数据类型</strong>：当该数据类型对应的变量的值发生了改变，它对应的内存地址也会发生改变（重新分配内存空间），如 Number、String、Tuple。即，数据中的元素不能被更改。</p>
<pre><code class="language-python"># 测试 Number 类型是否是不可变数据类型
n = 1      # 赋值
print(id(n), type(n))

n = 2      # 改变值
print(id(n), type(n))

# 可能输出：
# 1562536992 &lt;class 'int'&gt;
# 1562537024 &lt;class 'int'&gt;
</code></pre>
</li>
<li>
<p><strong>可变（mutable）数据类型</strong>：当该数据类型对应的变量的值发生了改变，它对应的内存地址不发生改变，如 List、Dictionary、Set。即，数据中的元素可以被更改。</p>
</li>
</ul>
<p>可迭代对象：List、Tuple、Set 、 Dictionary 和 String。</p>
<hr>
<h2 id="number类型">Number类型</h2>
<p>Python 支持的数字类型：</p>
<ul>
<li>
<p><strong>int</strong> —— 整数类型。</p>
</li>
<li>
<p><strong>float</strong> —— 浮点数类型（实数类型），如 <code>3.14</code>、<code>3E-2</code>。</p>
</li>
<li>
<p><strong>bool</strong> —— 布尔类型（<code>True</code> 和 <code>False</code>）。</p>
</li>
<li>
<p><strong>complex</strong> —— 复数类型，如 <code>1.1 + 2.2j</code>、<code>complex(a, b)</code>。</p>
</li>
</ul>
<p>Python 2 中有 long 型，Python 3 中没有。</p>
<hr>
<h3 id="数字函数">数字函数</h3>
<p>数字函数需要导入 math 模块：<code>import math</code></p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abs(x)</code></td>
<td>返回数字 <code>x</code>（可以是复数）的绝对值（内置函数，不用导入 math 模块）。</td>
</tr>
<tr>
<td><code>ceil(x)</code></td>
<td>返回数字 <code>x</code> 的上入整数（向上取整）。</td>
</tr>
<tr>
<td><code>cmp(x, y)</code></td>
<td>如果 <code>x &lt; y</code> 返回 <code>-1</code>，如果 <code>x == y</code> 返回 <code>0</code>，如果 <code>x &gt; y</code> 返回 <code>1</code>。
Python 3 已废弃，使用 <code>(x&gt;y)-(x&lt;y)</code> 替换。</td>
</tr>
<tr>
<td><code>exp(x)</code></td>
<td>返回 <code>e</code> 的 <code>x</code> 次幂 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">e^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>。</td>
</tr>
<tr>
<td><code>fabs(x)</code></td>
<td>返回数字 <code>x</code>（不能是复数）的绝对值。</td>
</tr>
<tr>
<td><code>floor(x)</code></td>
<td>返回数字的下舍整数（向下取整）。</td>
</tr>
<tr>
<td><code>log(x[, y])</code></td>
<td><code>log(x)</code> —— 返回 <code>x</code> 的自然对数；
<code>log(x, y)</code> —— 返回以 <code>y</code> 为基数的 <code>x</code> 的对数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mi>y</mi></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">\log_y{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746879999999999em;vertical-align:-0.380248em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252000000000025em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.380248em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span></span></span>。</td>
</tr>
<tr>
<td><code>log10(x)</code></td>
<td>返回以 10为基数的 <code>x</code> 的对数。</td>
</tr>
<tr>
<td><code>max(x1, x2,...)</code></td>
<td>返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td><code>min(x1, x2,...)</code></td>
<td>返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td><code>modf(x)</code></td>
<td>返回 <code>x</code> 的整数部分与小数部分，两部分的数值符号与 <code>x</code> 相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td><code>pow(x, y[, z])</code></td>
<td><code>pow(x, y)</code> —— <code>x**y</code> 运算后的值；
<code>pow(x, y, z)</code> —— 相当于 <code>pow(x, y) % z</code>。
通过内置方法调用，会把参数作为整型，而 math 会把参数转换为 float。</td>
</tr>
<tr>
<td><code>round(x [, n])</code></td>
<td>返回浮点数 <code>x</code> 的四舍五入值，如给出 <code>n</code> 值，则代表舍入到小数点后的位数。
<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td>
</tr>
<tr>
<td><code>sqrt(x)</code></td>
<td>返回数字 <code>x</code> 的平方根。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="string类型">String类型</h2>
<p>Python 的字符串（String）有以下特点：</p>
<ul>
<li>
<p>字符串常量可以使用单引号 <code>'</code> 和双引号 <code>&quot;</code> 指定。</p>
<pre><code class="language-python">&gt;&gt;&gt; str1 = 'Hello'
&gt;&gt;&gt; str2 = 'World'
&gt;&gt;&gt; print(str1, str2, '!')
Hello World !
&gt;&gt;&gt; str1 = '打印 &quot;双引号&quot; '
&gt;&gt;&gt; str1 += &quot;要用 '单引号' 将其括起来&quot;
&gt;&gt;&gt; print(str1)
打印 &quot;双引号&quot; 要用 '单引号' 将其括起来
</code></pre>
</li>
<li>
<p>使用三个引号可指定一个多行字符串常量。</p>
<pre><code class="language-python">&gt;&gt;&gt; str1 = &quot;&quot;&quot;这是一个段落，
... 可以由多行组成&quot;&quot;&quot;
&gt;&gt;&gt; print(str1)
这是一个段落，
可以由多行组成
</code></pre>
</li>
<li>
<p>转义符用 <code>\</code>  开头。单个反斜杠依然可以作为续行符。</p>
<pre><code class="language-python">&gt;&gt;&gt; str = 'str\
... ing'
&gt;&gt;&gt; print(str)
string
</code></pre>
</li>
<li>
<p>使用 <code>r</code> 或 <code>R</code> 可以让反斜杠不发生转义。这样的字符串被称为原始字符串。</p>
<pre><code class="language-python">&gt;&gt;&gt; print(r&quot;this is a line with \n&quot;)
this is a line with \n
</code></pre>
</li>
<li>
<p>按字面意义级联字符串。</p>
<pre><code class="language-python">&gt;&gt;&gt; print('this ' 'is ' 'string')
this is string
</code></pre>
</li>
<li>
<p>字符串可以用 <code>+</code> 运算符连接在一起，用 <code>*</code> 运算符重复。</p>
<pre><code class="language-python">&gt;&gt;&gt; print('this ' + 'is ' + 'string')
this is string
&gt;&gt;&gt; str = 'Hello World!' * 3
&gt;&gt;&gt; print(str)
Hello World!Hello World!Hello World!
</code></pre>
</li>
<li>
<p>有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。</p>
</li>
<li>
<p>字符串的截取的语法格式：<code>变量[头下标:尾下标:步长]</code>。字符串被截取后返回一个包含所需字符的新字符串。遵循<strong>左闭右开</strong>原则。<br>
<strong>尾下标</strong>从 <code>1</code> 开始。<br>
<strong>步长</strong>是指输出字符串中第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个字符后，接着输出第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mi mathvariant="normal">步</mi><mi mathvariant="normal">长</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n + 步长)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">步</span><span class="mord cjk_fallback">长</span><span class="mclose">)</span></span></span></span> 个字符，直至到达尾下标指定处。<br>
省略步长代表按字符串顺序输出，省略尾下标代表截取到字符串的最后一个字符，省略头下标代表从第一个字符开始截取。</p>
<pre><code class="language-python">&gt;&gt;&gt; str='123456789'
&gt;&gt;&gt; print(str[0])    # 输出字符串第一个字符
1
&gt;&gt;&gt; print(str[2:5])    # 输出从第三个开始到第五个的字符
345
&gt;&gt;&gt; print(str[0:-1])  # 输出第一个到倒数第二个的所有字符
12345678
&gt;&gt;&gt; print(str[2:])    # 输出从第三个开始后的所有字符
3456789
&gt;&gt;&gt; print(str[:3])    # 输出从第一个开始到第三个的字符
123
&gt;&gt;&gt; print(str[1:5:2])  # 输出从第二个开始到第五个且每隔一个的字符（步长为2）
24
&gt;&gt;&gt; print(str[:])    # 同时省略头下标和尾，创建了一个str的副本
</code></pre>
</li>
<li>
<p>字符串不能改变。即，字符串的切片不能被赋值。</p>
<pre><code class="language-python">&gt;&gt;&gt; str = 'string'
&gt;&gt;&gt; str[0] = 'S'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'str' object does not support item assignment
&gt;&gt;&gt; str = 'string'
&gt;&gt;&gt; print(str)
string
&gt;&gt;&gt; str = 'String'  # 修改字符串只能重新进行赋值
&gt;&gt;&gt; print(str)
String
</code></pre>
</li>
<li>
<p>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p>
</li>
</ul>
<p>在Python2中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 unicode 字符串。使用的语法是在字符串前面加上前缀 <code>u</code>。</p>
<p>在Python3中，所有的字符串都是 Unicode 字符串。</p>
<hr>
<h3 id="转义符">转义符</h3>
<table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\</code>（在代码行尾时）</td>
<td>续行符。</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠符号。</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>单引号。</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号。</td>
</tr>
<tr>
<td><code>\a</code></td>
<td>响铃
<code>print(&quot;\a&quot;)</code>执行后电脑有响声。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>退格（Backspace）。</td>
</tr>
<tr>
<td><code>\000</code></td>
<td>空。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>纵向制表符。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>横向制表符。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车，将 <code>\r</code> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <code>\r</code> 后面的内容完全替换完成。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>换页。</td>
</tr>
<tr>
<td><code>\yyy</code></td>
<td>八进制数，<code>y</code> 代表 0~7 的字符，如 <code>\012</code> 代表换行。</td>
</tr>
<tr>
<td><code>\xyy</code></td>
<td>十六进制数，以 <code>\x</code> 开头，<code>y</code> 代表的字符，例 <code>\x0a</code> 代表换行。</td>
</tr>
<tr>
<td><code>\other</code></td>
<td>其它的字符以普通格式输出。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="格式化字符串">格式化字符串</h3>
<p><code>print()</code> 函数能够使用 <code>%</code> 来进行格式化字符串的输出。例如：</p>
<pre><code class="language-python">&gt;&gt;&gt; print('%e' % 3.14)
3.140000e+00
</code></pre>
<p>字符串格式化符号：</p>
<table>
<thead>
<tr>
<th><strong>符  号</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%c</code></td>
<td>格式化字符及其 ASCII 码。</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>格式化字符串。</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>格式化整数。</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>格式化无符号整型。</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>格式化无符号八进制数。</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>格式化无符号十六进制数。</td>
</tr>
<tr>
<td><code>%X</code></td>
<td>格式化无符号十六进制数（大写）。</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>格式化浮点数字，可指定小数点后的精度。</td>
</tr>
<tr>
<td><code>%e</code> 或 <code>%E</code></td>
<td>用科学计数法格式化浮点数。
<code>%e</code> 中显示的字母为小写，<code>%E</code> 则为大写。</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>%f和%e的简写。</td>
</tr>
<tr>
<td><code>%G</code></td>
<td>%f 和 %E 的简写。</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>用十六进制数格式化变量的地址。</td>
</tr>
</tbody>
</table>
<p>格式化操作符辅助符号：</p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>定义宽度或者小数点精度。</td>
</tr>
<tr>
<td><code>-</code></td>
<td>用做左对齐。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>在正数前面显示加号。</td>
</tr>
<tr>
<td><code>&lt;sp&gt;</code></td>
<td>在正数前面显示空格。</td>
</tr>
<tr>
<td><code>#</code></td>
<td>在八进制数前面显示零 <code>'0'</code>，在十六进制前面显示 <code>'0x'</code> 或者 <code>'0X'</code>（取决于用的是 <code>'x'</code> 还是 <code>'X'</code>）。</td>
</tr>
<tr>
<td><code>0</code></td>
<td>显示的数字前面填充 <code>'0'</code> 而不是默认的空格。</td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>'%%'</code> 输出一个单一的 <code>'%'</code>。</td>
</tr>
<tr>
<td><code>(var)</code></td>
<td>映射变量(字典参数)。</td>
</tr>
<tr>
<td><code>m.n.</code></td>
<td>m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)。</td>
</tr>
</tbody>
</table>
<p>辅助符号在格式字符串 <code>%</code> 和符号中间使用，如需指定其它参数需要在字符串后的 <code>%</code> 使用括号 <code>()</code> 指定参数和要显示的值。如：</p>
<pre><code class="language-python">&gt;&gt;&gt; print('%*d' % (10, 2))
         2
</code></pre>
<hr>
<h3 id="f-string">f-string</h3>
<p>f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。f-string格式化字符串以 <code>f</code> 开头，后面跟着字符串，字符串中的表达式用大括号 <code>{}</code> 包起来，它会将变量或表达式计算后的值替换进去。</p>
<pre><code class="language-python">&gt;&gt;&gt; name = 'World!'
&gt;&gt;&gt; f'Hello {name}'  # 替换变量
'Hello World!'
&gt;&gt;&gt; f'{1+2}'         # 使用表达式
'3'
</code></pre>
<hr>
<h3 id="strformat">str.format()</h3>
<p><code>str.format()</code> 是用于格式化字符串的字符串方法。旧式的格式化最终会从该语言中移除，应该更多的使用 <code>str.format()</code>。</p>
<p><code>format()</code> 将 <code>str</code> 中的格式化字段（<code>{}</code> 及其里面包含的字符）替换为 <code>format()</code> 中的参数。它的用法如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; print('{} and {}'.format('a', 'b'))      # 按照参数顺序
a and b
&gt;&gt;&gt; print('{1} and {0}'.format('a', 'b'))    # 指定参数位置（从 0 开始）
b and a
&gt;&gt;&gt; print('{} and {b}'.format('a', b = 'b'))  # 指定关键字
a and b
</code></pre>
<p><code>!a</code>（使用 <code>ascii()</code>)，<code>!s</code>（使用 <code>str()</code>）和 <code>!r</code>（使用 <code>repr()</code>）可以用于在格式化某个值之前对其进行转化：</p>
<pre><code class="language-python">&gt;&gt;&gt; import math
&gt;&gt;&gt; print('常量 PI 的值近似为： {}。'.format(math.pi))
常量 PI 的值近似为： 3.141592653589793。
&gt;&gt;&gt; print('常量 PI 的值近似为： {!r}。'.format(math.pi))
常量 PI 的值近似为： 3.141592653589793。
</code></pre>
<p>可以使用 <code>:</code>，在右边指定输出形式，在 <code>:</code> 左边的是 <code>format()</code> 参数位置：</p>
<pre><code class="language-python">&gt;&gt;&gt; import math
&gt;&gt;&gt; print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
常量 PI 的值近似为 3.142。
</code></pre>
<p>在 <code>:</code> 后传入一个整数, 可以保证该域至少有这么多的宽度。</p>
<pre><code class="language-python">&gt;&gt;&gt; table = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; for name, number in table.items():
...     print('{0:10} ==&gt; {1:10d}'.format(name, number))
...
a          ==&gt;          1
b          ==&gt;          2
c          ==&gt;          3
</code></pre>
<p>传入一个字典，然后使用方括号 <code>[]</code> 来访问键值：</p>
<pre><code class="language-python">&gt;&gt;&gt; table = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; print('b: {0[b]:d}; a: {0[a]:d}; c: {0[c]:d}'.format(table))
b: 2; a: 1; c: 3
</code></pre>
<p>也可以通过在变量前使用 <code>**</code> 来实现相同的功能：</p>
<pre><code class="language-python">&gt;&gt;&gt; table = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; print('b: {b:d}; a: {a:d}; c: {c:d}'.format(**table))
b: 2; a: 1; c: 3
</code></pre>
<hr>
<h3 id="字符串方法">字符串方法</h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>str.capitalize()</code></td>
<td>将字符串的第一个字符转换为大写。</td>
</tr>
<tr>
<td><code>str.center(width[, fillchar])</code></td>
<td>返回一个指定的宽度 <code>width</code> 居中的字符串。
<code>fillchar</code> 为填充的字符，默认为空格。</td>
</tr>
<tr>
<td><code>str.count(sub[, start= 0, end=len(string)])</code></td>
<td>返回 <code>sub</code> 在 <code>str</code> 的指定范围里面出现的次数。
<code>sub</code> —— 搜索的子字符串。
<code>start</code> —— 字符串开始搜索的位置。默认为第一个字符（索引为 <code>0</code>）。
<code>end</code> —— 字符串中结束搜索的位置。默认为字符串的最后一个位置。</td>
</tr>
<tr>
<td><code>str.encode(encoding='UTF-8',errors='strict')</code></td>
<td>以 <code>encoding</code> 指定的编码格式编码字符串，如果出错默认报一个<code>ValueError</code> 的异常，除非 <code>errors</code> 指定的是 <code>'ignore'</code> 或者 <code>'replace'</code>。</td>
</tr>
<tr>
<td><code>bytes.decode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</code></td>
<td>以指定的编码格式解码 <code>bytes</code> 对象。
<code>encoding</code> —— 要使用的编码，默认为 <code>&quot;utf-8&quot;</code>。
<code>errors</code> —— 设置不同错误的处理方案。默认为 <code>&quot;strict&quot;</code>，意为编码错误引起一个 <code>UnicodeError</code>。 其他可能的值有 <code>&quot;ignore&quot;</code>，<code>&quot;replace&quot;</code>，<code>&quot;xmlcharrefreplace&quot;</code>，<code>&quot;backslashreplace&quot;</code> 以及通过 <code>codecs.register_error()</code> 注册的任何值。
Python3 中没有 <code>decode()</code> 方法，但可以使用 <code>bytes</code> 对象的 <code>decode()</code> 方法来解码给定的 <code>bytes</code> 对象，这个 <code>bytes</code> 对象可以由 <code>str.encode()</code> 来编码返回<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#i1UVu5eTHv7TvT3SWHoFXr" title="↩">↩</a>。</td>
</tr>
<tr>
<td><code>str.endswith(suffix[, start=0, end=len(string)])</code></td>
<td>检查字符串指定范围是否以 <code>suffix</code> 结束，如果是，返回 <code>True</code>，否则返回 <code>False</code>。
<code>suffix</code> —— 可以是一个字符串或者是一个元素。
<code>start</code> —— 指定的开始位置。默认为字符串第一个字符（索引为 <code>0</code>）。
<code>end</code> —— 指定的结束位置。默认为字符串的最后一个字符。</td>
</tr>
<tr>
<td><code>str.expandtabs(tabsize=8)</code></td>
<td>把字符串 <code>str</code> 中的 Tab 符号 <code>\t</code> 转为空格。
<code>tabsize</code> —— Tab 符号的长度，默认为 8。</td>
</tr>
<tr>
<td><code>str.find(sub[, beg=0, end=len(str)])</code></td>
<td>检测 <code>sub</code> 是否包含在字符串 <code>str</code> 的指定范围中，如果包含则返回开始的索引值，否则返回 <code>-1</code>。
<code>sub</code> —— 字符串。
<code>beg</code> —— 指定的开始位置。默认为字符串第一个字符（索引为 <code>0</code>）。
<code>end</code> —— 指定的结束位置。默认为字符串的最后一个字符。</td>
</tr>
<tr>
<td><code>str.index(sub[, beg=0, end=len(string)])</code></td>
<td>同 <code>find()</code>方法一样，只不过如果 <code>sub</code> 不在字符串中会报一个异常。</td>
</tr>
<tr>
<td><code>str.isalnum()</code></td>
<td>如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isalpha()</code></td>
<td>如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 <code>True</code>, 否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isdigit()</code></td>
<td>如果字符串只包含数字则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.islower()</code></td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isnumeric()</code></td>
<td>如果字符串中只包含数字字符，则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isspace()</code></td>
<td>如果字符串中只包含空白，则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.istitle()</code></td>
<td>如果字符串是标题化的（见 <code>title()</code>），则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.isupper()</code></td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>str.join(sequence)</code></td>
<td>字符串 <code>str</code> 作为分隔符，将 <code>sequence</code> 中所有的元素（的字符串表示）合并为一个新的字符串。</td>
</tr>
<tr>
<td><code>len(string)</code></td>
<td>返回字符串长度。</td>
</tr>
<tr>
<td><code>str.ljust(width[, fillchar])</code></td>
<td>返回一个原字符串左对齐，并使用 <code>fillchar</code> 填充至长度 <code>width</code> 的新字符串，<code>fillchar</code> 默认为空格。如果指定的长度小于原字符串的长度则返回原字符串。</td>
</tr>
<tr>
<td><code>str.lower()</code></td>
<td>转换字符串中所有大写字符为小写。</td>
</tr>
<tr>
<td><code>str.lstrip([chars])</code></td>
<td>截掉字符串左边的空格或指定字符。
<code>chars</code> —— 指定截取的字符。</td>
</tr>
<tr>
<td><code>str.maketrans(intab, outtab)</code></td>
<td>创建字符映射的转换表。<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#mqWsc4jJBXazkgF45wd4Ym" title="↩">↩</a><code>intab</code> —— 字符串，表示需要转换的字符。
<code>outtab</code> —— 字符串表示转换的目标。</td>
</tr>
<tr>
<td><code>max(str)</code></td>
<td>返回字符串 <code>str</code> 中最大的字母。</td>
</tr>
<tr>
<td><code>min(str)</code></td>
<td>返回字符串 <code>str</code> 中最小的字母。</td>
</tr>
<tr>
<td><code>str.replace(old, new[, max])</code></td>
<td>将字符串中的 <code>old</code> 替换成 <code>new</code>，如果 <code>max</code> 指定，则替换不超过 <code>max</code> 次。</td>
</tr>
<tr>
<td><code>str.rfind(sub[, beg=0,end=len(string)])</code></td>
<td>类似于 <code>find()</code> 函数，不过是从右边开始查找。即，返回字符串最后一次出现的位置，如果没有匹配项则返回 <code>-1</code>。</td>
</tr>
<tr>
<td><code>str.rindex(sub[, beg=0, end=len(string)])</code></td>
<td>类似于 <code>index()</code>，不过是从右边开始。即，返回子字符串 <code>sub</code> 在字符串中最后出现的位置，如果没有匹配的字符串会报异常。</td>
</tr>
<tr>
<td><code>str.rjust(width[, fillchar])</code></td>
<td>返回一个原字符串右对齐，并使用 <code>fillchar</code>（默认空格）填充至长度 <code>width</code> 的新字符串。</td>
</tr>
<tr>
<td><code>str.rstrip([chars])</code></td>
<td>删除字符串末尾的指定字符 <code>chars</code>，默认为空格。</td>
</tr>
<tr>
<td><code>str.split([str1=&quot;&quot;, num=string.count(str1)])</code></td>
<td>以参数 <code>str1</code> 为分隔符截取字符串，如果 <code>num</code> 有指定值，则仅截取 <code>num+1</code> 个子字符串<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#aV1m8VHmVaQtoTLyZoCoTi" title="↩">↩</a>。</td>
</tr>
<tr>
<td><code>str.splitlines([keepends])</code></td>
<td>按照行（<code>'\r'</code>，<code>'\r\n'</code>，<code>\n'</code>）分隔，返回一个包含各行作为元素的列表。如果参数 <code>keepends</code> 为 <code>False</code>，返回的列表则不包含换行符；如果为 <code>True</code>，则保留换行符。</td>
</tr>
<tr>
<td><code>str.startswith(substr[, beg=0, end=len(string)])</code></td>
<td>检查字符串是否是以指定子字符串 <code>substr</code> 开头，是则返回 <code>True</code>，否则返回 <code>False</code>。如果 <code>beg</code> 和 <code>end</code> 指定值，则在指定范围内检查。</td>
</tr>
<tr>
<td><code>str.strip([chars])</code></td>
<td>在字符串上执行 <code>lstrip()</code> 和 <code>rstrip()</code>。即移除字符串头尾指定的字符 <code>chars</code>（默认为空格）。</td>
</tr>
<tr>
<td><code>str.swapcase()</code></td>
<td>将字符串中大写转换为小写，小写转换为大写。</td>
</tr>
<tr>
<td><code>str.title()</code></td>
<td>返回 “标题化” 的字符串，即转化为所有单词都是以大写开始，其余字母均为小写的形式。</td>
</tr>
<tr>
<td><code>str.translate(table[, deletechars=&quot;&quot;])</code></td>
<td>根据 <code>str</code> 给出的表（包含 256 个字符）转换 <code>str</code> 的字符，要过滤掉的字符放到 <code>deletechars</code> 参数中。</td>
</tr>
<tr>
<td><code>str.upper()</code></td>
<td>转换字符串中的小写字母为大写。</td>
</tr>
<tr>
<td><code>str.zfill (width)</code></td>
<td>返回长度为 <code>width</code> 的字符串，原字符串右对齐，前面填充 <code>0</code>。</td>
</tr>
<tr>
<td><code>str.isdecimal()</code></td>
<td>检查字符串是否只包含十进制字符（只存在于 <code>unicode</code> 对象。），如果是返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<p><code>encode()</code> 和 <code>decode()</code> 用法实例：</p>
<pre><code class="language-python">&gt;&gt;&gt; str = &quot;Hello World!&quot;;
&gt;&gt;&gt; str_utf8 = str.encode(&quot;UTF-8&quot;)
&gt;&gt;&gt; str_gbk = str.encode(&quot;GBK&quot;)
&gt;&gt;&gt; print(str)
Hello World!
&gt;&gt;&gt; print(&quot;UTF-8 编码：&quot;, str_utf8)
UTF-8 编码： b'Hello World!'
&gt;&gt;&gt; print(&quot;GBK 编码：&quot;, str_gbk)
GBK 编码： b'Hello World!'
&gt;&gt;&gt; print(&quot;UTF-8 解码：&quot;, str_utf8.decode('UTF-8','strict'))
UTF-8 解码： Hello World!
&gt;&gt;&gt; print(&quot;GBK 解码：&quot;, str_gbk.decode('GBK','strict'))
GBK 解码： Hello World!
</code></pre>
<p><code>maketrans()</code> 的用法：</p>
<pre><code class="language-python">&gt;&gt;&gt; intab = &quot;aeiou&quot;
&gt;&gt;&gt; outtab = &quot;12345&quot;
&gt;&gt;&gt; trantab = str.maketrans(intab, outtab)
&gt;&gt;&gt; str = &quot;this is string example....wow!!!&quot;
&gt;&gt;&gt; print (str.translate(trantab))
th3s 3s str3ng 2x1mpl2....w4w!!!
</code></pre>
<p><code>split()</code> 的用法：</p>
<pre><code class="language-python">&gt;&gt;&gt; str = &quot;this is string example....wow!!!&quot;
&gt;&gt;&gt; print (str.split( ))       # 以空格为分隔符
['this', 'is', 'string', 'example....wow!!!']
&gt;&gt;&gt; print (str.split('i',1))   # 以 i 为分隔符
['th', 's is string example....wow!!!']
&gt;&gt;&gt; print (str.split('w'))     # 以 w 为分隔符
['this is string example....', 'o', '!!!']
</code></pre>
<hr>
<h3 id="byte样式字符串">byte样式字符串</h3>
<p>在字符串前面加上字符 <code>b</code>，可以得到该字符串的字节类型对象：</p>
<pre><code class="language-python">b'Hello World!'
</code></pre>
<p>使用 16 进制 ASCII 码赋值：</p>
<pre><code class="language-python">&gt;&gt;&gt; b'\x48\x65\x6C\x6C\x20\x57\x6F\x72\x6C\x64\x21'
b'Hell World!'
&gt;&gt; b&quot;\x01\x02\x03&quot;
b'\x01\x02\x03'
</code></pre>
<p>Python 会自动将可读的部分按照转换为文字。如果数据是不可读的，则使用 16 进制来表示。</p>
<p>byte 对象的元素是字节：</p>
<pre><code class="language-python">&gt;&gt;&gt; bt = b'Hello World!'
&gt;&gt;&gt; bt[2]
108
</code></pre>
<p>可以使用 <code>bin()</code> 查看每个字节在内存中的存储方式：</p>
<pre><code class="language-python">&gt;&gt;&gt; bin(bt[2])
'0b1101100'
</code></pre>
<p>除字面量表示之外，还可以用 <code>bytes()</code> 函数来得到字节类型。</p>
<hr>
<h2 id="list">List</h2>
<p>列表（List）由一系列按特定顺序排列的元素组成，它是写在方括号 <code>[]</code> 之间、用逗号分隔开的元素列表。列表其实更像是 Python 中的线性数据结构的实现，它具有绝大多数常见的线性数据结构的操作。</p>
<ul>
<li>
<p>列表中元素的类型可以不相同，它支持数字，字符串，甚至可以包含列表（嵌套）。</p>
<pre><code class="language-python">&gt;&gt;&gt; list = [1, '2', 3.4, [5, 6], (7, 8), {9, 10}]
&gt;&gt;&gt; print(list)
[1, '2', 3.4, [5, 6], (7, 8), {9, 10}]
</code></pre>
</li>
<li>
<p>有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。</p>
</li>
<li>
<p>列表的截取的语法格式：<code>变量[头下标:尾下标:步长]</code>。遵循<strong>左闭右开</strong>原则。<br>
<strong>尾下标</strong>从 <code>1</code> 开始。<br>
<strong>步长</strong>是指输出字符串中第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个元素后，接着输出第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mi mathvariant="normal">步</mi><mi mathvariant="normal">长</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n + 步长)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">步</span><span class="mord cjk_fallback">长</span><span class="mclose">)</span></span></span></span> 个元素，直至到达尾下标指定处。<br>
省略尾下标代表截取到字符串的最后一个字符，省略头下标代表从第一个字符开始截取。</p>
<pre><code class="language-python">&gt;&gt;&gt; list = [1, '2', 3.4, [5, 6], (7, 8), {9, 10}]
&gt;&gt;&gt; print (list[0])        # 输出列表第一个元素
1
&gt;&gt;&gt; print (list[1:3])      # 从第二个开始输出到第三个元素
['2', 3.4]
&gt;&gt;&gt; print (list[2:])      # 输出从第三个元素开始的所有元素
[3.4, [5, 6], (7, 8), {9, 10}]
&gt;&gt;&gt; print(list[:])        # 同时省略头下标和尾，创建了一个list的副本
&gt;&gt;&gt; tinylist = [123, 'list']
&gt;&gt;&gt; print (list + tinylist)    # 连接列表
[1, '2', 3.4, [5, 6], (7, 8), {9, 10}, 123, 'list']
&gt;&gt;&gt; double = tinylist * 2    # 重复列表
&gt;&gt;&gt; print(double)
[123, 'list', 123, 'list']
&gt;&gt;&gt; print(list[::-1])      # 步长为-1，表示逆向
[{9, 10}, (7, 8), [5, 6], 3.4, '2', 1]
&gt;&gt;&gt; list[len(list):] = [6]    # 在列表末尾插入元素
&gt;&gt;&gt; print(list)
[1, '2', 3.4, [5, 6], (7, 8), {9, 10}, 6]
</code></pre>
</li>
<li>
<p>列表中的元素是可更改的，并且列表长度也是可改变的。List 内置了许多方法来支持这种特性。</p>
<pre><code class="language-python">&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; list[1] = 6
&gt;&gt;&gt; print(list)
[1, 6, 3]
</code></pre>
</li>
<li>
<p>列表可以用 <code>+</code> 运算符拼接，用 <code>*</code> 运算符重复。</p>
<pre><code class="language-python">&gt;&gt;&gt; list1 = [1, 2, 3]
&gt;&gt;&gt; list2 = [4, 5, 6]
&gt;&gt;&gt; list = list1 + list2
&gt;&gt;&gt; print(list)
[1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; list = list1 * 2
&gt;&gt;&gt; print(list)
[1, 2, 3, 1, 2, 3]
</code></pre>
</li>
</ul>
<p>虽然列表和字符串有一些特性很相似，但它们是两个完全不同的类型。</p>
<p>删除列表或列表元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; del list[3]
&gt;&gt;&gt; print(list)
[1, 2, 3]
</code></pre>
<hr>
<h3 id="列表方法">列表方法</h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>list.append(obj)</code></td>
<td>在列表末尾添加新的对象 <code>obj</code>，无返回值。相当于 <code>list[len(list):] = [x]</code></td>
</tr>
<tr>
<td><code>list.count(obj)</code></td>
<td>返回 <code>obj</code> 在列表中出现的次数。</td>
</tr>
<tr>
<td><code>list.extend(seq)</code></td>
<td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。
<code>seq</code> —— 元素列表，可以是列表、元组、集合、字典，若为字典，则仅会将键（key）作为元素依次添加至原列表的末尾。</td>
</tr>
<tr>
<td><code>list.index(x[, start[, end]])</code></td>
<td>从列表中找出某个值第一个匹配项的索引位置。如果没有找到对象则抛出异常。
<code>x</code>—— 查找的对象；
<code>start</code> —— 可选，查找的起始位置；
<code>end</code> —— 可选，查找的结束位置。</td>
</tr>
<tr>
<td><code>list.insert(index, obj)</code></td>
<td>将对象插入列表，无返回值。
<code>index</code> —— 对象 <code>obj</code> 需要插入的索引位置；
<code>obj</code> —— 要插入列表中的对象。</td>
</tr>
<tr>
<td><code>list.pop([index=-1])</code></td>
<td>移除列表中 <code>index</code> 指定的元素（默认最后一个元素），并且返回该元素的值。</td>
</tr>
<tr>
<td><code>list.remove(obj)</code></td>
<td>移除列表中值与 <code>obj</code> 相同的第一个匹配项，无返回值。</td>
</tr>
<tr>
<td><code>list.reverse()</code></td>
<td>反向列表中元素。</td>
</tr>
<tr>
<td><code>list.sort(key=None, reverse=False)</code></td>
<td>对原列表进行排序。
<code>key</code> —— 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序；↩
<code>reverse</code> —— 排序规则，<code>reverse = True</code> 降序， <code>reverse = False</code> 升序（默认）。</td>
</tr>
<tr>
<td><code>list.clear()</code></td>
<td>清空列表，类似于 <code>del list[:]</code>。</td>
</tr>
<tr>
<td><code>list.copy()</code></td>
<td>返回复制后的新列表，类似于 <code>list[:]</code>。</td>
</tr>
</tbody>
</table>
<p><code>list.sort()</code> 指定排序元素：</p>
<pre><code class="language-python"># 获取列表的第二个元素
def takeSecond(elem):
    return elem[1]

# 列表
random = [(2, 2), (3, 4), (4, 1), (1, 3)]
 
# 指定第二个元素排序
random.sort(key=takeSecond)
 
# 输出类别
print ('排序列表：', random)

# 输出：排序列表：[(4, 1), (2, 2), (1, 3), (3, 4)]
</code></pre>
<p>Python 列表的特性可以很方便地将其封装成其他线性数据结构。</p>
<hr>
<h3 id="列表推导式">列表推导式</h3>
<p>列表推导式是指在方括号 <code>[]</code> 中使用 <code>for</code> 语句生成一串序列，这个 <code>for</code> 语句可以有零到多个 <code>for</code> 或 <code>if</code> 子句。返回结果是一个根据表达从其后的 <code>for</code> 和 <code>if</code> 上下文环境中生成出来的列表。</p>
<pre><code class="language-python">&gt;&gt;&gt; [x**2 for x in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; [str(round(355/113, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
</code></pre>
<hr>
<h2 id="tuple">Tuple</h2>
<p>元组（tuple）与列表类似，不同之处在于元组的元素可修改。元组写在小括号 <code>()</code> 里，元素之间用逗号隔开。</p>
<ul>
<li>
<p>元素的类型可以不相同。</p>
</li>
<li>
<p>元组中只包含一个元素时，需要在元素后面添加逗号 <code>,</code> ，否则括号会被当作运算符使用。</p>
</li>
<li>
<p>有两种索引方式：从左往右以 0 开始，从右往左以 -1 开始。</p>
</li>
<li>
<p>列表的截取的语法格式：<code>变量[头下标:尾下标:步长]</code>。遵循<strong>左闭右开</strong>原则。</p>
</li>
<li>
<p>元组元素不可修改是指元组中每个元素的指向永远不变。<br>
无法对元组的元素进行增删操作，但并非所有类型的元素都不可修改。</p>
<ul>
<li>
<p>对于不可变数据类型的元素，的确不能修改。</p>
</li>
<li>
<p>对于可变数据类型的元素，可以按照其规则修改。</p>
<pre><code class="language-python">&gt;&gt;&gt; tuple = (1, [1, 2, 3])
&gt;&gt;&gt; print(tuple)
(1, [1, 2, 3])
&gt;&gt;&gt; tuple[1][0] = 2
&gt;&gt;&gt; print(tuple)
(1, [2, 2, 3])
</code></pre>
</li>
</ul>
</li>
<li>
<p>可以用 <code>+</code> 运算符拼接，用 <code>*</code> 运算符重复。</p>
</li>
</ul>
<p>元组的某些操作可以参照列表，除了增加和删除元素的操作。</p>
<hr>
<p>元组支持推导式：</p>
<pre><code class="language-python">&gt;&gt;&gt; tuple(x**2 for x in range(10))
(0, 1, 4, 9, 16, 25, 36, 49, 64, 81)
</code></pre>
<hr>
<h2 id="set">Set</h2>
<p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。集合的基本功能是进行成员关系测试和删除重复元素。可以使用大括号 <code>{}</code> 或者构造函数 <code>set()</code> 创建集合。</p>
<ul>
<li>
<p>集合是一个无序不重复元素的集。</p>
</li>
<li>
<p>元素的类型可以不相同。</p>
</li>
<li>
<p>元素是可更改的。</p>
</li>
<li>
<p>创建空集：<br>
使用不带参数的构造函数 <code>set()</code> 创建，不可使用 <code>{}</code> 创建（<code>{}</code> 代表空字典）。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = set()
&gt;&gt;&gt; print(s)
set()
</code></pre>
</li>
<li>
<p>不包含多余的重复元素。在集合中，不会多次出现的相同元素。</p>
</li>
<li>
<p>不可使用索引或截取等操作。</p>
</li>
<li>
<p>可以使用集合运算。</p>
<pre><code class="language-python">&gt;&gt;&gt; set1 = {1, 2, 3, 4, 5, 7}
&gt;&gt;&gt; set2 = {2, 4, 6, 7, 8}
&gt;&gt;&gt; print(set1 - set2)      # set1 和 set2 的差集
{1, 3, 5}
&gt;&gt;&gt; print(set1 | set2)      # set1 和 set2 的并集
{1, 2, 3, 4, 5, 6, 7, 8}
&gt;&gt;&gt; print(set1 &amp; set2)      # set1 和 set2 的交集
{2, 4, 7}
&gt;&gt;&gt; print(set1 ^ set2)      # set1 和 set2 的对称差集
{1, 3, 5, 6, 8}
</code></pre>
</li>
</ul>
<hr>
<p>集合支持推导式：</p>
<pre><code class="language-python">&gt;&gt;&gt; {x**2 for x in range(10)}
{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}
</code></pre>
<hr>
<p>集合的成员测试：</p>
<pre><code class="language-python">avengers = {'captain america', 'iron man',
            'thor', 'doctor strange', 'star-Lord',
             'hulk', 'black widow', 'black panther',
             'spider man'}

if 'spider man' in avengers:
    print('蜘蛛侠是复仇者')
else:
    print('蜘蛛侠不是复仇者')
if 'thanos' in avengers:
    print('灭霸是复仇者')
else:
    print('灭霸不是复仇者')
</code></pre>
<hr>
<h3 id="集合方法">集合方法</h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set.add()</code></td>
<td>为集合添加元素。</td>
</tr>
<tr>
<td><code>set.clear()</code></td>
<td>移除集合中的所有元素。</td>
</tr>
<tr>
<td><code>set.copy()</code></td>
<td>拷贝一个集合。</td>
</tr>
<tr>
<td><code>set.difference(set1, set2, ...)</code></td>
<td>返回集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>s</mi><mi>e</mi><mi>t</mi><mo>−</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>1</mn><mo>)</mo><mo>∩</mo><mo>(</mo><mi>s</mi><mi>e</mi><mi>t</mi><mo>−</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>2</mn><mo>)</mo><mo>∩</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">(set - set1)\cap(set - set2)\cap\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>。</td>
</tr>
<tr>
<td><code>set.difference_update(set1, set2, ...)</code></td>
<td>移除集合 <code>set</code> 中的元素，该元素在指定的集合 <code>set1, set2, ...</code> 也存在。
即，将集合 <code>set</code> 更新为集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>s</mi><mi>e</mi><mi>t</mi><mo>−</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>1</mn><mo>)</mo><mo>∩</mo><mo>(</mo><mi>s</mi><mi>e</mi><mi>t</mi><mo>−</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>2</mn><mo>)</mo><mo>∩</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">(set - set1)\cap(set - set2)\cap\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>。</td>
</tr>
<tr>
<td><code>set.discard(value)</code></td>
<td>删除集合 <code>set</code> 中指定的元素 <code>value</code>。
与 <code>remove()</code> 不同的是，如果 <code>value</code> 不存在 <code>set</code> 中，并不会发生错误。</td>
</tr>
<tr>
<td><code>set.intersection(set1, set2, ...)</code></td>
<td>返回集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mo>∩</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>1</mn><mo>∩</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>2</mn><mo>∩</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">set \cap set1 \cap set2 \cap \cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>。</td>
</tr>
<tr>
<td><code>set.intersection_update(set1, set2, ...)</code></td>
<td>将集合 <code>set</code> 更新为集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mo>∩</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>1</mn><mo>∩</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>2</mn><mo>∩</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">set \cap set1 \cap set2 \cap \cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>。</td>
</tr>
<tr>
<td><code>set1.isdisjoint(set2)</code></td>
<td>判断集合 <code>set1</code> 和 <code>set2</code> 是否包含相同的元素，如果没有返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>set1.issubset(set2)</code></td>
<td>判断集合 <code>set1</code> 是否是集合 <code>set2</code> 的子集。如果是，则返回 <code>True</code>；否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>set1.issuperset(set2)</code></td>
<td>判断集合 <code>set1</code> 是否是集合 <code>set2</code> 的父集。如果是，则返回 <code>True</code>；否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>set.pop()</code></td>
<td>随机移除元素，并返回该元素。</td>
</tr>
<tr>
<td><code>set.remove(item)</code></td>
<td>移除指定元素 <code>item</code>。如果 <code>item</code> 不存在 <code>set</code> 中，会发生错误。</td>
</tr>
<tr>
<td><code>set1.symmetric_difference(set2)</code></td>
<td>返回集合  <code>set1</code> 和 <code>set2</code> 的对称差集 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mn>1</mn><mo>⊕</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">set1 \oplus set2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span>。</td>
</tr>
<tr>
<td><code>set1.symmetric_difference_update(set2)</code></td>
<td>将集合 <code>set1</code> 更新为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mn>1</mn><mo>⊕</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">set1 \oplus set2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">2</span></span></span></span>。</td>
</tr>
<tr>
<td><code>set.union(set1, set2...)</code></td>
<td>返回集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi><mo>∪</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>1</mn><mo>∪</mo><mi>s</mi><mi>e</mi><mi>t</mi><mn>2</mn><mo>∪</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">set \cup set1 \cup set2 \cup \cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>。</td>
</tr>
<tr>
<td><code>set.update(added_set)</code></td>
<td>添加新的元素或集合到当前集合中。
<code>added_set</code> —— 可以是元素或集合。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="dictionary">Dictionary</h2>
<p>字典是一种映射类型，用 <code>{}</code> 标识，是一个无序的 <code>key:value</code> （键 - 值对）的集合。字典当中的元素是通过键来存取的，而不是通过偏移存取。字典还可以使用构造函数 <code>dict()</code> 创建。</p>
<pre><code class="language-python"># 一般方法：
dic = {
    'name':   'tom',
    'age':    20,
    'height': 185,    # cm
    'weight': 71      # kg
}
print(dic)
# 输出：{'name': 'tom', 'age': 20, 'height': 185, 'weight': 71}

# 构造函数：
# 1.
dic = dict(
    name =   'lucy',
    age =    18,
    height = 169,
    weight = 56
)
print(dic)
# 输出：{'name': 'lucy', 'age': 18, 'height': 169, 'weight': 56}
# 2.
dic = dict([
    ('name', 'jiessie'),
    ('age', 25),
    ('height', 178),
    ('weight', 63)
])
print(dic)
# 输出：{'name': 'jiessie', 'age': 25, 'height': 178, 'weight': 63}

# 使用 for 循环：
dic = {
    x: x**2 for x in (2, 4, 6)
}
print(dic)
# 输出：{2: 4, 4: 16, 6: 36}
</code></pre>
<p>更多构造字典的方法↩。</p>
<ul>
<li>
<p>键（key）必须使用不可变类型，且是唯一的。</p>
<pre><code class="language-python">&gt;&gt;&gt; dic = {1:20, 'a':50, (1, 2, 3):6}
&gt;&gt;&gt; print(dic)
{1: 20, 'a': 50, (1, 2, 3): 6}
&gt;&gt;&gt; print(dic[1])
20
&gt;&gt;&gt; print(dic['a'])
50
&gt;&gt;&gt; print(dic[(1, 2, 3)])
6
</code></pre>
</li>
<li>
<p>值（value）可以是任何类型的元素。</p>
</li>
<li>
<p>使用键作为索引。</p>
</li>
<li>
<p>使用 <code>in</code> 操作符判断键是否存在字典中，如 <code>key in dict</code> ，如果键在字典dict里返回 <code>True</code>，否则返回 <code>False</code>。<code>not in</code> 操作符与 <code>in</code> 相反。</p>
</li>
</ul>
<hr>
<h3 id="字典方法">字典方法</h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>radiansdict.clear()</code></td>
<td>删除字典内所有元素，无返回值。</td>
</tr>
<tr>
<td><code>radiansdict.copy()</code></td>
<td>返回一个字典的浅复制。</td>
</tr>
<tr>
<td><code>radiansdict.fromkeys(seq[, value])</code></td>
<td>创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值（可选）。</td>
</tr>
<tr>
<td><code>radiansdict.get(key, default=None)</code></td>
<td>返回指定键 <code>key</code> 的值，如果键不在字典中返回 <code>default</code> 设置的默认值。</td>
</tr>
<tr>
<td><code>radiansdict.items()</code></td>
<td>以列表返回一个视图对象，视图对象中的元素以键-值对 <code>(key, value)</code> 的形式显示。
视图对象不是列表，不支持索引，其中的元素是键-值对。字典的视图对象都是只读的，但字典改变，视图也会跟着变化。</td>
</tr>
<tr>
<td><code>radiansdict.keys()</code></td>
<td>返回一个只包含键的视图对象。</td>
</tr>
<tr>
<td><code>radiansdict.setdefault(key, default=None)</code></td>
<td>和 <code>get()</code> 类似，如果 <code>key</code> 存在于 <code>radiandict</code> 中，就返回其值；但如果 <code>key</code> 不存在于字典中，将会添加键并将值设为 <code>default</code>。</td>
</tr>
<tr>
<td><code>radiansdict.update(dict2)</code></td>
<td>把字典 <code>dict2</code> 的键-值对更新到 <code>dict</code> 里，无返回值。</td>
</tr>
<tr>
<td><code>radiansdict.values()</code></td>
<td>返回一个只包含值的视图对象。</td>
</tr>
<tr>
<td><code>radiansdict.pop(key[, default])</code></td>
<td>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。否则，返回 <code>default</code> 值。如果 <code>key</code> 不存在字典中，返回 <code>default</code> 值（<code>default</code> 值必须给出，否则会报错。</td>
</tr>
<tr>
<td><code>radiansdict.popitem()</code></td>
<td>随机返回并删除字典中的最后一对键和值 <code>(key, value)</code>。
如果字典已经为空，却调用了此方法，就报出 KeyError 异常。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="函数操作">函数操作</h2>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>len(obj)</code></td>
<td>返回对象的元素个数</td>
</tr>
<tr>
<td><code>max(x1[, x2[, x3[, ...]]])</code></td>
<td>返回参数中最大值，参数还可以是集合、列表或元组。</td>
</tr>
<tr>
<td><code>min(x1[, x2[, x3[, ...]]])</code></td>
<td>返回参数中最小值，参数还可以是集合、列表或元组。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="数据类型转换">数据类型转换</h2>
<p>将数据类型作为函数名即可进行数据类型的转换。以下内置的数据类型转换函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int(x, base = 10)</code></td>
<td>将 <code>x</code> 转换为一个整数。
<code>x</code> —— 字符串或数字；
<code>base</code> —— 基数（进制数），默认 10。</td>
</tr>
<tr>
<td><code>float(x = 0.0)</code></td>
<td>将 <code>x</code> 转换为一个浮点数。
<code>x</code> —— 字符串或数字，默认为 <code>0.0</code>。</td>
</tr>
<tr>
<td><code>complex(real[, imag])</code></td>
<td>创建一个值为 <code>real + imag * j </code> 的复数。
<code>real</code> —— 为字符串时不需要指定第二个参数，还可以为 int 或 float；
<code>imag</code> —— int、float。</td>
</tr>
<tr>
<td><code>str(object = '')</code></td>
<td>将对象 <code>object</code> 转换为字符串，默认为空字符串。</td>
</tr>
<tr>
<td><code>repr(object)</code></td>
<td>将对象 <code>object</code> 转换为表达式字符串。<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#7imkekufL7cP1iNPsFJUPW" title="↩">↩</a></td>
</tr>
<tr>
<td><code>eval(expression[, globals[, locals]])</code></td>
<td>用来执行字符串中的有效表达式，并返回表达式的值。
<code>expression</code> —— 表达式字符串；
<code>globals</code> —— 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象；
<code>locals</code> —— 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</td>
</tr>
<tr>
<td><code>tuple(iterable)</code></td>
<td>将序列 <code>iterable</code> 转换为一个元组。
<code>iterable</code> —— 可迭代对象，如列表、字典、元组等等。</td>
</tr>
<tr>
<td><code>list(seq)</code></td>
<td>将序列 <code>seq</code> 转换为一个列表。
<code>seq</code> —— 元组或字符串。</td>
</tr>
<tr>
<td><code>set([iterable])</code></td>
<td>将 <code>iterable</code> 转换为可变集合，默认创建空集。
<code>iterable</code> —— 可迭代对象。</td>
</tr>
<tr>
<td><code>dict(**kwarg)</code>、
<code>class dict(mapping, **kwarg) </code>、
<code>class dict(iterable, **kwarg)</code></td>
<td>创建一个字典，默认创建空集。<a href="https://www.wolai.com/jXMTD4hXeMQaPS4Rx4pcFg#fMV3hFyFYXDnjis1W11TRq" title="↩">↩</a><code>**kwargs</code> —— 关键字，如 <code>key=value</code>；
<code>mapping</code> —— 元素的容器；
<code>iterable</code> —— 可迭代对象。</td>
</tr>
<tr>
<td><code>frozenset([iterable])</code></td>
<td>将 <code>iterable</code> 转换为不可变集合，默认创建空集。
<code>iterable</code> —— 可迭代的对象。</td>
</tr>
<tr>
<td><code>chr(i)</code></td>
<td>将一个整数 <code>i</code>（<code>in rang(256)</code>）转换为一个字符。
返回值是当前整数对应的 ASCII 字符。</td>
</tr>
<tr>
<td><code>ord(c)</code></td>
<td>将一个字符 <code>c</code> 转换为它的整数值（ASCII 数值，或者 Unicode 数值）。
<code>c</code> —— 字符（长度为 1 的字符串）。
如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。</td>
</tr>
<tr>
<td><code>hex(x)</code></td>
<td>将整数 <code>x</code> 转换为一个十六进制字符串（以 <code>0x</code> 为前缀）。</td>
</tr>
<tr>
<td><code>oct(x)</code></td>
<td>将整数 <code>x</code> 转换为一个八进制字符串。
Python2.x 版本的 8 进制以 <code>0</code> 作为前缀表示；
Python3.x 版本的 8 进制以 <code>0o</code> 作为前缀表示。</td>
</tr>
</tbody>
</table>
<p><code>repr</code> 的用法：</p>
<pre><code class="language-python">&gt;&gt;&gt; dic = [1, 2, 3]
&gt;&gt;&gt; repr(dic)
'[1, 2, 3]'
</code></pre>
<p><code>dict()</code> 的用法：</p>
<pre><code class="language-python">&gt;&gt;&gt;dict()                         # 创建空字典
{}
&gt;&gt;&gt; dict(a='a', b='b', t='t')     # 传入关键字
{'a': 'a', 'b': 'b', 't': 't'}
&gt;&gt;&gt; dict(zip(['one', 'two', 'three'], [1, 2, 3]))   # 映射函数方式来构造字典
{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt; dict([('one', 1), ('two', 2), ('three', 3)])    # 可迭代对象方式来构造字典
{'one': 1, 'two': 2, 'three': 3}
</code></pre>
<hr>
<h2 id="其他操作">其他操作</h2>
<p>使用 Python 的 <code>type()</code> 函数查看变量的类型：</p>
<pre><code class="language-python">&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j
&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))
&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt;
</code></pre>
<p>使用 <code>isinstance</code> 判断数据类型是否正确：</p>
<pre><code class="language-python">&gt;&gt;&gt; a = 111
&gt;&gt;&gt; isinstance(a, int)
True
</code></pre>
<p><code>isinstance()</code> 和 <code>type()</code> 的区别在于：</p>
<ul>
<li>
<p><code>type()</code> 不会认为子类是一种父类类型。</p>
</li>
<li>
<p><code>isinstance()</code> 会认为子类是一种父类类型。即，子类和父类被认为是同一类型。</p>
</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; class A:
...     pass
... 
&gt;&gt;&gt; # B 是 A 的子类
&gt;&gt;&gt; class B(A):
...     pass
... 
&gt;&gt;&gt; isinstance(A(), A)
True
&gt;&gt;&gt; type(A()) == A 
True
&gt;&gt;&gt; isinstance(B(), A)
True
&gt;&gt;&gt; type(B()) == A
False
</code></pre>
<hr>
<p>Python3 中，bool 是 int 的子类，<code>True</code> 和 <code>False</code> 可以和数字相加。</p>
<pre><code class="language-python">&gt;&gt;&gt; True == 1
True
&gt;&gt;&gt; False == 0
True
</code></pre>
<p>可以通过 <code>is</code> 来判断：</p>
<pre><code class="language-python">&gt;&gt;&gt; True is 1
False
&gt;&gt;&gt; flag = True
&gt;&gt;&gt; flag is True
True
</code></pre>
<hr>
<p>使用 <code>del</code> 删除对象：</p>
<pre><code class="language-python">del var        # 删除一个对象
del var_1, var_2  # 删除多个对象
</code></pre>
<hr>
<p><code>print</code> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <code>end=&quot;&quot;</code>：</p>
<pre><code class="language-python">&gt;&gt;&gt; str1 = 'Hello '
&gt;&gt;&gt; str2 = 'World!'
&gt;&gt;&gt; print(str1); print(str2)
Hello
World!
&gt;&gt;&gt; print(str1, end = ''); print(str2)
Hello World!
</code></pre>
<hr>
<h1 id="运算符">运算符</h1>
<h2 id="算术运算符">算术运算符</h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>加
操作对象为字符串、列表或元组时，表示将两个对象拼接在一起。</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘
<code>a * b</code>，若 <code>a</code> 为字符串、列表或元组，<code>b</code> 为整数时，表示将 <code>b</code> 个 <code>a</code> 拼接在一起。</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂，如 <code>a**b</code> 返回 <code>a</code> 的 <code>b</code> 次方</td>
</tr>
<tr>
<td><code>//</code></td>
<td>整除，向下取整</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="比较关系运算符">比较（关系）运算符</h2>
<p>所有比较运算符返回 <code>1</code>（或 <code>True</code>）表示真，返回 <code>0</code>（或 <code>False</code>）表示假。</p>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>相等</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于
Python 3 已不支持 <code>&lt;&gt;</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于 - 返回x是否大于等于y。</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于 - 返回x是否小于等于y。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="赋值运算符">赋值运算符</h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加法赋值运算符</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减法赋值运算符</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘法赋值运算符</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除法赋值运算符</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取模赋值运算符</td>
</tr>
<tr>
<td><code>**=</code></td>
<td>幂赋值运算符</td>
</tr>
<tr>
<td><code>//=</code></td>
<td>取整除赋值运算符</td>
</tr>
<tr>
<td><code>:=</code></td>
<td>海象运算符，可在表达式内部为变量赋值，然后直接进行判断。<strong>Python3.8 版本新增运算符</strong>。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="位运算符">位运算符</h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explain</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>按位与运算符：
参与运算的两个值，如果两个相应位都为 1，则该位的结果为 1，否则为 0。</td>
</tr>
<tr>
<td><code>|</code></td>
<td>按位或运算符：
只要对应的两个二进位有一个为 1 时，结果位就为 1。</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或运算符：
当两对应的二进位相异时，结果为 1。</td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位取反运算符：
对数据的每个二进制位取反，即把 1 变为 0，把 0 变为 1。<code>~x</code> 类似于 <code>x-1</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移动运算符：
运算数的各二进位全部左移若干位，由 <code>&lt;&lt;</code> 右边的数指定移动的位数，高位丢弃，低位补 0。</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移动运算符：
把 <code>&gt;&gt;</code> 左边的运算数的各二进位全部右移若干位，<code>&gt;&gt;</code> 右边的数指定移动的位数。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="逻辑运算符">逻辑运算符</h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Expressions</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>and</code></td>
<td><code>x and y</code></td>
<td>布尔 “与”
如果 <code>x</code> 为 <code>False</code>，<code>x and y</code> 返回 <code>x</code> 的值，否则返回 <code>y</code> 的计算值。</td>
</tr>
<tr>
<td><code>or</code></td>
<td><code>x or y</code></td>
<td>布尔 “或”
如果 <code>x</code> 是 <code>True</code>，它返回 <code>x</code> 的值，否则它返回 <code>y</code> 的计算值。</td>
</tr>
<tr>
<td><code>not</code></td>
<td><code>not x</code></td>
<td>布尔 “非”
如果 <code>x</code> 为 <code>True</code>，返回 <code>False</code>；如果 <code>x</code> 为 <code>False</code>，它返回 <code>True</code>。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="成员运算符">成员运算符</h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>in</code></td>
<td>如果在指定的序列中找到值返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>not in</code></td>
<td>如果在指定的序列中没有找到值返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="身份运算符">身份运算符</h2>
<table>
<thead>
<tr>
<th><strong>Operators</strong></th>
<th><strong>Explains</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is</code></td>
<td>判断两个标识符是不是引用自一个对象。
<code>x is y</code>，类似 <code>id(x) == id(y)</code>。
如果引用的是同一个对象则返回 <code>True</code>，否则返回 <code>False</code></td>
</tr>
<tr>
<td><code>is not</code></td>
<td>判断两个标识符是不是引用自不同对象。
<code>x is not y</code>，类似 <code>id(a) != id(b)</code>。
如果引用的不是同一个对象则返回结果 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
</tbody>
</table>
<p><code>is</code> 和 <code>==</code> 的区别：</p>
<pre><code class="language-python">&gt;&gt;&gt;a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b is a 
True
&gt;&gt;&gt; b == a
True
&gt;&gt;&gt; b = a[:]
&gt;&gt;&gt; b is a
False
&gt;&gt;&gt; b == a
True
</code></pre>
<hr>
<h2 id="运算符优先级">运算符优先级</h2>
<p>优先级按从高到底排列：</p>
<table>
<thead>
<tr>
<th>Operators</th>
<th>Explains</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>**</code></td>
<td>指数</td>
</tr>
<tr>
<td><code>~</code> <code>+</code> <code>-</code></td>
<td>按位翻转，一元加号和减号（最后两个的方法名为 +@ 和 -@）</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td>
<td>乘，除，求余数和取整除</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>加法减法</td>
</tr>
<tr>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td>右移，左移运算符</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code> <code>|</code></td>
<td>按位异或，按位与</td>
</tr>
<tr>
<td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>比较运算符</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code></td>
<td>等于运算符</td>
</tr>
<tr>
<td><code>=</code> <code>%=</code> <code>/=</code> <code>//=</code> <code>-=</code> <code>+=</code> <code>*=</code> <code>**=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>is</code> <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code> <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>and</code> <code>or</code></td>
<td>逻辑运算符</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="if条件控制">if条件控制</h1>
<p><code>if</code> 语句的形式：</p>
<pre><code class="language-python">if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
</code></pre>
<p><code>if</code> 语句的条件通常由关系运算符或返回值为布尔值的语句组成，使用逻辑运算符在一条 <code>if</code> 语句中连接多个条件。</p>
<hr>
<h2 id="条件运算符">条件运算符</h2>
<p>Python 提供了条件运算符（三目运算符）：</p>
<pre><code class="language-python">statement_1 if condition else statement
</code></pre>
<ul>
<li>
<p>如果 <code>condition</code> 为 <code>True</code>，执行 <code>statement_1</code> 并且返回 <code>staement_1</code> 的结果。</p>
</li>
<li>
<p>如果 <code>condition</code> 为 <code>False</code>，执行 <code>statement_2</code> 并且返回 <code>statement_2</code> 的结果。</p>
</li>
</ul>
<hr>
<h1 id="循环语句">循环语句</h1>
<p>Python 有 <code>while</code> 和 <code>for</code> 两种循环语句。</p>
<hr>
<h2 id="while条件循环">while条件循环</h2>
<p><code>while</code> 循环的一般用法是，当指定条件成立时执行一次 <code>while</code> 后的代码块。</p>
<pre><code class="language-python">while condition:
    statements_block
</code></pre>
<p><code>while</code> 语句后可接 <code>else</code> 语句。当指定条件不成立时，执行一次 <code>while</code> 后面的 <code>else</code> 语句。</p>
<pre><code class="language-python">while condition:
    statements_block_1
else:
    statements_block_2
</code></pre>
<hr>
<h2 id="for循环遍历">for循环遍历</h2>
<p><code>for</code> 循环的一般用法是，遍历任何可迭代对象。每次循环，都会从指定的可迭代对象中选取一个赋给指定的变量。如此循环下去，直到遍历完指定的可迭代对象中所有元素。</p>
<pre><code class="language-python">for variables in sequence:
    statements_block
</code></pre>
<p><code>for</code> 语句后可接 <code>else</code> 语句。当指定的可迭代对象为空时，执行一次 <code>for</code> 后面的 <code>else</code> 语句。</p>
<pre><code class="language-python">for variable in sequence:
    statements_block_1
else:
    statements_block_2
</code></pre>
<hr>
<p><code>for</code> 循环经常与 <code>range()</code> 函数一起使用。当需要遍历数字序列时，可以使用 <code>range()</code> 函数生成数列。</p>
<pre><code class="language-python"># 输出数字 5~12
for i in range(5, 13):
    print(i, end=' ')

print('')    # 输出一个换行符
</code></pre>
<hr>
<h3 id="遍历技巧">遍历技巧</h3>
<p>在字典中遍历时，关键字和对应的值可以使用 <code>items()</code> 方法同时解读出来：</p>
<pre><code class="language-python">&gt;&gt;&gt; dict = {'one':1, 'two': 2, 'three': 3}
&gt;&gt;&gt; for key, val in dict.items():
...     print(key, ' = ', val)
...
one  =  1
two  =  2
three  =  3
</code></pre>
<p>在序列中遍历时，索引位置和对应值可以使用 <code>enumerate()</code> 函数同时得到：</p>
<pre><code class="language-python">&gt;&gt;&gt; for index, val in enumerate(['one', 'two', 'three']):
...     print(index, ': ', val)
...
0 :  one
1 :  two
2 :  three
</code></pre>
<p>同时遍历两个或更多的序列，可以使用 <code>zip()</code> 组合：</p>
<pre><code class="language-python">&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']
&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']
&gt;&gt;&gt; for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
</code></pre>
<p>反向遍历序列，可以调用 <code>reversed()</code> 函数：</p>
<pre><code class="language-python">&gt;&gt;&gt; for i in reversed(range(10)):
...     print(i, end = '')
...
9876543210
</code></pre>
<p>要按顺序遍历一个序列，使用 <code>sorted()</code> 函数返回一个已排序的序列，并不修改原值：</p>
<pre><code class="language-python">&gt;&gt;&gt; basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
&gt;&gt;&gt; for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
</code></pre>
<hr>
<h3 id="列表推导式-2">列表推导式</h3>
<p>列表推导式（又称列表解析式）的基本语法如下：</p>
<pre><code class="language-python">[val for val in sequence if_or_for_statement]
# if_or_for_statement是一个if判断语句或for循环
# 如果是if语句，那么只有条件位真时val才会在列表中
</code></pre>
<p>Example：</p>
<pre><code class="language-python">&gt;&gt;&gt; [x for x in range(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>列表推导式中的<code>for</code>语句和<code>if</code>语句是可嵌套的：</p>
<pre><code class="language-python">[x*y for x in range(1,5) if x &gt; 2 for y in range(1,4) if y &lt; 3]
</code></pre>
<p>上面语句的执行顺序是：</p>
<pre><code class="language-python">for x in range(1,5)
    if x &gt; 2
        for y in range(1,4)
            if y &lt; 3
                x*y
</code></pre>
<p>列表推导式除了<code>list</code>还可以被转化成其它对象：</p>
<pre><code class="language-python">&gt;&gt;&gt; (x for x in range(10))
&lt;generator object &lt;genexpr&gt; at 0x0000026F7A655BA0&gt;
&gt;&gt;&gt; tuple(x for x in range(10))
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
</code></pre>
<hr>
<h2 id="break-and-continue">break and continue</h2>
<ul>
<li>
<p><code>break</code> 语句 —— 跳出（终止）循环。不执行当前循环块中 <code>break</code> 语句以下的语句，并且将控制转移到当前循环语句的下一条语句。</p>
</li>
<li>
<p><code>continue</code> 语句 —— 进入下一轮循环。不执行当前循环块中 <code>continue</code> 语句以下的语句，并且将控制转义到循环语句的开头。</p>
</li>
</ul>
<p><code>break</code> 和 <code>continue</code> 在循环语句中使用。一般在循环中的 <code>if</code> 条件语句中使用。即，达到某个条件便结束或进入下一次循环。</p>
<hr>
<h2 id="pass语句">pass语句</h2>
<p><code>pass</code> 语句是空语句，即不执行任何操作。<code>pass</code> 是为了保持 Python 程序结构的完整性。</p>
<p><code>pass</code> 一般作为占位语句，当操作都在条件语句或循环语句中完成时，在语句块中使用 <code>pass</code> 占位。如：</p>
<pre><code class="language-python">if condition_1:
    pass

while condition_2:
    pass

for variable in sequence:
    pass
</code></pre>
<hr>
<h1 id="迭代器与生成器">迭代器与生成器</h1>
<h2 id="迭代器">迭代器</h2>
<p>迭代是一种访问集合元素的方式。迭代器是一个可以记住遍历位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</p>
<p>字符串、列表或元组对象都可用于创建迭代器。</p>
<pre><code class="language-python">&gt;&gt;&gt; list = [1, 2, 3, 4]
&gt;&gt;&gt; it = iter(list)     # 创建迭代器对象
&gt;&gt;&gt; print(next(it))    # 输出迭代器的下一个元素
1
&gt;&gt;&gt; print(next(it))
2
</code></pre>
<p>迭代器对象可以使用常规 <code>for</code> 语句进行遍历：</p>
<pre><code class="language-python">list = [1, 2, 3, 4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print(x, end = ' ')
</code></pre>
<p>使用 <code>next()</code> 迭代：</p>
<pre><code class="language-python">import sys         # 引入 sys 模块
 
list=[1, 2, 3, 4]
it = iter(list)    # 创建迭代器对象
 
while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
</code></pre>
<hr>
<h3 id="创建迭代器">创建迭代器</h3>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code> 。</p>
<ul>
<li>
<p><code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code>方法并通过 <code>StopIteration</code> 异常标识迭代的完成。</p>
</li>
<li>
<p><code>__next__()</code> 方法（Python 2 里是 <code>next()</code>）会返回下一个迭代器对象。</p>
</li>
</ul>
<pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)

i = 0
while i &lt; 10:
    print(next(myiter), end = ' ')
    i += 1

# 输出：1 2 3 4 5 6 7 8 9 10
</code></pre>
<hr>
<h3 id="迭代结束标志">迭代结束标志</h3>
<p><code>StopIteration</code> 异常用于标识迭代的完成，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。</p>
<pre><code class="language-python"># 迭代 10 次后停止
class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
 
for x in myiter:
  print(x, end = ' ')

# 输出：1 2 3 4 5 6 7 8 9 10
</code></pre>
<hr>
<h2 id="生成器">生成器</h2>
<p>在 Python 中，使用了 <code>yield</code> 的函数被称为生成器（generator），生成器是一个返回迭代器的函数，只能用于迭代操作。</p>
<p>在调用生成器运行的过程中，每次遇到 <code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code> 的值, 并在下一次执行 <code>next()</code> 方法时从当前位置继续运行。</p>
<pre><code class="language-python">import sys
 
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 1, 1, 0
    while True:
        if (counter &gt; n): 
            return
        yield a
        a, b = b, a + b
        counter += 1

f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
 
while True:
    try:
        print (next(f), end=&quot; &quot;)
    except StopIteration:
        sys.exit()

# 输出：1 1 2 3 5 8 13 21 34 55 89
</code></pre>
<hr>
<h1 id="函数">函数</h1>
<p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。</p>
<p>函数的定义形式：</p>
<pre><code class="language-python">def function_name(arguments):
    &quot;&quot;&quot;explain&quot;&quot;&quot;
    statements_block
    return [expression]
# end function_name
</code></pre>
<ul>
<li>
<p><code>explain</code> 是使用文档字符串存放的函数说明。</p>
</li>
<li>
<p><code>return</code> 代表一个函数的结束，并且返回一个值给调用方，这个值放在 <code>return</code> 后面，可以是具体的值也可以是一条有确切值的表达式。不带值或表达式的 <code>return</code> 相当于返回 <code>None</code>。当函数不需要返回值时，可以省略 <code>return</code>。</p>
</li>
</ul>
<p>调用一个函数时需要使用该函数名并根据其定义指定参数：</p>
<pre><code class="language-python">def function_name(arguments):
    &quot;&quot;&quot;explain&quot;&quot;&quot;
    statements_block
    return [expression]
# end function_name

function_name(arguments)
</code></pre>
<hr>
<h2 id="参数">参数</h2>
<ul>
<li>
<p><strong>不可变类型的参数传递</strong>：类似 C++ 的值传递。传递的只是参数的值，没有影响参数对象本身。如果在 <code>fun(a)</code> 内部修改 <code>a</code> 的值，则是新生成一个 <code>a</code> 的对象。即，修改参数之前函数内部参数的地址和函数外部参数的地址相同，一旦修改了变量，参数的地址将会发生变化。如 Number、String、Tuple。</p>
</li>
<li>
<p><strong>可变类型的参数传递</strong>：类似 C++ 的引用传递。如 <code>fun(la)</code>，则是将 <code>la</code> 真正的传过去，修改后 <code>fun</code> 外部的 <code>la</code> 也会受影响。无论是否对参数进行修改，参数地址都不会发生改变。如 List、Dictionary、Set。</p>
</li>
</ul>
<p>参数类型：</p>
<ul>
<li>
<p><strong>必须参数</strong>：须以正确的顺序传入函数。调用时，必须参数的数量必须和声明时一样。</p>
</li>
<li>
<p><strong>关键字参数</strong>：函数调用时使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<pre><code class="language-python">def func(a, b):
    print('a = ', a, 'b = ', b)
    return

func(b = 2, a = 1)
</code></pre>
</li>
<li>
<p><strong>默认参数</strong>：调用函数时，如果没有传递参数，则会使用默认参数。默认参数在定义函数时定义。</p>
<pre><code class="language-python">def func(a, b = 1)
  print('a = ', a, 'b = ', b)
    return

func(2)
</code></pre>
</li>
<li>
<p><strong>不定长参数</strong>：</p>
<ul>
<li>
<p>加了星号 <code>*</code> 的参数会以元组的形式导入，存放所有未命名的变量参数。</p>
<pre><code class="language-python">def func(atg1, *vartuple):
    print(atg1, vartuple)
    return

func(1, 2, 3)
# 输出：1 (2, 3)
</code></pre>
</li>
<li>
<p>加了两个星号 <code>**</code> 的参数会以字典的形式导入。</p>
<pre><code class="language-python">def func(atg1, **vartuple):
    print(atg1, vartuple)
    return

func(1, a = 2, b = 3)
# 输出：1 {'a': 2, 'b': 3}
</code></pre>
</li>
<li>
<p>如果参数单独出现星号 <code>*</code> 后的参数必须用关键字传入。</p>
<pre><code class="language-python">&gt;&gt;&gt; def f(a,b,*,c):
...     return a+b+c
... 
&gt;&gt;&gt; f(1,2,3)   # 报错
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: f() takes 2 positional arguments but 3 were given
&gt;&gt;&gt; f(1,2,c=3) # 正常
6
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>强制位置参数</strong>：Python3.8 新增了一个函数形参语法 <code>/ </code> 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<pre><code class="language-python">def f(a, b, /, c):
    print(a, b, c)
    return

# 形参 a 和 b 必须使用指定位置参数，c 可以是位置形参或关键字形参
f(1, 2, c = 3)
</code></pre>
</li>
</ul>
<hr>
<h2 id="lambda匿名函数">lambda匿名函数</h2>
<p>Python 使用 <code>lambda</code> 来创建匿名函数。</p>
<ul>
<li>
<p><code>lambda</code> 的主体是一个表达式，而不是一个代码块（比 <code>def</code> 简单很多）。仅仅能在 <code>lambda</code> 表达式中封装有限的逻辑进去。</p>
</li>
<li>
<p><code>lambda</code> 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</p>
</li>
<li>
<p>虽然 <code>lambda</code> 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</p>
</li>
</ul>
<p><code>lambda</code> 函数的语法：</p>
<pre><code class="language-python">lambda [arg1 [,arg2,.....argn]]: expression
</code></pre>
<p>用法：</p>
<pre><code class="language-python">&gt;&gt;&gt; sum = lambda arg1, arg2: arg1 + arg2
&gt;&gt;&gt; sum(1, 2)
3
</code></pre>
<hr>
<h1 id="模块">模块</h1>
<p>模块是一个包含函数定义和变量的文件，其后缀名是 <code>.py</code>。</p>
<ul>
<li>
<p>模块可以被别的程序引入，以使用该模块中的函数等功能。</p>
</li>
<li>
<p>Python 标准库也是一个个内置的模块。<br>
这些模块会根据不同的操作系统进行不同的配置，不同的操作系统可能会有一些不同的模块。</p>
</li>
<li>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用，可以使用 <code>dir()</code> 查看。<br>
在导入模块后，可以通过 <code>modname.itemname</code> 这样的表示法来访问模块内的函数。</p>
</li>
<li>
<p>模块可以被导入其他模块。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
</li>
<li>
<p>模块除了方法定义，还可以包括可执行的代码。<br>
这些代码一般用来初始化这个模块，只有在第一次被导入时才会被执行。</p>
</li>
</ul>
<hr>
<h2 id="包">包</h2>
<p>包是一种管理 Python 模块命名空间的形式，采用 “点模块名称”。如一个模块的名称是 <code>A.B</code>， 那么他表示一个包 <code>A</code> 中的子模块 <code>B</code>。优点是不用担心不同模块之间的名称冲突。</p>
<p>包结构实例：</p>
<pre><code class="language-纯文本">sound/                          顶层包
      __init__.py               初始化 sound 包
      formats/                  文件格式转换子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  声音效果子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  filters 子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</code></pre>
<p>包还提供一个额外的属性 <code>__path__</code>。这是一个目录列表，里面每一个包含的目录都有为这个包服务的 __init__.py，得在其他 __init__.py 被执行前定义。可以修改这个变量，用来影响包含在包里面的模块和子包。这个功能并不常用，一般用来扩展包里面的模块。</p>
<hr>
<h2 id="import语句">import语句</h2>
<pre><code class="language-python">import module1[, module2[,... moduleN]
</code></pre>
<p>当解释器遇到 <code>import</code> 语句，如果模块在当前的搜索路径就会被导入。<code>import</code> 命令一般放在脚本顶端，如：</p>
<pre><code class="language-python">#!/usr/bin/python3
# Filename: support.py
 
def print_hello():
    print ('Hello World！')
    return
</code></pre>
<pre><code class="language-python">#!/usr/bin/python3
# Filename: test.py
 
# 导入模块
import hello
 
# 使用 . 运算符调用模块中的函数
hello.print_hello()
</code></pre>
<p>对于同一个模块，无论执行了多少次 <code>import</code> 语句，一个模块只会被导入一次。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表，由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块（很像环境变量）。搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在 <code>sys</code> 模块中的 <code>path</code> 变量。</p>
<p>以 Windows 系统为例（在 VS2017 中安装的 Python3）：</p>
<pre><code class="language-python">&gt;&gt;&gt; import sys
&gt;&gt;&gt; print(sys.path)
['', 'C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\Python36_64\\python36.zip', 'C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\Python36_64\\DLLs', 'C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\Python36_64\\lib', 'C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\Python36_64', 'C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\Python36_64\\lib\\site-packages']
</code></pre>
<p><code>sys.path</code> 输出是一个列表，其中第一项是空串，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），即我们执行 Python 解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>如果要引入一些不在搜索路径中的模块，可以在脚本中修改 <code>sys.path</code>。</p>
<p>如果要经常使用一个模块中的函数，可以赋给它一个本地名称：</p>
<pre><code class="language-python">import module

func = module.func
func(arg)
</code></pre>
<hr>
<h2 id="from-import语句">from ... import语句</h2>
<p>使用 <code>from ... import</code> 语句可以从模块中导入一个指定的部分到当前命名空间中。这种导入的方法不会把被导入的模块的名称放在当前的字符表中。</p>
<pre><code class="language-python">from modname import item1[, item2[, ... itemN]]
</code></pre>
<p>这样只会把 <code>modname</code> 中的指定的部分 <code>item1[, item2[, ... itemN]]</code> 导入到当前命名空间中，并且可以直接使用它们的名称来调用它们（无需使用 <code>.</code> 运算符）。<code>item1[, item2[, ... itemN]]</code> 可以是子模块、函数、类或变量等。</p>
<p>使用 <code>from package import item</code> 这种形式的时候，<code>import</code> 语法会首先把 <code>item</code> 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <code>:exc:ImportError</code> 异常。</p>
<p>把一个模块的所有内容全都导入到当前的命名空间（不推荐使用），但是那些由单一下划线 <code>_</code> 开头的名字不在此例：</p>
<pre><code class="language-python">from modname import *
</code></pre>
<p>Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。</p>
<p>为了解决这个问题，需要提供一个精确包的索引。导入语句遵循如下规则：</p>
<p>如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>以下实例在 file:sounds/effects/_<em>init</em>_.py 中包含如下代码：</p>
<pre><code class="language-python">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre>
<hr>
<h2 id="from-import-as语句">from ... import ... as语句</h2>
<p><code>import ... as</code> 可以将导入的模块、函数或者变量等重命名：</p>
<pre><code class="language-python">import name as new_name
</code></pre>
<p>该语句也可以接在 <code>from</code> 语句后面：</p>
<pre><code class="language-python">from modname import name as new_name
</code></pre>
<hr>
<h2 id="__name__-属性">__name__ 属性</h2>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。可以用 <code>__name__</code> 属性来使该程序块仅在该模块自身运行时执行（被其它程序或模块引入时不执行）。</p>
<p>每个模块都有一个 <code>__name__</code> 属性，当其值是 <code>'__main__'</code> 时，表明该模块自身在运行，否则是被引入。</p>
<pre><code class="language-python">#!/usr/bin/python3
# Filename: using_name.py

if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
</code></pre>
<pre><code class="language-python">$ python using_name.py
程序自身在运行
</code></pre>
<pre><code class="language-python">$ python
&gt;&gt;&gt; import using_name
我来自另一模块
</code></pre>
<hr>
<h2 id="dir-函数">dir() 函数</h2>
<p>内置的函数 <code>dir()</code> 可以找到指定模块内定义的所有名称，以一个字符串列表的形式返回。</p>
<pre><code class="language-python">&gt;&gt;&gt; import math
&gt;&gt;&gt; dir(math)
['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']
</code></pre>
<p>如果没有给定参数，<code>dir()</code> 函数会罗列出当前定义的所有名称。</p>
<pre><code class="language-python">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = 4
&gt;&gt;&gt; dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'b']
</code></pre>
<hr>
<h1 id="输入输出">输入输出</h1>
<h2 id="标准输出">标准输出</h2>
<p>在 Python 中使用 <code>print()</code> 来将其参数输出到标准输出上。默认的标准输出是屏幕。</p>
<p>可以使用 <code>str.format()</code> 函数等方式⤴ 来格式化输出值。</p>
<p>可以使用 <code>repr()</code> 或 <code>str()</code> 函数来将输出的值转成字符串。</p>
<ul>
<li>
<p><code>str()</code>：函数返回一个用户易读的表达形式。</p>
</li>
<li>
<p><code>repr()</code>：产生一个解释器易读的表达形式。</p>
</li>
</ul>
<hr>
<h2 id="标准输入">标准输入</h2>
<p>Python 提供了 <code>input()</code> 内置函数从标准输入读入一行文本，默认的标准输入是键盘。</p>
<p>Python3.x 中 <code>input()</code> 函数接受一个标准输入数据，返回为 string 类型。Python3.x 没有 <code>raw_input()</code>。</p>
<p><code>input()</code> 函数的语法：</p>
<pre><code class="language-python">input([prompt])
# prompt —— 输出到标准输出的提示信息
</code></pre>
<p>用法示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; a = input('输入一个整数：')
输入一个整数：123
&gt;&gt;&gt; type(a)
&lt;class 'str'&gt;      # input() 返回的是 string
&gt;&gt;&gt; a = int(a)      # 使用 int() 类型转换
&gt;&gt;&gt; print(type(a), a)
&lt;class 'int'&gt; 123    # 此时 a 才是 int
</code></pre>
<p><code>input()</code> 接收多个值：</p>
<pre><code class="language-python">#输入三角形的三边长
a, b, c = (input(&quot;请输入三角形三边的长：&quot;).split())
a = int(a)
b = int(b)
c = int(c)

#计算三角形的半周长p
p = (a + b + c) / 2

#计算三角形的面积s
s = (p * (p - a) * (p - b) * (p - c))**0.5

#输出三角形的面积
print(&quot;三角形面积为：&quot;, format(s, '.2f'))
</code></pre>
<hr>
<h2 id="读写文件">读写文件</h2>
<p><code>open()</code> 将会返回一个 <code>file</code> 对象，基本语法格式如下：</p>
<pre><code class="language-python">open(filename[, mode='r'])
# filename —— 包含了要访问的文件名称的字符串值
# mode —— 打开文件的模式的字符串值，默认文件访问模式为只读（r）
</code></pre>
<p>打开文件的模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>t</code></td>
<td>文本模式 (默认)。</td>
</tr>
<tr>
<td><code>x</code></td>
<td>写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td><code>b</code></td>
<td>二进制模式。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>打开一个文件进行更新（可读可写）。</td>
</tr>
<tr>
<td><code>U</code></td>
<td>通用换行模式（不推荐）。</td>
</tr>
<tr>
<td><code>r</code></td>
<td>以只读方式打开文件（默认模式）。文件的指针将会放在文件的开头。</td>
</tr>
<tr>
<td><code>rb</code></td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td><code>r+</code></td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td><code>rb+</code></td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td><code>w</code></td>
<td>打开一个文件只用于写入。
如果该文件已存在，则清空原文件内容，并从开头开始编辑。
如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td><code>wb</code></td>
<td>以二进制格式打开一个文件只用于写入。
打开方式与 <code>w</code> 相同（会覆盖原有的文件）。</td>
</tr>
<tr>
<td><code>w+</code></td>
<td>打开一个文件用于读写。
打开方式与 <code>w</code> 相同。</td>
</tr>
<tr>
<td><code>wb+</code></td>
<td>以二进制格式打开一个文件用于读写。
打开方式与 <code>w</code> 相同。</td>
</tr>
<tr>
<td><code>a</code></td>
<td>打开一个文件用于追加。
如果该文件已存在，文件指针将会放在文件的结尾。
即，新的内容将会被写入到已有内容之后。
如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td><code>ab</code></td>
<td>以二进制格式打开一个文件用于追加。
打开方式与 <code>a</code> 相同。</td>
</tr>
<tr>
<td><code>a+</code></td>
<td>打开一个文件用于读写。
打开方式与 <code>a</code> 相同。</td>
</tr>
<tr>
<td><code>ab+</code></td>
<td>以二进制格式打开一个文件用于追加。
打开方式与 <code>a</code> 相同。</td>
</tr>
</tbody>
</table>
<p>下图总结了这几种模式：</p>
<figure data-type="image" tabindex="1"><img src="python%20%E5%9F%BA%E7%A1%80.assets/2112205-861c05b2bdbc9c28.png" alt="img" title="img" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>模式</th>
<th><code>r</code></th>
<th><code>r+</code></th>
<th><code>w</code></th>
<th><code>w+</code></th>
<th><code>a</code></th>
<th><code>a+</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>写</td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>创建</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>覆盖</td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指针在开始</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>指针在结尾</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
<p><code>open()</code> 函数的完整语法格式：</p>
<pre><code class="language-python">open(file[, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None])
# file —— 必需，文件路径（相对或者绝对路径）。
# mode —— 可选，文件打开模式
# buffering —— 设置缓冲
# encoding —— 一般使用 utf8
# errors —— 报错级别
# newline —— 区分换行符
# closefd —— 传入的 file 参数类型
# opener —— 自定义打开文件方式
</code></pre>
<hr>
<p>打开文件后，要进行的就是写入和读取操作，这些操作都是对 <code>file</code> 对象进行操作。</p>
<p><code>file</code> 对象方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>file.close()</code></td>
<td>关闭文件。关闭后文件不能再进行读写操作。
在执行完文件的读写操作后，有必要执行该方法。</td>
</tr>
<tr>
<td><code>file.flush()</code></td>
<td>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>
</tr>
<tr>
<td><code>file.fileno()</code></td>
<td>返回一个整型的文件描述符（file descriptor FD 整型），可以用在如 <code>os</code> 模块的 <code>read</code> 方法等一些底层操作上。</td>
</tr>
<tr>
<td><code>file.isatty()</code></td>
<td>如果文件连接到一个终端设备返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>file.next()</code></td>
<td>返回文件下一行。</td>
</tr>
<tr>
<td><code>file.read([size=-1])</code></td>
<td>从文件读取指定的字节数，默认为 <code>-1</code>，为负数时表示读取所有。</td>
</tr>
<tr>
<td><code>file.readline([size=-1])</code></td>
<td>读取整行（<code>size</code> 默认为 <code>-1</code>，为负数表示读取整行），包括 <code>'\n'</code> 字符。
如果指定了 <code>size</code> 则读取该行的前 <code>size</code> 字符。
第一次调用时读取第一行，第二次调用时读取第二行，以此类推。</td>
</tr>
<tr>
<td><code>file.readlines([sizeint])</code></td>
<td>读取所有行并返回列表，若给定 <code>sizeint</code> &gt; 0，则是设置一次读多少字节，这是为了减轻读取压力。</td>
</tr>
<tr>
<td><code>file.seek(offset[, whence=0])</code></td>
<td>设置文件当前位置。
<code>offset</code> —— 开始的偏移量。
<code>whence</code> —— 给 <code>offset</code> 参数一个定义，表示要从哪个位置开始偏移；<code>0</code> 代表从文件开头开始算起，<code>1</code>代表从当前位置开始算起，<code>2 </code>代表从文件末尾算起。默认为 <code>0</code>。</td>
</tr>
<tr>
<td><code>file.tell()</code></td>
<td>返回文件当前位置。</td>
</tr>
<tr>
<td><code>file.truncate([size=file.tell()])</code></td>
<td>截取文件，截取的字节通过 <code>size</code> 指定，默认为当前文件位置。</td>
</tr>
<tr>
<td><code>file.write(str)</code></td>
<td>将字符串写入文件，返回的是写入的字符长度。
如果文件打开模式带 <code>b</code>，那写入文件内容时，<code>str</code> 要用 <code>encode()</code> 方法转为 <code>bytes</code> 形式，否则报错：TypeError: a bytes-like object is required, not 'str'。</td>
</tr>
<tr>
<td><code>file.writelines(sequence)</code></td>
<td>向文件写入一个序列字符串列表（这一序列字符串可以是由迭代对象产生的，如一个字符串列表），如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody>
</table>
<hr>
<p><code>file.write()</code> 用法：</p>
<pre><code class="language-python">f = open('test.txt', 'w+')
f.write('test1')
f.seek(0)
print('从文件中读取到的字符串：', f.read())
f.close()
# 输出：
# 从文件中读取到的字符串： test1

f = open('test.txt', 'wb+')
f.write('test1'.encode())
f.seek(0)
print('从二进制文件中读取到的内容：', f.read())
f.seek(0)
print('将其转化为字符串输出：', f.read().decode())
f.close()
# 输出：
# 从二进制文件中读取到的内容： b''
# 将其转化为字符串输出： test1
</code></pre>
<hr>
<h1 id="os模块">os模块</h1>
<p>os 模块提供了非常丰富的方法用来处理文件和目录。以下是一些常用的方法：</p>
<hr>
<p><code>os.access(path, mode)</code></p>
<p>检验权限模式（使用当前的 UID/GID 尝试访问路径）。</p>
<ul>
<li>
<p><code>path</code> —— 要用来检测是否有访问权限的路径。</p>
</li>
<li>
<p><code>mode</code> —— 参数取值如下：</p>
<ul>
<li>
<p><code>os.F_OK</code> —— 测试 <code>path</code> 是否存在；</p>
</li>
<li>
<p><code>os.R_OK</code> —— 测试 <code>path</code> 是否可读；</p>
</li>
<li>
<p><code>os.W_OK</code> —— 测试 <code>path</code> 是否可写；</p>
</li>
<li>
<p><code>os.X_OK</code> —— 测试 <code>path</code> 是否可执行。</p>
</li>
<li>
<p>在相应模式下，如果存在/可读/写/执行返回 <code>True</code> ，否则返回 <code>False</code>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>os.chdir(path)</code></td>
<td>改变当前工作目录到 <code>path</code> 指定的路径。如果允许访问返回 <code>True</code>，否则返回 <code>False</code>。</td>
</tr>
<tr>
<td><code>os.chflags(path, flags)</code></td>
<td>设置路径 <code>path</code> 的标记为数字标记。多个标记可以使用 OR 来组合起来。
<code>flags</code> —— 参数取值如下：
<code>stat.UF_NODUMP</code> —— 非转储文件；
<code>stat.UF_IMMUTABLE</code> —— 文件是只读的；
<code>stat.UF_APPEND</code> —— 文件只能追加内容；
<code>stat.UF_NOUNLINK</code> —— 文件不可删除；
<code>stat.UF_OPAQUE</code> —— 目录不透明，需要通过联合堆栈查看；
以下参数值是超级用户可设置的：
<code>stat.SF_ARCHIVED</code> —— 可存档文件；
<code>stat.SF_IMMUTABLE</code> —— 文件是只读的；
<code>stat.SF_APPEND</code> —— 文件只能追加内容；
<code>stat.SF_NOUNLINK</code> —— 文件不可删除；
<code>stat.SF_SNAPSHOT</code> —— 快照文件。</td>
</tr>
<tr>
<td><code>os.chmod(path, mode)</code></td>
<td>更改权限</td>
</tr>
<tr>
<td><code>os.chown(path, uid, gid)</code></td>
<td>更改文件所有者</td>
</tr>
<tr>
<td><code>os.chroot(path)</code></td>
<td>改变当前进程的根目录</td>
</tr>
<tr>
<td><code>os.close(fd)</code></td>
<td>关闭文件描述符 fd</td>
</tr>
<tr>
<td><code>os.closerange(fd_low, fd_high)</code></td>
<td>关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td><code>os.dup(fd)</code></td>
<td>复制文件描述符 fd</td>
</tr>
<tr>
<td><code>os.dup2(fd, fd2)</code></td>
<td>将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td><code>os.fchdir(fd)</code></td>
<td>通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td><code>os.fchmod(fd, mode)</code></td>
<td>改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td><code>os.fchown(fd, uid, gid)</code></td>
<td>修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td><code>os.fdatasync(fd)</code></td>
<td>强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td><code>os.fdopen(fd[, mode[, bufsize]])</code></td>
<td>通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td><code>os.fpathconf(fd, name)</code></td>
<td>返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr>
<td><code>os.fstat(fd)</code></td>
<td>返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td><code>os.fstatvfs(fd)</code></td>
<td>返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。</td>
</tr>
<tr>
<td><code>os.fsync(fd)</code></td>
<td>强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td><code>os.ftruncate(fd, length)</code></td>
<td>裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td><code>os.getcwd()</code></td>
<td>返回当前工作目录</td>
</tr>
<tr>
<td><code>os.getcwdb()</code></td>
<td>返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td><code>os.isatty(fd)</code></td>
<td>如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td><code>os.lchflags(path, flags)</code></td>
<td>设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td><code>os.lchmod(path, mode)</code></td>
<td>修改连接文件权限</td>
</tr>
<tr>
<td><code>os.lchown(path, uid, gid)</code></td>
<td>更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td><code>os.link(src, dst)</code></td>
<td>创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td><code>os.listdir(path)</code></td>
<td>返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td><code>os.lseek(fd, pos, how)</code></td>
<td>设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td><code>os.lstat(path)</code></td>
<td>像stat(),但是没有软链接</td>
</tr>
<tr>
<td><code>os.major(device)</code></td>
<td>从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td><code>os.makedev(major, minor)</code></td>
<td>以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td><code>os.makedirs(path[, mode])</code></td>
<td>递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td><code>os.minor(device)</code></td>
<td>从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td><code>os.mkdir(path[, mode])</code></td>
<td>以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td><code>os.mkfifo(path[, mode])</code></td>
<td>创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td><code>os.mknod(filename[, mode=0600, device])</code></td>
<td>创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td><code>os.open(file, flags[, mode])</code></td>
<td>打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td><code>os.openpty()</code></td>
<td>打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td><code>os.pathconf(path, name)</code></td>
<td>返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td><code>os.pipe()</code></td>
<td>创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr>
<td><code>os.popen(command[, mode[, bufsize]])</code></td>
<td>从一个 command 打开一个管道</td>
</tr>
<tr>
<td><code>os.read(fd, n)</code></td>
<td>从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td><code>os.readlink(path)</code></td>
<td>返回软链接所指向的文件</td>
</tr>
<tr>
<td><code>os.remove(path)</code></td>
<td>删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td><code>os.removedirs(path)</code></td>
<td>递归删除目录。</td>
</tr>
<tr>
<td><code>os.rename(src, dst)</code></td>
<td>重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td><code>os.renames(old, new)</code></td>
<td>递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td><code>os.rmdir(path)</code></td>
<td>删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr>
<td><code>os.stat(path)</code></td>
<td>获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr>
<td><code>os.stat_float_times([newvalue])</code></td>
<td>决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr>
<td><code>os.statvfs(path)</code></td>
<td>获取指定路径的文件系统统计信息</td>
</tr>
<tr>
<td><code>os.symlink(src, dst)</code></td>
<td>创建一个软链接</td>
</tr>
<tr>
<td><code>os.tcgetpgrp(fd)</code></td>
<td>返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr>
<td><code>os.tcsetpgrp(fd, pg)</code></td>
<td>设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr>
<td><code>os.tempnam([dir[, prefix]])</code></td>
<td><strong>Python3 中已删除。</strong> 返回唯一的路径名用于创建临时文件。</td>
</tr>
<tr>
<td><code>os.tmpfile()</code></td>
<td><strong>Python3 中已删除。</strong> 返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
</tr>
<tr>
<td><code>os.tmpnam()</code></td>
<td><strong>Python3 中已删除。</strong> 为创建一个临时文件返回一个唯一的路径</td>
</tr>
<tr>
<td><code>os.ttyname(fd)</code></td>
<td>返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr>
<td><code>os.unlink(path)</code></td>
<td>删除文件路径</td>
</tr>
<tr>
<td><code>os.utime(path, times)</code></td>
<td>返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr>
<td><code>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</code></td>
<td>输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
</tr>
<tr>
<td><code>os.write(fd, str)</code></td>
<td>写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
<tr>
<td><code>os.path</code> 模块</td>
<td>获取文件的属性信息。</td>
</tr>
<tr>
<td><code>os.pardir()</code></td>
<td>获取当前目录的父目录，以字符串形式显示目录名。</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="错误和异常">错误和异常</h1>
<p>Python 中的语法错误也可称之为解析错。即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。</p>
<p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来：</p>
<pre><code class="language-python">&gt;&gt;&gt; 10 * (1/0)             # 0 不能作为除数，触发异常
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
ZeroDivisionError: division by zero
&gt;&gt;&gt; 4 + spam*3             # spam 未定义，触发异常
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: name 'spam' is not defined
&gt;&gt;&gt; '2' + 2               # int 不能与 str 相加，触发异常
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: can only concatenate str (not &quot;int&quot;) to str
</code></pre>
<p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p>
<hr>
<h2 id="异常处理">异常处理</h2>
<h3 id="tryexcept">try/except</h3>
<p>异常捕捉可以使用 <code>try/except</code> 语句：</p>
<pre><code class="language-python"># 执行一次 try 子句，并尝试捕捉异常
# 如果没有异常发生，忽略 except 子句
# 当捕捉到异常时，将执行对应的 except 子句
# 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中
# 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。但最多只有一个分支会被执行。
try:
    statement_1
except Error1:
    statement_2
except Error2:
    statement_3
......
except: # 省略异常的名称，将被当作通配符使用
    statement_n

# 2. 一次处理多个异常
try:
    statement_1
except (Error1, Error2, ...): # 这里是一个元素为“异常”的元组
    statement_2
</code></pre>
<p>Example：</p>
<pre><code class="language-python">while True:
    try:
        x = int(input(&quot;请输入一个数字: &quot;))
        break
    except ValueError:
        print(&quot;您输入的不是数字，请再次尝试输入！&quot;)
</code></pre>
<pre><code class="language-python">import sys

try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print(&quot;OS error: {0}&quot;.format(err))
except ValueError:
    print(&quot;Could not convert data to an integer.&quot;)
except:
    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])
    raise # 再次将触发的异常抛出
</code></pre>
<hr>
<h3 id="tryexcept-else">try/except ... else</h3>
<p><code>try/except</code> 语句还有一个可选的 <code>else</code> 子句，如果使用这个子句，那么必须放在所有的 <code>except</code> 子句之后。<code>else</code> 子句将在 <code>try</code> 子句没有发生任何异常的时候执行。</p>
<pre><code class="language-python">try:
    statement_1
except Error1:
    statement_2
except Error2:
    statement_3
......
except:
    statement_n
else:
    statement_e
</code></pre>
<p>判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容：</p>
<pre><code class="language-python">for arg in sys.argv[1:]:
    try:
        f = open(arg, 'r')
    except IOError:
        print('cannot open', arg)
    else:
        print(arg, 'has', len(f.readlines()), 'lines')
        f.close()
</code></pre>
<p>使用 <code>else</code> 子句比把所有的语句都放在 <code>try</code> 子句里面要好，这样可以避免一些意想不到，而 <code>except</code> 又无法捕获的异常。异常处理并不仅仅处理那些直接发生在 <code>try</code> 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。</p>
<hr>
<h3 id="try-finally">try-finally</h3>
<p><code>try-finally</code> 语句无论是否发生异常都将执行 <code>finally</code> 子句的代码。</p>
<pre><code class="language-python">try:
    statement_1
except Error1:
    statement_2
except Error2:
    statement_3
......
except:
    statement_n
else:
    statement_e
finally:
    statement_f
</code></pre>
<p>Example：</p>
<pre><code class="language-python">try:
    runoob()
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)
finally:
    print('这句话，无论异常是否发生都会执行。')
</code></pre>
<p><code>finally</code> 子句通常用作定义任何情况下都会执行的清理行为。</p>
<p>如果一个异常在 <code>try</code> 子句里（或者在 <code>except</code> 和 <code>else</code> 子句里）被抛出，而又没有任何的 <code>except </code>把它截住，那么这个异常会在 <code>finally</code> 子句执行后被抛出。</p>
<hr>
<h2 id="抛出异常">抛出异常</h2>
<p>Python 使用 <code>raise</code> 语句抛出一个指定的异常。<code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 <code>Exception</code> 的子类）。<code>raise</code> 语法格式如下：</p>
<pre><code class="language-python">raise [Exception [, args [, traceback]]]
</code></pre>
<p>Example：</p>
<pre><code class="language-python">x = 10
if x &gt; 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
</code></pre>
<p>执行以上代码会触发异常：</p>
<pre><code class="language-latex">Traceback (most recent call last):
  File &quot;test.py&quot;, line 3, in &lt;module&gt;
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
Exception: x 不能大于 5。x 的值为: 10
</code></pre>
<hr>
<h2 id="用户自定义异常">用户自定义异常</h2>
<p>异常类都是直接或间接地继承自 <code>Exception</code> 类。</p>
<pre><code class="language-python">&gt;&gt;&gt; class MyError(Exception):
...     def __init__(self, value):
...         self.value = value
...     def __str__(self):
...         return repr(self.value)
...
&gt;&gt;&gt; try:
...     raise MyError(2*2)
... except MyError as e:
...     print('My exception occurred, value:', e.value)
...
My exception occurred, value: 4
&gt;&gt;&gt; raise MyError('oops!')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
__main__.MyError: 'oops!'
</code></pre>
<hr>
<h2 id="预定义清理行为">预定义清理行为</h2>
<p><code>with</code> 语句可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法：</p>
<pre><code class="language-python">with open(&quot;myfile.txt&quot;) as f:
    for line in f:
        print(line, end=&quot;&quot;)
</code></pre>
<hr>
<h2 id="assert-断言">assert 断言</h2>
<p>Python <code>assert</code>（断言）用于判断一个表达式，在表达式条件为 <code>false</code> 的时候触发异常。</p>
<p>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。</p>
<p>语法格式如下：</p>
<pre><code class="language-python">assert expression
# expression 值为 True 时，正常执行；
# 为 False 时，触发异常
</code></pre>
<p>它等价于：</p>
<pre><code class="language-python">if not expression:
    raise AssertionError
</code></pre>
<p><code>assert</code> 后面也可以紧跟参数:</p>
<pre><code class="language-python">assert expression [, arguments]
</code></pre>
<p>等价于：</p>
<pre><code class="language-python">if not expression:
    raise AssertionError(arguments)
</code></pre>
<p>Example：</p>
<pre><code class="language-python">&gt;&gt;&gt; assert True     # 条件为 true 正常执行
&gt;&gt;&gt; assert False    # 条件为 false 触发异常
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AssertionError
&gt;&gt;&gt; assert 1==1    # 条件为 true 正常执行
&gt;&gt;&gt; assert 1==2    # 条件为 false 触发异常
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AssertionError

&gt;&gt;&gt; assert 1==2, '1 不等于 2'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AssertionError: 1 不等于 2
</code></pre>
<pre><code class="language-python"># 判断当前系统是否为 Linux，如果不满足条件则直接触发异常，不必执行接下来的代码
import sys
assert ('linux' in sys.platform), &quot;该代码只能在 Linux 下执行&quot;

# ... 接下来要执行的代码
</code></pre>
<hr>
<h1 id="面向对象">面向对象</h1>
<ul>
<li>
<p><strong>类</strong>（Class）：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p>
</li>
<li>
<p><strong>方法</strong>：类中定义的函数。</p>
</li>
<li>
<p><strong>类变量</strong>：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</p>
</li>
<li>
<p><strong>数据成员</strong>：类变量或者实例变量用于处理类及其实例对象的相关的数据。</p>
</li>
<li>
<p><strong>方法重写</strong>：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p>
</li>
<li>
<p><strong>局部变量</strong>：定义在方法中的变量，只作用于当前实例的类。</p>
</li>
<li>
<p><strong>实例变量</strong>：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</p>
</li>
<li>
<p><strong>继承</strong>：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。继承是模拟 “是一个（is-a）” 关系。</p>
</li>
<li>
<p><strong>实例化</strong>：创建一个类的实例，类的具体对象。</p>
</li>
<li>
<p><strong>对象</strong>：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p>
</li>
</ul>
<hr>
<h2 id="类定义和类对象">类定义和类对象</h2>
<h2 id="创建类">创建类</h2>
<p>创建类的语法格式如下：</p>
<pre><code class="language-python">class ClassName():
   
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre>
<hr>
<h2 id="创建实例对象">创建实例对象</h2>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p>在 Python 中，类的实例化类似函数调用方式，其语法格式如下：</p>
<pre><code class="language-python">obj = ClassName([arg1, arg2, ...])
</code></pre>
<hr>
<h2 id="访问对象属性">访问对象属性</h2>
<p>类的属性是指在类中定义的变量和方法等。</p>
<p>属性引用使用 <code>obj.name</code> 语法。类对象创建后，类命名空间中所有的命名（如变量、方法等）都是有效属性名。</p>
<p>Example：</p>
<pre><code class="language-python">class MyClass():
    var1 = 1
    var2 = 2
    
    def method(self):
        print(&quot;This is my class.&quot;)
        
obj = MyClass()
print(obj.var1, obj.var2)
print()
obj.func()

# 输出：
# 1 2
# This is my class.
</code></pre>
<hr>
<h2 id="__init__-和self">__init__() 和self</h2>
<p>在类定义中有一个特殊的方法，构造方法 <code>__init__()</code>。如果类定义了 <code>__init__()</code> 方法，那么在类实例化时，会自动调用该方法。</p>
<p>在类定义中，<code>self</code> 代表类的实例，而非类。<code>self</code> 必须存在，且位于其他形参前面。类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>，按照惯例它的名称是 <code>self</code>。</p>
<p><code>self</code> 的名字并不是规定死的，也可以使用 <code>this</code>，但是最好还是按照约定使用 <code>self</code>。</p>
<p>在类的内部，使用 <code>def</code> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <code>self</code>, 且为第一个参数。</p>
<p>Example：</p>
<pre><code class="language-python">class Complex():
    &quot;&quot;&quot;复数类&quot;&quot;&quot;
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart
        
    def print_complex(self):
        print('{:f}{:+f}i'.format(self.r, self.i))

x = Complex(3.0, -4.5) # 实例化
print(x.r, x.i)   # 输出：3.0 -4.5
x.print_complex() # 输出：3.000000-4.500000i
</code></pre>
<p>在 Python 调用 <code>__init__()</code> 来创建实例时，将自动传入实参 <code>self</code>。每个与类相关联的方法调用都自动传递实参 <code>self</code>。</p>
<p>在类的内部使用属性和方法，需要使用 <code>self.attrs</code> 或 <code>self.method()</code>。</p>
<hr>
<h2 id="修改属性值">修改属性值</h2>
<p>通常有两种方法可以修改属性值，一种是直接使用 <code>obj.name</code> 语法修改，另一种是通过方法对属性值进行修改。</p>
<p>Example：</p>
<pre><code class="language-python">class Car(): 
 
    def __init__(self, make, model, year): 
        &quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot; 
        self.make = make 
        self.model = model 
        self.year = year
        self.odometer_reading = 0 

    def get_descriptive_name(self): 
        &quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot; 
        long_name = str(self.year) + ' ' + self.make 
          + ' ' + self.model 
        return long_name.title()

    def read_odometer(self): 
        &quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot; 
        print(&quot;This car has &quot; + str(self.odometer_reading) 
              + &quot; miles on it.&quot;) 
        
    def update_odometer(self, mileage): 
        &quot;&quot;&quot; 
        将里程表读数设置为指定的值
        禁止将里程表读数往回调
        &quot;&quot;&quot;
        if mileage &gt;= self.odometer_reading: 
       self.odometer_reading = mileage 
     else: 
      print(&quot;You can't roll back an odometer!&quot;)
            
    def increment_odometer(self, miles): 
     &quot;&quot;&quot;将里程表读数增加指定的量&quot;&quot;&quot; 
     self.odometer_reading += miles

my_new_car = Car('audi', 'a4', 2016) 
# 通过方法获取属性
print(my_new_car.get_descriptive_name()) 
my_new_car.read_odometer()

# 输出：
# 2016 Audi A4 
# This car has 0 miles on it.

# 通过方法对属性值进行修改
my_used_car = Car('subaru', 'outback', 2013) 
print(my_used_car.get_descriptive_name())

my_used_car.update_odometer(23500) 
my_used_car.read_odometer()

my_used_car.increment_odometer(100) 
my_used_car.read_odometer()

# 输出：
# 2013 Subaru Outback 
# This car has 23500 miles on it. 
# This car has 23600 miles on it.
</code></pre>
<hr>
<h2 id="继承">继承</h2>
<p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。派生类的定义如下所示：</p>
<pre><code class="language-python">class DerivedClassName(BaseClassName):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre>
<p><code>BaseClassName</code>（实例中的基类名）必须与派生类定义在一个作用域内。</p>
<p>如果基类定义在另一个模块中，需要使用 <code>.</code> 运算符：</p>
<pre><code class="language-python">class DerivedClassName(modname.BaseClassName):
</code></pre>
<p>Example：</p>
<pre><code class="language-python"># 类定义
class people:
    # 定义基本属性
    name = ''
    age = 0
    # 定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    # 定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
# 单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        # 调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    # 覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
 
 
 
s = student('ken',10,60,3)
s.speak()
</code></pre>
<hr>
<h3 id="多继承">多继承</h3>
<p>Python 有限地支持<strong>多继承</strong>，多继承的类定义如下：</p>
<pre><code class="language-python">class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre>
<p>若是父类中有相同的方法名，而在子类使用时未指定，Python 会根据圆括号中父类的顺序从左至右搜索。即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<p>Example：</p>
<pre><code class="language-python"># 接上一个例子

# 另一个类，多重继承之前的准备
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))
 
# 多重继承
class sample(speaker,student):
    a =''
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
 
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   # 方法名同，默认调用的是在括号中排前地父类的方法
</code></pre>
<hr>
<h3 id="方法重写">方法重写</h3>
<p>可以在子类中重写其父类的方法：</p>
<pre><code class="language-python">class Parent:        # 定义父类
   def myMethod(self):
      print ('调用父类方法')
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print ('调用子类方法')
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() # 用子类对象调用父类已被覆盖的方法

# 输出：
# 调用子类方法
# 调用父类方法
</code></pre>
<hr>
<h3 id="子类继承父类构造函数说明">子类继承父类构造函数说明</h3>
<p>如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。</p>
<p>子类不重写 <code>__init__</code>，实例化子类时，会自动调用父类定义的 <code>__init__</code>。</p>
<p>Example：</p>
<pre><code class="language-python">class Father(object):
    def __init__(self, name):
        self.name = name
        print (&quot;name: %s&quot; % (self.name))
    def getName(self):
        return 'Father ' + self.name
 
# 重写了 getName 但并没有重写 __init__
class Son(Father):
    def getName(self):
        return 'Son ' + self.name
 
if __name__ == '__main__':
    son = Son('runoob')
    print(son.getName())
    
# 输出：
# name: runoob
# Son runoob
</code></pre>
<hr>
<p>如果重写了<code>__init__</code> 时，实例化子类，就不会调用父类已经定义的 <code>__init__</code>。</p>
<p>Example：</p>
<pre><code class="language-python">class Father(object):
    def __init__(self, name):
        self.name=name
        print ( &quot;name: %s&quot; %( self.name) )
    def getName(self):
        return 'Father ' + self.name
 
# 重写了 __init__ 和 getName
class Son(Father):
    def __init__(self, name):
        print ( &quot;hi&quot; )
        self.name =  name
    def getName(self):
        return 'Son '+self.name
 
if __name__=='__main__':
    son=Son('runoob')
    print (son.getName())
    
# 输出：
# hi
# Son runoob
</code></pre>
<hr>
<p>如果重写了 <code>__init__</code> 时，要继承父类的构造方法，可以在 <code>__init__</code> 的定义中使用 <code>super</code> 关键字：</p>
<pre><code class="language-python">super(子类, self).__init__(参数1, 参数2, ....)
</code></pre>
<p>另一种写法：</p>
<pre><code class="language-python">父类名称.__init__(self, 参数1, 参数2, ...)
</code></pre>
<p>Example：</p>
<pre><code class="language-python">class Father(object):
    def __init__(self, name):
        self.name = name
        print(&quot;name: %s&quot; % (self.name))
    def getName(self):
        return 'Father ' + self.name
 
class Son(Father):
    def __init__(self, name):
        super(Son, self).__init__(name)
        print(&quot;hi&quot;)
        self.name =  name
    def getName(self):
        return 'Son ' + self.name
 
if __name__ == '__main__':
    son=Son('runoob')
    print (son.getName())
    
# 输出：
# name: runoob
# hi
# Son runoob
</code></pre>
<hr>
<h2 id="类的私有属性与私有方法">类的私有属性与私有方法</h2>
<p>私有属性不能在类的外部被使用或直接访问。使用两个下划线开头，声明该属性为私有：</p>
<pre><code class="language-python">__private_attrs
</code></pre>
<p>在类内部的方法中使用私有属性：</p>
<pre><code class="language-python">self.__private_attrs
</code></pre>
<p>Example：</p>
<pre><code class="language-python">class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量
 
    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print (self.__secretCount)
 
counter = JustCounter()
counter.count()
counter.count()
print (counter.publicCount)
print (counter.__secretCount)  # 报错，实例不能访问私有变量
</code></pre>
<p>输出结果：</p>
<pre><code class="language-python">1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 16, in &lt;module&gt;
    print (counter.__secretCount)  # 报错，实例不能访问私有变量
AttributeError: 'JustCounter' object has no attribute '__secretCount'
</code></pre>
<hr>
<p>私有方法只能在类的内部调用 ，不能在类的外部调用。使用两个下划线开头，声明该方法为私有方法：</p>
<pre><code class="language-python">def __private_method(self[, ...]):
</code></pre>
<p>在类内部的方法中使用私有方法：</p>
<pre><code class="language-python">self.__private_methods([...])
</code></pre>
<p>Example：</p>
<pre><code class="language-python">class Site:
    def __init__(self, name, url):
        self.name = name   # public
        self.__url = url   # private
 
    def who(self):
        print('name  : ', self.name)
        print('url : ', self.__url)
 
    def __foo(self):          # 私有方法
        print('这是私有方法')
 
    def foo(self):            # 公共方法
        print('这是公共方法')
        self.__foo()
 
x = Site('菜鸟教程', 'www.runoob.com')
x.who()        # 正常输出
x.foo()        # 正常输出
x.__foo()      # 报错
</code></pre>
<p>输出结果：</p>
<pre><code class="language-python">name  :  菜鸟教程
url :  www.runoob.com
这是公共方法
这是私有方法
Traceback (most recent call last):
  File &quot;c:/Users/27120/Documents/MyDocuments/Code/test.py&quot;, line 20, in &lt;module&gt;      
    x.__foo()      # 报错，外部不能调用私有方法
AttributeError: 'Site' object has no attribute '__foo'
</code></pre>
<hr>
<h2 id="类的专有方法">类的专有方法</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__init__ </code></td>
<td>构造函数，在生成对象时调用</td>
</tr>
<tr>
<td><code>__del__</code></td>
<td>析构函数，释放对象时使用</td>
</tr>
<tr>
<td><code>__repr__</code></td>
<td>打印，转换</td>
</tr>
<tr>
<td><code>__setitem__</code></td>
<td>按照索引赋值</td>
</tr>
<tr>
<td><code>__getitem__</code></td>
<td>按照索引获取值</td>
</tr>
<tr>
<td><code>__len__</code></td>
<td>获得长度</td>
</tr>
<tr>
<td><code>__cmp__</code></td>
<td>比较运算</td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>函数调用</td>
</tr>
<tr>
<td><code>__add__</code></td>
<td>加运算</td>
</tr>
<tr>
<td><code>__sub__</code></td>
<td>减运算</td>
</tr>
<tr>
<td><code>__mul__</code></td>
<td>乘运算</td>
</tr>
<tr>
<td><code>__truediv__</code></td>
<td>除运算</td>
</tr>
<tr>
<td><code>__mod__</code></td>
<td>求余运算</td>
</tr>
<tr>
<td><code>__pow__</code></td>
<td>乘方</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="运算符重载">运算符重载</h3>
<p>可以对类的专有方法进行重载：</p>
<pre><code class="language-python">class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
 
   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)
   
   def __add__(self, other):
      return Vector(self.a + other.a, self.b + other.b)
 
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)

# 输出：
# Vector(7,8)
</code></pre>
<hr>
<h1 id="命名空间">命名空间</h1>
<p>命名空间（Namespace）是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p>
<p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p>
<p>一般有三种命名空间：</p>
<ol>
<li>
<p><strong>内置名称（built-in names）</strong>：Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</p>
</li>
<li>
<p><strong>全局名称（global names）</strong>：模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</p>
</li>
<li>
<p><strong>局部名称（local names）</strong>：函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量（类中定义的也是）。</p>
</li>
</ol>
<ul>
<li>
<p>命名空间查找顺序：局部的命名空间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 全局命名空间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 内置命名空间。</p>
</li>
<li>
<p>如果找不到变量，将放弃查找并引发一个 <code>NameError</code> 异常：</p>
<pre><code class="language-python">NameError: name 'runoob' is not defined
</code></pre>
</li>
<li>
<p>命名空间的生命周期：命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。</p>
</li>
</ul>
<p>因此，无法从外部命名空间访问内部命名空间的对象。</p>
<hr>
<h1 id="作用域">作用域</h1>
<p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。变量的访问权限取决于这个变量是在哪里赋值的。</p>
<p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有 4 种，分别是：</p>
<ol>
<li>
<p><strong>L（Local）</strong>：最内层，包含局部变量。如一个函数/方法内部。</p>
</li>
<li>
<p><strong>E（Enclosing）</strong>：包含了非局部（non-local）也非全局（non-global）的变量。<br>
如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 non-local。</p>
</li>
<li>
<p><strong>G（Global）</strong>：当前脚本的最外层。如当前模块的全局变量。</p>
</li>
<li>
<p><strong>B（Built-in）</strong>： 包含了内建的变量/关键字等，最后被搜索。</p>
</li>
</ol>
<p>作用域查找顺序： L <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> E <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> G <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> B。</p>
<pre><code class="language-python">g_count = 0  # 全局作用域
def outer():
    o_count = 1  # 闭包函数外的函数中
    def inner():
        i_count = 2  # 局部作用域
</code></pre>
<p>内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在Python3.0中，可以使用以下的代码来查看到底预定义了哪些变量：</p>
<pre><code class="language-python">&gt;&gt;&gt; import builtins
&gt;&gt;&gt; dir(builtins)
</code></pre>
<p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 <code>if</code>/<code>elif</code>/<code>else</code>、<code>try</code>/<code>except</code>、<code>for</code>/<code>while</code>等）是不会引入新的作用域的：</p>
<hr>
<h2 id="全局变量和局部变量">全局变量和局部变量</h2>
<p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。</p>
<hr>
<h2 id="global和nonlocal">global和nonlocal</h2>
<p><code>global</code> 和 <code>nonlocal</code> 的作用是让内部作用域修改外部作用域变量。</p>
<p><code>global</code> —— 修改全局变量：</p>
<pre><code class="language-python">num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num) 
    num = 123
    print(num)
    
fun1()
print(num)

# 输出：
# 1
# 123
# 123
</code></pre>
<p><code>nonlocal</code> —— 修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量：</p>
<pre><code class="language-python">def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
    
outer()

# 输出：
# 100
# 100
</code></pre>
<hr>
<p>不使用 <code>global</code> 或 <code>nonlocal</code> 修改外部作用域变量：</p>
<pre><code class="language-python">a = 10
def test():
    a = a + 1
    print(a)
test()
</code></pre>
<p>结果：</p>
<pre><code class="language-python">Traceback (most recent call last):
  File &quot;test.py&quot;, line 7, in &lt;module&gt;
    test()
  File &quot;test.py&quot;, line 5, in test
    a = a + 1
UnboundLocalError: local variable 'a' referenced before assignment
</code></pre>
<p>局部作用域引用错误，因为 <code>test</code> 函数中的 <code>a</code> 使用的是局部，未定义，无法修改。</p>
<hr>
<p>for x in range(1,5)</p>
<p>if x &gt; 2</p>
<p>for y in range(1,4)</p>
<p>if y &lt; 3</p>
<p>x*y</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://linna-cy.github.io/old-blog/Python 进阶 — 正则表达式篇/" class="post-title gt-a-link">
                    Python 进阶 — 正则表达式篇
                </a>
            </div>
        

        

        

        <!-- <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first"></div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://linna-cy.github.io/old-blog/atom.xml" target="_blank">RSS</a>
    </div>
</div>
 -->
    </div>
</div>
<script>
  hljs.highlightAll();
  // 开启代码高亮
  // hljs.initHighlightingOnLoad();
  // 行号显示
  // hljs.initLineNumbersOnLoad({ singleLine:true });
  // let tocDiv = document.getElementById('toc-div');
  // let toc = document.querySelector('#toc-div .markdownIt-TOC');
  // if (toc === null || toc === undefined) {
  //   tocDiv.style.display = 'none';
  // }

  setCodeAllNum();
</script>
</body>
</html>
