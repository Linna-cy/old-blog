<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>SpringMVC 基础 | Linner&#39;s Blog</title>

<!-- 代码高亮： -->
<!-- <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"> -->
<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script> -->

<link rel="shortcut icon" href="https://linna-cy.github.io/old-blog/favicon.ico?v=1684376365462">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://linna-cy.github.io/old-blog/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<link rel="stylesheet" href="https://linna-cy.github.io/old-blog/media/icons/iconfont.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!-- <script src="media/scripts/index.js"></script> -->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
    <script>
      // 计算代码行数
      let pxToNumber = function(px) {
        // let num = Number(px.replace("px", ""));
        let num = parseFloat(px);

        return num;
      };
      let getRow = function(elem) {
          let style = window.getComputedStyle(elem, null);
          // let lineHeight = style.lineHeight === "normal" ? style.fontSize : style.lineHeight;
          let lineHeight = style.lineHeight;

          let height = style.height;
          let padding = style.padding;
          // let isiOS = /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent);
          let row = (pxToNumber(height)-pxToNumber(padding)) / pxToNumber(lineHeight);
          // if (isiOS) {
          //   row = pxToNumber(height) / pxToNumber(lineHeight);
          //   alert('ios!');
          // }
          // else {
          //   row = (pxToNumber(height)-pxToNumber(padding)) / pxToNumber(lineHeight);
          // }
          return parseInt(row);
      };
      
      // 获取行号文字
      let getRowNumString = function (row) {
          let num_str = new String('');
          for (let i = 1; i <= row; i++) {
              let num = new String(i.toString() + '\n');
              num_str = num_str + num;
          }
          return num_str;
      }

      // 指定代码块开启代码行号
      let setCodeNum = function(codeElem) {
          let pre = codeElem.parentElement;
          let span = document.createElement('span');
          span.innerText = getRowNumString(getRow(codeElem));
          let codeElemStyle = window.getComputedStyle(codeElem, null);
          span.style.display = 'inline-block';
          span.style.backgroundColor = "rgba(255,255,255,0)";
          span.style.color = 'rgba(255,255,255,0.4)';
          span.style.margin = 0;
          span.style.padding = 0;
          // span.style.borderRight = '1px #fff solid';
          span.style.paddingRight = 4;
          span.style.userSelect = 'none';
          span.style.textAlign = 'center';
          span.className = 'code-num';

          span.style.font = codeElemStyle.font;
          // span.style.height = codeElemStyle.height;
          span.style.paddingLeft = codeElemStyle.paddingRight;
          span.style.borderTopLeftRadius = codeElemStyle.borderTopRightRadius;
          span.style.borderBottomLeftRadius = codeElemStyle.borderBottomRightRadius;
          span.style.paddingTop = codeElemStyle.paddingTop;

          pre.style.display = 'flex';
          pre.style.overflowX = 'hidden';

          codeElem.style.borderTopLeftRadius = 0;
          codeElem.style.borderBottomLeftRadius = 0;
          codeElem.style.marginLeft = 0;
          codeElem.style.paddingLeft = span.style.paddingRight;
          codeElem.style.overflowX = 'auto';
          codeElem.style.display = 'inline-block';
          pre.insertBefore(span, codeElem);
      }

      // 设置代码块开启代码行号
      let setCodeAllNum = function() {
          let codeElems = document.querySelectorAll('pre > code');
          for (let i = 0; i < codeElems.length; i++) {
              codeElems[i].parentElement.className = 'code-pre';
              setCodeNum(codeElems[i]);
          }
      }
    </script>
</head>
<body>
<div class="main gt-bg-theme-color-first post-main">
    <!-- <div class="top">
    <span id="go-top" class="iconfont icon-shangxiazuoyouTriangle17"></span>
</div>
<script>
    let goTop = document.getElementById("go-top");
    let goTopDisplay = function () {
        let height = document.documentElement.scrollTop 
                    || document.body.scrollTop
        if (height >= (document.body.clientHeight || document.documentElement.clientHeight) * 0.8) {
            goTop.style.display = "block"
        } else {
            goTop.style.display = "none"
        }
        goTop.focus();
    }
    window.onscroll = goTopDisplay;
    window.onload = goTopDisplay;
    window.onresize = goTopDisplay;
    goTop.onclick = function () {
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }
</script> -->
    <nav class="navbar navbar-expand-lg" id="navbar">
    <a class="navbar-brand" href="/">
        <!-- <img class="user-avatar" src="/images/avatar.png" alt="头像"> -->
        <img class="site-icon" src="https://linna-cy.github.io/old-blog/images/favicon.png" alt="icon">
        <div class="site-name gt-c-content-color-first">
            Linner&#39;s Blog
        </div>
    </a>

    <div id="to-top" style="flex: 1; height: 100%;"></div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    <span class="iconfont icon-zhuye"></span>
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    <span class="iconfont icon-guidang"></span>
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    <span class="iconfont icon-biaoqian"></span>
                    标签
                </a>
                
            </div>
            
            <!-- <div class="nav-item" id="toc">
                <a class="menu gt-a-link">
                    <span class="iconfont icon-mulu"></span>
                    目录
                </a>
            </div> -->
            <!-- <div class="nav-item" id="to-top">
                <a href="#top" class="menu gt-a-link">
                    <span class="iconfont icon-fanhuidingbu"></span>
                    返回顶部
                </a>
            </div> -->
        </div>
        <!-- 搜索框 -->
        <!-- <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1684376365462"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 7px; left: 10px;"></i>
            </form>
        </div> -->
        <div class="search-box">
            <i class="fas fa-search gt-c-content-color-first"></i>
            <form id="gridea-search-form" data-update="1684376365462"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'flex';
        } else {
            element.style.display = 'none';
        }
    }

    // 自动显示目录项
    // let toc = document.getElementById('toc');
    // let isPost = document.getElementById('isPost');
    // if (isPost == null) {
    //     toc.style.display = 'none';
    // }
    // else {
    //     toc.style.display = 'block';
    // }

    // toc.onclick = () => {

    // }

    // 点击导航栏转到页面顶部
    let toTop = document.getElementById("to-top");
    toTop.onclick = function () {
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }

    // let goTopDisplay = function () {
    //     let height = document.documentElement.scrollTop 
    //                 || document.body.scrollTop
    //     if (height >= (document.body.clientHeight || document.documentElement.clientHeight) * 0.8) {
    //         navbar.style.position = "fixed !important"
    //     } else {
    //         navbar.style.position = "static !important"
    //     }
    // }
    // window.onscroll = goTopDisplay;
    // window.onload = goTopDisplay;
    // window.onresize = goTopDisplay;
</script>


    <div id="background" class="background" style="background-image: url(https://gitcode.net/qq_22182345/myfiles/-/raw/master/img/4kcityscape.jpg);">
        <div class="post-header">
          <h2 class="post-title">
            SpringMVC 基础
          </h2>
          <div class="post-info">
            <span class="meta-item pc-show">
              <!-- icon -->
              <span class="language" data-lan="publish">发布于</span>
              <span class="publish-time">2023-02-20</span>
              <span class="post-meta-divider pc-show">|</span>
            </span>
            
            <span class="meta-item">
              <!-- icon -->
              <span class="pc-show language" data-lan="category-in">标签:</span>
               
              <a href="https://linna-cy.github.io/old-blog/boslKuyhk/"> <span>#Spring </span></a>  
              <a href="https://linna-cy.github.io/old-blog/MrL8MvLdJ_/"> <span>#Java </span></a>  
              <a href="https://linna-cy.github.io/old-blog/vvCs3Js_LL/"> <span>#JavaWeb </span></a>  
              <a href="https://linna-cy.github.io/old-blog/18uPZhlPeC/">
                <span>#Maven </span>
              </a>
               
            </span>
            <span class="post-meta-divider">|</span>
            
            <span class="meta-item">
              <!-- icon -->
              <span
                >22<span class="language" data-lan="minute"
                  >分钟</span
                ></span
              >
            </span>
            <span class="meta-item">
              <span class="post-meta-divider">|</span>
              <!-- icon -->
              <span
                >4571<span class="pc-show language" data-lan="words"
                  >字数</span
                ></span
              >
            </span>
          </div>
        </div>
    </div>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <div class="post-content">
                    <!-- <div id="toc-div">
                        <h1>目录</h1>
                        <ul class="markdownIt-TOC">
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">项目结构及基础环境配置</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83">项目环境</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E7%B1%BB">配置类</a></li>
<li><a href="#springmvc-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">SpringMVC 工作流程</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94">请求与响应</a>
<ul>
<li><a href="#%E6%8E%A5%E6%94%B6-url-%E5%8F%82%E6%95%B0">接收 URL 参数</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E5%8F%82%E6%95%B0">普通参数</a></li>
<li><a href="#pojo%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">POJO类型参数</a></li>
<li><a href="#%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">数组、集合类型参数</a></li>
<li><a href="#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F">日期格式</a></li>
</ul>
</li>
<li><a href="#json-%E6%95%B0%E6%8D%AE%E5%8F%82%E6%95%B0">JSON 数据参数</a></li>
<li><a href="#%E5%93%8D%E5%BA%94-json-%E6%95%B0%E6%8D%AE">响应 JSON 数据</a></li>
<li><a href="#rest-%E9%A3%8E%E6%A0%BC">REST 风格</a>
<ul>
<li><a href="#restful-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91">RESTful 快速开发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a>
<ul>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B9%A6%E5%86%99%E7%AE%80%E5%8C%96">拦截器配置书写简化</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">静态资源</a></li>
</ul>
</li>
</ul>

                        <hr>
                    </div> -->
                    
                        <h1>目录</h1>
                        <ul class="markdownIt-TOC">
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">项目结构及基础环境配置</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83">项目环境</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E7%B1%BB">配置类</a></li>
<li><a href="#springmvc-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">SpringMVC 工作流程</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94">请求与响应</a>
<ul>
<li><a href="#%E6%8E%A5%E6%94%B6-url-%E5%8F%82%E6%95%B0">接收 URL 参数</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E5%8F%82%E6%95%B0">普通参数</a></li>
<li><a href="#pojo%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">POJO类型参数</a></li>
<li><a href="#%E6%95%B0%E7%BB%84-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">数组、集合类型参数</a></li>
<li><a href="#%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F">日期格式</a></li>
</ul>
</li>
<li><a href="#json-%E6%95%B0%E6%8D%AE%E5%8F%82%E6%95%B0">JSON 数据参数</a></li>
<li><a href="#%E5%93%8D%E5%BA%94-json-%E6%95%B0%E6%8D%AE">响应 JSON 数据</a></li>
<li><a href="#rest-%E9%A3%8E%E6%A0%BC">REST 风格</a>
<ul>
<li><a href="#restful-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91">RESTful 快速开发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a>
<ul>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE%E4%B9%A6%E5%86%99%E7%AE%80%E5%8C%96">拦截器配置书写简化</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">静态资源</a></li>
</ul>
</li>
</ul>

                        <hr>
                    
                    <h1 id="简介">简介</h1>
<p>SpringMVC是Spring下的一个用于Web表现层开发的技术。相比Servlet，SpringMVC更加高效快捷。</p>
<p>SpringMVC流程如下：</p>
<ul>
<li>浏览器发送请求到Tomcat服务器；</li>
<li>Tomcat接收请求后，将请求交给SpringMVC中的<code>DispatcherServlet</code>（前端控制器）来处理。</li>
<li><code>DispatcherServlet</code>按照对应规则将请求分发到对应的<code>Bean</code>。</li>
<li><code>Bean</code>由我们自己编写来处理不同的请求。<br>
每个<code>Bean</code>中可以处理一个或多个不同的请求URL。</li>
</ul>
<blockquote>
<p><code>DispatcherServlet</code>和<code>Bean</code>对象都需要交给Spring容器来进行管理。</p>
</blockquote>
<p>综上，我们需要编写的内容为：</p>
<ul>
<li><code>Bean</code>对象；</li>
<li>请求URL和<code>Bean</code>对象对应关系的配置；</li>
<li>构建Spring容器。<br>
将<code>DispatcherServlet</code>和<code>Bean</code>对象交给容器管理。</li>
<li>配置Tomcat服务器。<br>
使Tomcat能够识别Spring容器，并将请求交给容器中的<code>DispatcherServlet</code>来分发请求。</li>
</ul>
<p>项目的基本实现步骤如下：</p>
<ol>
<li>创建Web工程（Maven结构），并在工程的<code>pom.xml</code>中添加SpringMVC和Servlet坐标。</li>
<li>创建SpringMVC控制器类（等同于Servlet功能）。</li>
<li>初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的<code>Bean</code>。</li>
<li>初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求。</li>
</ol>
<h2 id="项目结构及基础环境配置">项目结构及基础环境配置</h2>
<p>使用SpringMVC开发的项目结构如下：</p>
<ul>
<li>📁<code>project-file-name</code>
<ul>
<li>📁<code>src</code>
<ul>
<li>📁<code>main</code>
<ul>
<li>📁<code>java</code>
<ul>
<li>📁<code>com.linner</code>
<ul>
<li>📁<code>config</code> —— 配置类</li>
<li>📁<code>controller</code> —— 表现层</li>
<li>📁<code>dao</code> —— 持久层</li>
<li>📁<code>domain</code> —— 实体类</li>
<li>📁<code>service</code> —— 业务层</li>
</ul>
</li>
</ul>
</li>
<li>📁<code>resourcs</code></li>
<li>📁<code>webapp</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这种项目结构采用了SSM架构，即：</p>
<ul>
<li>表现层；</li>
<li>持久层；</li>
<li>业务层。</li>
</ul>
<p>通过IDEA创建SpringMVC项目步骤如下：</p>
<ol>
<li>创建基础的Maven-Archetype-Webapp项目。<br>
<img src="https://linna-cy.github.io/old-blog/post-images/1676947539616.png" alt="" loading="lazy"></li>
<li>补全项目结构：
<ul>
<li>📁<code>src</code>
<ul>
<li>📁<code>main</code>
<ul>
<li>📁<code>java</code></li>
<li>📁<code>resourcs</code></li>
<li>📁<code>webapp</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>修改<code>pom.xml</code>文件：<br>
将多余的内容删除，然后添加SpringMVC所需的依赖。如：</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.linner&lt;/groupId&gt;
  &lt;artifactId&gt;springmvc-demo&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;!-- SpringMVC所需依赖的坐标： --&gt;
    &lt;!-- Servlet坐标： --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
      &lt;version&gt;3.1.0&lt;/version&gt;
      &lt;!-- Servlet需要修改作用范围，否则会与Tomcat中的servlet-api包发生冲突 --&gt;
      &lt;!-- provided代表的是该包只在编译和测试的时候用 --&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- SpringMVC坐标： --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;port&gt;80&lt;/port&gt;
          &lt;path&gt;/&lt;/path&gt;
          &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<hr>
<h1 id="项目环境">项目环境</h1>
<p>使用SpringMVC构建Web项目，除了以上基础配置外，还需要导入其他配置。</p>
<p>DAO相关的坐标：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.16&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.5.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<hr>
<h1 id="配置类">配置类</h1>
<p><code>jdbc.properties</code>（数据库配置，放在项目中<code>resources</code>目录下）：</p>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql:///spring_db?useSSL=false&amp;characterEncoding=utf-8
jdbc.username=root
jdbc.password=root
</code></pre>
<p>SpringMVC项目至少需要<code>SpringConfig</code>和<code>SpringMvcConfig</code>这两个配置类。</p>
<ul>
<li>Spring：控制业务（Service）和功能（DataSource、SqlSessionFactoryBean、 MapperScannerConfigurer等）相关的Bean。</li>
<li>SpringMVC：加载表现层Bean（Controller）。</li>
</ul>
<p><code>SpringConfig</code>（启动Tomcat服务器时加载Spring配置类）：</p>
<pre><code class="language-java">@Configuration
@ComponentScan({&quot;com.linner.service&quot;})
@PropertySource(&quot;classpath:jdbc.properties&quot;)
@Import({JdbcConfig.class,MyBatisConfig.class})
@EnableTransactionManagement
public class SpringConfig {
}
</code></pre>
<blockquote>
<p>Spring需要管理的是<code>service</code>包和<code>dao</code>包。但<code>dao</code>包最终是交给<code>MapperScannerConfigurer</code>对象来进行扫描处理的。所以<code>SpringConfig</code>只需要扫描到<code>service</code>包即可。<br>
演示<code>@ComponentScan</code>的另一种用法（排除<code>controller</code>包中的Bean）：</p>
<pre><code class="language-java">@ComponentScan(value=&quot;com.linner&quot;,
  excludeFilters=@ComponentScan.Filter(
      type = FilterType.ANNOTATION,
      classes = Controller.class // 排除@Controller定义的Bean
  )
)
</code></pre>
<p>上面方法本质是使用<code>@ComponentScan</code>的<code>excludeFilters</code>属性设置过滤规则。</p>
<ul>
<li><code>type</code>：设置排除规则。
<ul>
<li><code>ANNOTATION</code>：按照注解排除。</li>
<li><code>ASSIGNABLE_TYPE</code>：按照指定的类型过滤。</li>
<li><code>ASPECTJ</code>：按照Aspectj表达式排除（基本上不会用）。</li>
<li><code>REGEX</code>：按照正则表达式排除。</li>
<li><code>CUSTOM</code>：按照自定义规则排除。<br>
<code>classes</code>：设置排除的具体注解类。</li>
</ul>
</li>
</ul>
</blockquote>
<p><code>SpringMvcConfig</code></p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.linner.controller&quot;)
public class SpringMvcConfig {
}
</code></pre>
<p>DAO相关配置类：</p>
<p><code>JdbcConfig</code>：</p>
<pre><code class="language-java">public class JdbcConfig {
    @Value(&quot;${jdbc.driver}&quot;)
    private String driver;
    @Value(&quot;${jdbc.url}&quot;)
    private String url;
    @Value(&quot;${jdbc.username}&quot;)
    private String username;
    @Value(&quot;${jdbc.password}&quot;)
    private String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }

    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource){
        DataSourceTransactionManager ds = new DataSourceTransactionManager();
        ds.setDataSource(dataSource);
        return ds;
    }
}
</code></pre>
<p><code>MyBatisConfig</code>：</p>
<pre><code class="language-java">public class MyBatisConfig {
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        factoryBean.setTypeAliasesPackage(&quot;com.linner.domain&quot;);
        return factoryBean;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer(){
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage(&quot;com.linner.dao&quot;);
        return msc;
    }
}
</code></pre>
<p><code>ServletConfig</code>（Web项目入口配置类）：</p>
<pre><code class="language-java">public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    protected String[] getServletMappings() {
        return new String[]{&quot;/&quot;};
    }
}
</code></pre>
<hr>
<h1 id="springmvc-工作流程">SpringMVC 工作流程</h1>
<p>SpringMVC的使用过程共分两个阶段：</p>
<ol>
<li>启动服务器初始化过程；
<ol>
<li>
<p>服务器启动，执行<code>ServletConfig</code>类，初始化Web容器。</p>
</li>
<li>
<p>根据<code>getServletConfigClasses</code>获取所需的SpringMVC配置类（这里是<code>SpringMvcConfig</code>）来初始化SpringMVC的容器。</p>
</li>
<li>
<p>加载<code>SpringMvcConfig</code>配置类。</p>
</li>
<li>
<p>执行<code>@ComponentScan</code>加载对应的<code>Bean</code>。<br>
扫描指定包下所有类上的注解，将所有的Controller类（如有<code>@Controller</code>、<code>@RestController</code>等注解的类）加载到容器中。</p>
</li>
<li>
<p>加载每一个<code>Controler</code>。<br>
使用<code>@RequestMapping</code>建立请求路径与<code>Controler</code>中的方法的对应关系。</p>
</li>
<li>
<p>执行<code>getServletMappings</code>方法，定义所有的请求都通过SpringMVC。如：</p>
<pre><code class="language-java">protected Spring[]  getServletMappings() {
    return new Spring[]{&quot;/&quot;};
}    
</code></pre>
<p><code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求。</p>
</li>
</ol>
</li>
<li>单次请求过程。
<ol>
<li>根据请求路径发送请求。</li>
<li>Web容器将符合设置的请求路径的请求交给SpringMVC处理。</li>
<li>解析请求路径。</li>
<li>执行匹配对应请求路径的方法。</li>
<li>将有<code>@ResponseBody</code>方法的返回值作为响应体返回给请求方。</li>
</ol>
</li>
</ol>
<hr>
<h1 id="请求与响应">请求与响应</h1>
<p>SpringMVC是Web层的框架，主要作用是接收请求、接收数据、响应结果。</p>
<p>编写Controller只需要在Controller类上使用<code>@Controller</code>注解即可。</p>
<h2 id="接收-url-参数">接收 URL 参数</h2>
<blockquote>
<p>接收URL参数，GET和POST请求的编写方式一致。<br>
如果要使用不同的方式接收请求，可以修改<code>@RequestMapping</code>注解：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/save&quot;, method = RequestMethod.GET)
</code></pre>
</blockquote>
<h3 id="普通参数">普通参数</h3>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    // 使用 [http://localhost/user/hello?name=张三] 访问
    // 返回响应体 Hello 张三!
    @RequestMapping(&quot;/hello&quot;)
    @ResponseBody
    public String hello(String name) {
        return &quot;Hello &quot; + name + &quot;!&quot;;
    }

    // 使用 [http://localhost/user/login?name=张三&amp;password=abc] 访问
    // 返回响应体 OK，终端输出 userName=张三; password=abc
    @RequestMapping(&quot;/login&quot;)
    @ResponseBody
    public String login(@RequestParam(&quot;name&quot;) String userName, String password) {
        System.out.println(&quot;userName=&quot; + userName + &quot;; password=&quot; + password);
        return &quot;OK&quot;;
    }

}
</code></pre>
<ul>
<li>请求路径（<code>@RequestMapping</code>）：<br>
请求路径使用<code>@RequestMapping</code>注解。注解中的值为请求路径。<br>
<code>@RequestMapping</code>可以作用在类和方法上。<br>
方法上定义的<code>@RequestMapping</code>是具体的请求路径。即，如果在方法上使用了<code>@RequestMapping</code>并且没有在类上使用<code>@RequestMapping</code>，那么该方法的请求路径即为方法上<code>@RequestMapping</code>中的值。<br>
类上定义的<code>@RequestMapping</code>是请求目录。即，如果在方法和类上均使用了<code>@RequestMapping</code>，那么该方法的请求路径需要加上类<code>@RequestMapping</code>注解中定义的目录。例如上方代码中的请求路径为<code>/user/hello</code>和。</li>
<li>请求参数：<br>
普通参数即URL地址传参。<br>
<strong>定义相同的地址参数名与方法形参变量名即可接收参数。</strong><br>
<strong>如果想要形参名与地址参数名不同则可使用<code>@RequestParam</code>注解定义地址参数名</strong>（如<code>login()</code>）。<br>
如果有多个请求参数则定义多个方法参数。</li>
<li>返回值：<br>
返回值使用<code>@ResponseBody</code>注解后直接在方法中使用<code>return</code>返回。这里注解<code>@ResponseBody</code>是指将返回值作为响应体。</li>
</ul>
<h3 id="pojo类型参数">POJO类型参数</h3>
<p>使用POJO类型接收参数，只需要让请求参数名与形参对象属性名相同即可。如果有嵌套的POJO参数，请求参数名与形参对象属性名相同，然后按照对象层次结构关系即可接收。</p>
<p>定义一个POJO类：</p>
<pre><code class="language-java">public class Address {
    private String province;
    private String city;
    // setter、getter and toString...
}
</code></pre>
<pre><code class="language-java">public class User {
    private Integer id;
    private String name;
    private String password;
    private Address address;
    // setter、getter and toString...
}
</code></pre>
<p>Controller：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    // 访问 [http://localhost/user/login?id=123&amp;password=abc&amp;name=张三&amp;address.province=广东&amp;address.city=广州]
    // 返回响应体 OK，终端输出 Login: User{id=123, name='张三', password='abc', address=Address{province='广东', city='广州'}}
    @RequestMapping(&quot;/login&quot;)
    @ResponseBody
    public String login(User user) {
        System.out.println(&quot;Login: &quot; + user);
        return &quot;OK&quot;;
    }

}
</code></pre>
<h3 id="数组-集合类型参数">数组、集合类型参数</h3>
<p>接收数组参数只需让请求参数名与形参名相同且请求参数为多个即可（形参为数组类型）。</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    // 访问 [http://localhost/user/setHobbies?id=123&amp;hobbies=唱歌,跳舞,Rap,打篮球]
    // 返回响应体 OK，终端输出 User 123's hobbyies: [唱歌, 跳舞, Rap, 打篮球]
    @RequestMapping(&quot;/setHobbies&quot;)
    @ResponseBody
    public String setHobbies(Integer id, String[] hobbies) {
        System.out.println(&quot;User &quot; + id + &quot;'s hobbies: &quot; + Arrays.toString(hobbies));
        return &quot;OK&quot;;
    }

}
</code></pre>
<p>使用集合类型形参接收参数，使用方式与数组不同（会报错）。因为SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象。</p>
<p>使用集合类型形参接收参数需要使用<code>@RequestParam</code>绑定参数关系。</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    // 访问方式与数组形式相同，响应体与终端输出也相同
    @RequestMapping(&quot;/setHobbies&quot;)
    @ResponseBody
    public String setHobbies(Integer id, @RequestParam List&lt;String&gt; hobbies) {
        System.out.println(&quot;User &quot; + id + &quot;'s hobbies: &quot; + hobbies);
        return &quot;OK&quot;;
    }

}
</code></pre>
<h3 id="日期格式">日期格式</h3>
<p>使用<code>@DateTimeFormat</code>可以设置参数的日期格式，如：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    // URL: http://localhost/user/setBirthday?id=123&amp;birthday=2023/1/1 18:23:40
    @RequestMapping(&quot;/setBirthday&quot;)
    @ResponseBody
    public String setBirthday(Integer id, @DateTimeFormat(pattern = &quot;yyyy/MM/dd HH:mm:ss&quot;) Date birthday) {
        System.out.println(&quot;User &quot; + id + &quot;'s birthday is &quot; + birthday);
        return &quot;OK&quot;;
    }
    
}
</code></pre>
<h2 id="json-数据参数">JSON 数据参数</h2>
<p>使用JSON传输需要添加相应依赖。SpringMVC默认使用的是jackson来处理json的转换：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在配置类中添加<code>@EnableWebMvc</code>注解来开启JSON数据类型自动转换：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.linner.controller&quot;)
@EnableWebMvc // 开启JSON数据类型自动转换
public class SpringMvcConfig {
}
</code></pre>
<p>使用JSON传输数据只需要在形参前添加<code>@ResponseBody</code>注解来将外部传递的JSON数据映射到形参到对象中：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    @RequestMapping(&quot;/login&quot;)
    @ResponseBody
    public String login(@RequestBody User user) {
        System.out.println(&quot;Login: &quot; + user);
        return &quot;OK&quot;;
    }

    @RequestMapping(&quot;/setHobbies&quot;)
    @ResponseBody
    public String setHobbies(Integer id, @RequestBody List&lt;String&gt; /* 也可以使用 String[] */ hobbies) {
        System.out.println(&quot;User &quot; + id + &quot;'s hobbies: &quot; + hobbies);
        return &quot;OK&quot;;
    }

}
</code></pre>
<ul>
<li>
<p><code>login()</code>：<br>
URL：<code>http://localhost/user/login</code><br>
JSON：</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;name&quot;: &quot;张三&quot;,
    &quot;password&quot;: &quot;123&quot;,
    &quot;address&quot;: {
        &quot;province&quot;: &quot;广东&quot;,
        &quot;city&quot;: &quot;广州&quot;
    }
} 
</code></pre>
</li>
<li>
<p><code>setHobbies</code>：<br>
URL：<code>http://localhost/user/setHobbies2?id=123</code><br>
JSON：</p>
<pre><code class="language-json">[&quot;唱歌&quot;, &quot;跳舞&quot;, &quot;Rap&quot;, &quot;打篮球&quot;]
</code></pre>
</li>
</ul>
<h2 id="响应-json-数据">响应 JSON 数据</h2>
<p>响应JSON数据需要依赖于<code>@ResponseBody</code>（在Controller中）和<code>@EnableWebMvc</code>（在配置类中）注解。将返回值设置为实体类对象，设置返回值类型为实体类类型，即可实现返回对应对象的JSON数据：</p>
<p>实体类：</p>
<pre><code class="language-java">public class Book {
    private Integer id;
    private String name;
    // constructor、setter、getter and toString ...
}
</code></pre>
<p>Controller:</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/books&quot;)
public class BookController {

    @RequestMapping(&quot;/search&quot;)
    @ResponseBody
    public Book search(int id) {
        return new Book(id, &quot;Hello SpringMVC&quot;);
    }

    @RequestMapping(&quot;/searchName&quot;)
    @ResponseBody
    public List&lt;Book&gt; searchName(String name) {
        System.out.println(&quot;Search the book &quot; + name);
        List books = new ArrayList&lt;Book&gt;();
        for (int i = 0; i &lt; 5; i++) {
            books.add(new Book(i, name + Integer.toString(i)));
        }
        return books;
    }

}
</code></pre>
<ul>
<li>
<p><code>searchName()</code>：<br>
URL：http://localhost/books/searchName?name=SpringMVC<br>
返回JOSN：</p>
<pre><code class="language-json">[
    {
        &quot;id&quot;: 0,
        &quot;name&quot;: &quot;SpringMVC0&quot;
    },
    {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;SpringMVC1&quot;
    },
    {
        &quot;id&quot;: 2,
        &quot;name&quot;: &quot;SpringMVC2&quot;
    },
    {
        &quot;id&quot;: 3,
        &quot;name&quot;: &quot;SpringMVC3&quot;
    },
    {
        &quot;id&quot;: 4,
        &quot;name&quot;: &quot;SpringMVC4&quot;
    }
]
</code></pre>
</li>
<li>
<p><code>search()</code>：<br>
URL：http://localhost/books/search?id=123<br>
返回JSON：</p>
<pre><code class="language-json">{
    &quot;id&quot;: 123,
    &quot;name&quot;: &quot;SpringMVC&quot;
}
</code></pre>
</li>
</ul>
<h2 id="rest-风格">REST 风格</h2>
<p>REST（Representational State Transfer，表现形式状态转换），是一种软件架构风格。REST的优点有：</p>
<ul>
<li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作。</li>
<li>简化书写。</li>
</ul>
<p>按照REST风格访问资源时使用行为动作区分对资源进行了何种操作：</p>
<ul>
<li>GET：查询；</li>
<li>POST：新增。</li>
<li>PUT：修改。</li>
<li>DELETE：删除。</li>
</ul>
<p>如：</p>
<ul>
<li><code>http://localhost/users</code>——GET：<br>
查询全部用户信息（查询）。</li>
<li><code>http://localhost/users/1</code>——GET：查询指定用户（id为1）信息（查询）。</li>
<li><code>http://localhost/users</code>——POST：添加用户信息（新增/保存）。</li>
<li><code>http://localhost/users</code>——PUT：修改用户信息（修改/更新）。</li>
<li><code>http://localhost/users/1</code>——DELETE：删除用户信息（删除）。</li>
</ul>
<blockquote>
<p>描述模块的名称通常使用复数，表示此类资源，而非单个资源。</p>
</blockquote>
<p>Example：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/users&quot;)
public class UserController {

    /**
     * 添加用户
     */
    @RequestMapping(method = RequestMethod.POST)
    @ResponseBody
    public String save(@RequestBody User user) {
        return &quot;OK&quot;;
    }

    /**
     * 删除用户
     */
    @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.DELETE)
    @ResponseBody
    public String delete(@PathVariable int id) {
        return &quot;OK&quot;;
    }

    /**
     * 修改用户
     */
    @RequestMapping(method = RequestMethod.PUT)
    @ResponseBody
    public String update(@RequestBody User user) {
        return &quot;OK&quot;;
    }

    /**
     * 根据用户id查询
     */
    @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)
    @ResponseBody
    public String searchById(@PathVariable int id) {
        return &quot;OK&quot;;
    }

    /**
     * 查询所有用户
     */
    @RequestMapping(method = RequestMethod.GET)
    @ResponseBody
    public String searchAll() {
        return &quot;OK&quot;;
    }
}
</code></pre>
<p>上方Controller中每个方法的<code>@RequestMapping</code>中都使用了<code>method</code>元素来确定请求方式。并且根据需要<code>save()</code>和<code>update()</code>都接收一个JSON数据。</p>
<p><code>delete()</code>和<code>searchById()</code>都使用了路径参数（<code>value = &quot;\{id}&quot;</code>）。指定路径参数后，需要在方法参数列表中添加名称相同的参数，并且用<code>@PathVariable</code>注解（<code>public String delete(@PathVariable int id)</code>）。</p>
<p>路径参数可以定义多个，如：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/{id}/{name}&quot;, method = RequestMethod.GET)
@ResponseBody
public String searchById(@PathVariable int id, @PathVariable String name) {
    return &quot;OK&quot;;
}
</code></pre>
<p>如果想要路径参数名与形参名不同，需要在<code>@PathVariable</code>中注明对应关系，如：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.DELETE)
@ResponseBody
public String delete(@PathVariable(&quot;id&quot;) int userId) {
    return &quot;OK&quot;;
}
</code></pre>
<h3 id="restful-快速开发">RESTful 快速开发</h3>
<ul>
<li>使用<code>@RestController</code>注解：<br>
将<code>@ResponseBody</code>注解提到类上，让所有的方法都有<code>@ResponseBody</code>的功能。<br>
<code>@RestController</code>注解正好相当于<code>@Controller</code>加上<code>@ResponseBody</code>的功能，所以可以使用<code>@RestController</code>替代它们。</li>
<li>使用<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>等替代<code>@RequestMapping</code>。<br>
例如<code>@GetMapping</code>就相当于<code>RequestMapping(method = RequestMethod.GET)</code>。</li>
</ul>
<p>Example：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/books&quot;)
public class BookController {

    /**
     * 搜索全部书籍
     */
    @GetMapping
    public String getAll() {
        return &quot;All Books&quot;;
    }

    /**
     * 搜索图书
     */
    @GetMapping(&quot;/{id}&quot;)
    public String getById(@PathVariable int id) {
        return &quot;Get by id &quot; + id;
    }

    /**
     * 保存图书
     */
    @PostMapping
    public String save(@RequestBody Book book) {
        return &quot;Save &quot; + book.toString();
    }

    /**
     * 修改图书
     */
    @PutMapping
    public String update(@RequestBody Book book) {
        return &quot;Update &quot; + book.toString();
    }

    /**
     * 删除图书
     */
    @DeleteMapping(&quot;/{id}&quot;)
    public String delete(@PathVariable int id) {
        return &quot;Delete by id&quot; + id;
    }

}
</code></pre>
<hr>
<h1 id="拦截器">拦截器</h1>
<p>拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行。拦截器可以在指定的发那个发调用前后执行预先设定的代码，可以阻止原始方法的执行。拦截器和过滤器在作用和执行顺序上很相似。它们的关系如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://linna-cy.github.io/old-blog/post-images/1630676903190.png" alt="" loading="lazy"></figure>
<p>创建拦截器类：</p>
<pre><code class="language-java">@Component  // 由SpringMVC来管理
public class BookInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;preHandle...&quot;);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;postHandle...&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(&quot;afterCompletion...&quot;);
    }
}
</code></pre>
<p>配置拦截器类：</p>
<pre><code class="language-java">@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport {
    @Autowired  // 自动装配
    private BookInterceptor bookInterceptor;

    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        // 添加（声明）拦截器并配置拦截规则
        // 可以同时配置多个规则
        registry.addInterceptor(bookInterceptor).addPathPatterns(&quot;/books&quot;, &quot;/books/*&quot;);
    }
}
</code></pre>
<p>让SpringMVC扫描到拦截器的配置类：</p>
<pre><code class="language-java">@Configuration
@ComponentScan({&quot;com.linner.controller&quot;, &quot;com.linner.config&quot;})
@EnableWebMvc
public class SpringMvcConfig {
}
</code></pre>
<p>运行程序，发送<code>books</code>开头的请求（如<code>http://localhost/books</code>），终端会有如下输出：</p>
<pre><code>preHandle...
getAll...
postHandle...
afterCompletion...
</code></pre>
<p>拦截器的执行顺序如下：</p>
<ol>
<li>执行<code>preHandle()</code>。
<ul>
<li><code>preHandle()</code>返回值为<code>true</code>：
<ol>
<li>执行请求路径相应的方法或下一个拦截器的<code>preHandle()</code>。</li>
<li>判断是否执行<code>postHandle()</code>：
<ul>
<li>Controller被执行（后续拦截器链中没有一个<code>preHandle()</code>返回值为<code>false</code>），执行<code>postHandle()</code>。</li>
<li>Controller没有被执行（后续拦截器链中存在一个<code>preHandle()</code>返回值为<code>false</code>），不执行<code>postHandle()</code>。</li>
</ul>
</li>
<li>执行<code>afterCompletion()</code>。</li>
</ol>
</li>
<li><code>preHandle()</code>返回值为<code>false</code>。</li>
</ul>
</li>
<li>结束。</li>
</ol>
<p>当配置多个拦截器时，形成拦截器链。多个<code>preHandle()</code>按照Interceptor被声明顺序执行；多个<code>postHandle()</code>按照Interceptor被声明顺序逆序执行。即，拦截器链的运行顺序参照拦截器添加顺序为准。</p>
<p>当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行。当拦截器运行中断，仅运行配置在前面的拦截器的<code>afterCompletion()</code>操作（<code>afterCompletion()</code>代表当前拦截器执行完成，与后续拦截器链中<code>preHandle()</code>的返回值和Controller是否被执行无关）。</p>
<h2 id="拦截器配置书写简化">拦截器配置书写简化</h2>
<p>Interceptor的配置类<code>SpingMvcSupport</code>可以书写在<code>SpringMvcConfig</code>中：</p>
<pre><code class="language-java">@Configuration
@ComponentScan({&quot;com.linner.controller&quot;})
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer {
    @Autowired
    private BookInterceptor bookInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(bookInterceptor).addPathPatterns(&quot;/books&quot;, &quot;/books/*&quot;);
    }
}
</code></pre>
<h2 id="静态资源">静态资源</h2>
<pre><code class="language-java">@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport {
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);
    }
}
</code></pre>
<ul>
<li><code>addResourceHandler()</code>：定义访问资源路径。</li>
<li><code>addResourceLocations()</code>：定义访问路径时的静态资源目录。</li>
</ul>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://linna-cy.github.io/old-blog/Java进阶/" class="post-title gt-a-link">
                    Java 进阶
                </a>
            </div>
        

        

        

        <!-- <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first"></div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://linna-cy.github.io/old-blog/atom.xml" target="_blank">RSS</a>
    </div>
</div>
 -->
    </div>
</div>
<script>
  hljs.highlightAll();
  // 开启代码高亮
  // hljs.initHighlightingOnLoad();
  // 行号显示
  // hljs.initLineNumbersOnLoad({ singleLine:true });
  // let tocDiv = document.getElementById('toc-div');
  // let toc = document.querySelector('#toc-div .markdownIt-TOC');
  // if (toc === null || toc === undefined) {
  //   tocDiv.style.display = 'none';
  // }

  setCodeAllNum();
</script>
</body>
</html>
