<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>SQL语句 | Linner&#39;s Blog</title>

<!-- 代码高亮： -->
<!-- <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css"> -->
<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script> -->

<link rel="shortcut icon" href="https://linna-cy.github.io/old-blog/favicon.ico?v=1684376365462">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://linna-cy.github.io/old-blog/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<link rel="stylesheet" href="https://linna-cy.github.io/old-blog/media/icons/iconfont.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!-- <script src="media/scripts/index.js"></script> -->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
    <script>
      // 计算代码行数
      let pxToNumber = function(px) {
        // let num = Number(px.replace("px", ""));
        let num = parseFloat(px);

        return num;
      };
      let getRow = function(elem) {
          let style = window.getComputedStyle(elem, null);
          // let lineHeight = style.lineHeight === "normal" ? style.fontSize : style.lineHeight;
          let lineHeight = style.lineHeight;

          let height = style.height;
          let padding = style.padding;
          // let isiOS = /(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent);
          let row = (pxToNumber(height)-pxToNumber(padding)) / pxToNumber(lineHeight);
          // if (isiOS) {
          //   row = pxToNumber(height) / pxToNumber(lineHeight);
          //   alert('ios!');
          // }
          // else {
          //   row = (pxToNumber(height)-pxToNumber(padding)) / pxToNumber(lineHeight);
          // }
          return parseInt(row);
      };
      
      // 获取行号文字
      let getRowNumString = function (row) {
          let num_str = new String('');
          for (let i = 1; i <= row; i++) {
              let num = new String(i.toString() + '\n');
              num_str = num_str + num;
          }
          return num_str;
      }

      // 指定代码块开启代码行号
      let setCodeNum = function(codeElem) {
          let pre = codeElem.parentElement;
          let span = document.createElement('span');
          span.innerText = getRowNumString(getRow(codeElem));
          let codeElemStyle = window.getComputedStyle(codeElem, null);
          span.style.display = 'inline-block';
          span.style.backgroundColor = "rgba(255,255,255,0)";
          span.style.color = 'rgba(255,255,255,0.4)';
          span.style.margin = 0;
          span.style.padding = 0;
          // span.style.borderRight = '1px #fff solid';
          span.style.paddingRight = 4;
          span.style.userSelect = 'none';
          span.style.textAlign = 'center';
          span.className = 'code-num';

          span.style.font = codeElemStyle.font;
          // span.style.height = codeElemStyle.height;
          span.style.paddingLeft = codeElemStyle.paddingRight;
          span.style.borderTopLeftRadius = codeElemStyle.borderTopRightRadius;
          span.style.borderBottomLeftRadius = codeElemStyle.borderBottomRightRadius;
          span.style.paddingTop = codeElemStyle.paddingTop;

          pre.style.display = 'flex';
          pre.style.overflowX = 'hidden';

          codeElem.style.borderTopLeftRadius = 0;
          codeElem.style.borderBottomLeftRadius = 0;
          codeElem.style.marginLeft = 0;
          codeElem.style.paddingLeft = span.style.paddingRight;
          codeElem.style.overflowX = 'auto';
          codeElem.style.display = 'inline-block';
          pre.insertBefore(span, codeElem);
      }

      // 设置代码块开启代码行号
      let setCodeAllNum = function() {
          let codeElems = document.querySelectorAll('pre > code');
          for (let i = 0; i < codeElems.length; i++) {
              codeElems[i].parentElement.className = 'code-pre';
              setCodeNum(codeElems[i]);
          }
      }
    </script>
</head>
<body>
<div class="main gt-bg-theme-color-first post-main">
    <!-- <div class="top">
    <span id="go-top" class="iconfont icon-shangxiazuoyouTriangle17"></span>
</div>
<script>
    let goTop = document.getElementById("go-top");
    let goTopDisplay = function () {
        let height = document.documentElement.scrollTop 
                    || document.body.scrollTop
        if (height >= (document.body.clientHeight || document.documentElement.clientHeight) * 0.8) {
            goTop.style.display = "block"
        } else {
            goTop.style.display = "none"
        }
        goTop.focus();
    }
    window.onscroll = goTopDisplay;
    window.onload = goTopDisplay;
    window.onresize = goTopDisplay;
    goTop.onclick = function () {
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }
</script> -->
    <nav class="navbar navbar-expand-lg" id="navbar">
    <a class="navbar-brand" href="/">
        <!-- <img class="user-avatar" src="/images/avatar.png" alt="头像"> -->
        <img class="site-icon" src="https://linna-cy.github.io/old-blog/images/favicon.png" alt="icon">
        <div class="site-name gt-c-content-color-first">
            Linner&#39;s Blog
        </div>
    </a>

    <div id="to-top" style="flex: 1; height: 100%;"></div>

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    <span class="iconfont icon-zhuye"></span>
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    <span class="iconfont icon-guidang"></span>
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    <span class="iconfont icon-biaoqian"></span>
                    标签
                </a>
                
            </div>
            
            <!-- <div class="nav-item" id="toc">
                <a class="menu gt-a-link">
                    <span class="iconfont icon-mulu"></span>
                    目录
                </a>
            </div> -->
            <!-- <div class="nav-item" id="to-top">
                <a href="#top" class="menu gt-a-link">
                    <span class="iconfont icon-fanhuidingbu"></span>
                    返回顶部
                </a>
            </div> -->
        </div>
        <!-- 搜索框 -->
        <!-- <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1684376365462"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 7px; left: 10px;"></i>
            </form>
        </div> -->
        <div class="search-box">
            <i class="fas fa-search gt-c-content-color-first"></i>
            <form id="gridea-search-form" data-update="1684376365462"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'flex';
        } else {
            element.style.display = 'none';
        }
    }

    // 自动显示目录项
    // let toc = document.getElementById('toc');
    // let isPost = document.getElementById('isPost');
    // if (isPost == null) {
    //     toc.style.display = 'none';
    // }
    // else {
    //     toc.style.display = 'block';
    // }

    // toc.onclick = () => {

    // }

    // 点击导航栏转到页面顶部
    let toTop = document.getElementById("to-top");
    toTop.onclick = function () {
        window.scrollTo({
            top: 0,
            behavior: "smooth"
        })
    }

    // let goTopDisplay = function () {
    //     let height = document.documentElement.scrollTop 
    //                 || document.body.scrollTop
    //     if (height >= (document.body.clientHeight || document.documentElement.clientHeight) * 0.8) {
    //         navbar.style.position = "fixed !important"
    //     } else {
    //         navbar.style.position = "static !important"
    //     }
    // }
    // window.onscroll = goTopDisplay;
    // window.onload = goTopDisplay;
    // window.onresize = goTopDisplay;
</script>


    <div id="background" class="background" style="background-image: url(https://gitcode.net/qq_22182345/myfiles/-/raw/master/img/4kcityscape.jpg);">
        <div class="post-header">
          <h2 class="post-title">
            SQL语句
          </h2>
          <div class="post-info">
            <span class="meta-item pc-show">
              <!-- icon -->
              <span class="language" data-lan="publish">发布于</span>
              <span class="publish-time">2022-01-11</span>
              <span class="post-meta-divider pc-show">|</span>
            </span>
            
            <span class="meta-item">
              <!-- icon -->
              <span class="pc-show language" data-lan="category-in">标签:</span>
               
              <a href="https://linna-cy.github.io/old-blog/r84-TDVc4/">
                <span>#SQL </span>
              </a>
               
            </span>
            <span class="post-meta-divider">|</span>
            
            <span class="meta-item">
              <!-- icon -->
              <span
                >55<span class="language" data-lan="minute"
                  >分钟</span
                ></span
              >
            </span>
            <span class="meta-item">
              <span class="post-meta-divider">|</span>
              <!-- icon -->
              <span
                >14107<span class="pc-show language" data-lan="words"
                  >字数</span
                ></span
              >
            </span>
          </div>
        </div>
    </div>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <div class="post-content">
                    <!-- <div id="toc-div">
                        <h1>目录</h1>
                        <ul class="markdownIt-TOC">
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>
<ul>
<li><a href="#%E8%A1%A8">表</a></li>
<li><a href="#%E6%A8%A1%E5%BC%8F">模式</a></li>
<li><a href="#%E8%A1%8C%E5%92%8C%E5%88%97">行和列</a>
<ul>
<li><a href="#%E5%88%97">列</a></li>
<li><a href="#%E8%A1%8C">行</a></li>
<li><a href="#%E4%B8%BB%E9%94%AE">主键</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">关系数据库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a></li>
<li><a href="#sql-%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB">SQL 语句分类</a></li>
<li><a href="#sql-%E8%AF%AD%E6%B3%95">SQL 语法</a></li>
<li><a href="#%E5%AD%97%E6%AE%B5">字段</a></li>
</ul>
</li>
<li><a href="#select-%E8%AF%AD%E5%8F%A5">SELECT 语句</a>
<ul>
<li><a href="#all-%E5%92%8C-distinct">ALL 和 DISTINCT</a></li>
<li><a href="#%E9%99%90%E5%88%B6%E8%BF%94%E5%9B%9E%E7%9A%84%E8%A1%8C">限制返回的行</a></li>
<li><a href="#order-by-%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE">ORDER BY 排序数据</a>
<ul>
<li><a href="#%E6%8C%87%E5%AE%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E5%90%91">指定排序方向</a></li>
</ul>
</li>
<li><a href="#where-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE">WHERE 过滤数据</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6">逻辑操作符</a></li>
<li><a href="#in-%E6%8C%87%E5%AE%9A%E6%9D%A1%E4%BB%B6%E8%8C%83%E5%9B%B4">IN 指定条件范围</a></li>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8B%BC%E6%8E%A5">拼接</a></li>
<li><a href="#as-%E6%8C%87%E5%AE%9A%E5%88%AB%E5%90%8D">AS 指定别名</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">数值处理函数</a></li>
<li><a href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">文本处理函数</a></li>
<li><a href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">日期和时间处理函数</a></li>
<li><a href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE">汇总数据</a></li>
</ul>
</li>
<li><a href="#group-by-%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84">GROUP BY 数据分组</a>
<ul>
<li><a href="#having-%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84">HAVING 过滤分组</a></li>
<li><a href="#%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F">分组和排序</a></li>
</ul>
</li>
<li><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2">子查询</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2">使用计算字段进行子查询</a></li>
</ul>
</li>
<li><a href="#join-%E8%81%94%E7%BB%93%E8%A1%A8">JOIN 联结表</a>
<ul>
<li><a href="#inner-join-%E5%86%85%E8%81%94%E7%BB%93">INNER JOIN 内联结</a></li>
<li><a href="#%E8%87%AA%E8%81%94%E7%BB%93">自联结</a></li>
<li><a href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93">自然联结</a></li>
<li><a href="#outer-join-%E5%A4%96%E8%81%94%E7%BB%93">OUTER JOIN 外联结</a></li>
<li><a href="#%E8%81%94%E7%BB%93-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%88%86%E7%BB%84">联结、聚合函数与分组</a></li>
</ul>
</li>
<li><a href="#union-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">UNION 组合查询</a></li>
<li><a href="#insert-%E8%AF%AD%E5%8F%A5">INSERT 语句</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A1%8C">插入完整的行</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E8%A1%8C%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">插入行的一部分</a></li>
<li><a href="#insert-select">INSERT SELECT</a></li>
<li><a href="#select-into">SELECT INTO</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">更新和删除数据</a>
<ul>
<li><a href="#update-%E8%AF%AD%E5%8F%A5">UPDATE 语句</a></li>
<li><a href="#delete-%E8%AF%AD%E5%8F%A5">DELETE 语句</a></li>
<li><a href="#update-%E5%92%8C-delete-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%87%86%E5%88%99">UPDATE 和 DELETE 的使用准则</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">创建和删除数据库</a></li>
<li><a href="#sql-%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">SQL 通用数据类型</a>
<ul>
<li><a href="#%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">时间数据格式</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8%E6%A0%BC">创建和操纵表格</a>
<ul>
<li><a href="#create-table-%E5%88%9B%E5%BB%BA%E8%A1%A8">CREATE TABLE 创建表</a></li>
<li><a href="#alter-table-%E6%9B%B4%E6%96%B0%E8%A1%A8%E5%AE%9A%E4%B9%89">ALTER TABLE 更新表定义</a></li>
<li><a href="#drop-table-%E5%88%A0%E9%99%A4%E8%A1%A8">DROP TABLE 删除表</a></li>
<li><a href="#truncate-table-%E5%88%A0%E9%99%A4%E8%A1%A8%E6%95%B0%E6%8D%AE">TRUNCATE TABLE 删除表数据</a></li>
<li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8">重命名表</a></li>
</ul>
</li>
<li><a href="#sql-%E7%BA%A6%E6%9D%9F">SQL 约束</a>
<ul>
<li><a href="#not-null-%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F">NOT NULL 非空约束</a></li>
<li><a href="#unique-%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F">UNIQUE 唯一约束</a></li>
<li><a href="#primary-key-%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F">PRIMARY KEY 主键约束</a></li>
<li><a href="#foreign-key-%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F">FOREIGN KEY 外键约束</a></li>
<li><a href="#check-%E6%A3%80%E6%9F%A5%E7%BA%A6%E6%9D%9F">CHECK 检查约束</a></li>
<li><a href="#default-%E9%BB%98%E8%AE%A4%E7%BA%A6%E6%9D%9F">DEFAULT 默认约束</a></li>
</ul>
</li>
<li><a href="#auto-increment-%E5%AD%97%E6%AE%B5">AUTO INCREMENT 字段</a></li>
<li><a href="#%E8%A7%86%E5%9B%BE">视图</a>
<ul>
<li><a href="#create-view-%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE">CREATE VIEW 创建视图</a></li>
<li><a href="#drop-view-%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE">DROP VIEW 删除视图</a></li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a>
<ul>
<li><a href="#create-index-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">CREATE INDEX 创建索引</a></li>
<li><a href="#drop-index-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95">DROP INDEX 删除索引</a></li>
</ul>
</li>
</ul>

                        <hr>
                    </div> -->
                    
                        <h1>目录</h1>
                        <ul class="markdownIt-TOC">
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>
<ul>
<li><a href="#%E8%A1%A8">表</a></li>
<li><a href="#%E6%A8%A1%E5%BC%8F">模式</a></li>
<li><a href="#%E8%A1%8C%E5%92%8C%E5%88%97">行和列</a>
<ul>
<li><a href="#%E5%88%97">列</a></li>
<li><a href="#%E8%A1%8C">行</a></li>
<li><a href="#%E4%B8%BB%E9%94%AE">主键</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">关系数据库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a></li>
<li><a href="#sql-%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB">SQL 语句分类</a></li>
<li><a href="#sql-%E8%AF%AD%E6%B3%95">SQL 语法</a></li>
<li><a href="#%E5%AD%97%E6%AE%B5">字段</a></li>
</ul>
</li>
<li><a href="#select-%E8%AF%AD%E5%8F%A5">SELECT 语句</a>
<ul>
<li><a href="#all-%E5%92%8C-distinct">ALL 和 DISTINCT</a></li>
<li><a href="#%E9%99%90%E5%88%B6%E8%BF%94%E5%9B%9E%E7%9A%84%E8%A1%8C">限制返回的行</a></li>
<li><a href="#order-by-%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE">ORDER BY 排序数据</a>
<ul>
<li><a href="#%E6%8C%87%E5%AE%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E5%90%91">指定排序方向</a></li>
</ul>
</li>
<li><a href="#where-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE">WHERE 过滤数据</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6">逻辑操作符</a></li>
<li><a href="#in-%E6%8C%87%E5%AE%9A%E6%9D%A1%E4%BB%B6%E8%8C%83%E5%9B%B4">IN 指定条件范围</a></li>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8B%BC%E6%8E%A5">拼接</a></li>
<li><a href="#as-%E6%8C%87%E5%AE%9A%E5%88%AB%E5%90%8D">AS 指定别名</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">数值处理函数</a></li>
<li><a href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">文本处理函数</a></li>
<li><a href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">日期和时间处理函数</a></li>
<li><a href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE">汇总数据</a></li>
</ul>
</li>
<li><a href="#group-by-%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84">GROUP BY 数据分组</a>
<ul>
<li><a href="#having-%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84">HAVING 过滤分组</a></li>
<li><a href="#%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F">分组和排序</a></li>
</ul>
</li>
<li><a href="#%E5%AD%90%E6%9F%A5%E8%AF%A2">子查询</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2">使用计算字段进行子查询</a></li>
</ul>
</li>
<li><a href="#join-%E8%81%94%E7%BB%93%E8%A1%A8">JOIN 联结表</a>
<ul>
<li><a href="#inner-join-%E5%86%85%E8%81%94%E7%BB%93">INNER JOIN 内联结</a></li>
<li><a href="#%E8%87%AA%E8%81%94%E7%BB%93">自联结</a></li>
<li><a href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93">自然联结</a></li>
<li><a href="#outer-join-%E5%A4%96%E8%81%94%E7%BB%93">OUTER JOIN 外联结</a></li>
<li><a href="#%E8%81%94%E7%BB%93-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%B8%8E%E5%88%86%E7%BB%84">联结、聚合函数与分组</a></li>
</ul>
</li>
<li><a href="#union-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">UNION 组合查询</a></li>
<li><a href="#insert-%E8%AF%AD%E5%8F%A5">INSERT 语句</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A1%8C">插入完整的行</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E8%A1%8C%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86">插入行的一部分</a></li>
<li><a href="#insert-select">INSERT SELECT</a></li>
<li><a href="#select-into">SELECT INTO</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">更新和删除数据</a>
<ul>
<li><a href="#update-%E8%AF%AD%E5%8F%A5">UPDATE 语句</a></li>
<li><a href="#delete-%E8%AF%AD%E5%8F%A5">DELETE 语句</a></li>
<li><a href="#update-%E5%92%8C-delete-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%87%86%E5%88%99">UPDATE 和 DELETE 的使用准则</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">创建和删除数据库</a></li>
<li><a href="#sql-%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">SQL 通用数据类型</a>
<ul>
<li><a href="#%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">时间数据格式</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8%E6%A0%BC">创建和操纵表格</a>
<ul>
<li><a href="#create-table-%E5%88%9B%E5%BB%BA%E8%A1%A8">CREATE TABLE 创建表</a></li>
<li><a href="#alter-table-%E6%9B%B4%E6%96%B0%E8%A1%A8%E5%AE%9A%E4%B9%89">ALTER TABLE 更新表定义</a></li>
<li><a href="#drop-table-%E5%88%A0%E9%99%A4%E8%A1%A8">DROP TABLE 删除表</a></li>
<li><a href="#truncate-table-%E5%88%A0%E9%99%A4%E8%A1%A8%E6%95%B0%E6%8D%AE">TRUNCATE TABLE 删除表数据</a></li>
<li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8">重命名表</a></li>
</ul>
</li>
<li><a href="#sql-%E7%BA%A6%E6%9D%9F">SQL 约束</a>
<ul>
<li><a href="#not-null-%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F">NOT NULL 非空约束</a></li>
<li><a href="#unique-%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F">UNIQUE 唯一约束</a></li>
<li><a href="#primary-key-%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F">PRIMARY KEY 主键约束</a></li>
<li><a href="#foreign-key-%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F">FOREIGN KEY 外键约束</a></li>
<li><a href="#check-%E6%A3%80%E6%9F%A5%E7%BA%A6%E6%9D%9F">CHECK 检查约束</a></li>
<li><a href="#default-%E9%BB%98%E8%AE%A4%E7%BA%A6%E6%9D%9F">DEFAULT 默认约束</a></li>
</ul>
</li>
<li><a href="#auto-increment-%E5%AD%97%E6%AE%B5">AUTO INCREMENT 字段</a></li>
<li><a href="#%E8%A7%86%E5%9B%BE">视图</a>
<ul>
<li><a href="#create-view-%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE">CREATE VIEW 创建视图</a></li>
<li><a href="#drop-view-%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE">DROP VIEW 删除视图</a></li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a>
<ul>
<li><a href="#create-index-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">CREATE INDEX 创建索引</a></li>
<li><a href="#drop-index-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95">DROP INDEX 删除索引</a></li>
</ul>
</li>
</ul>

                        <hr>
                    
                    <h1 id="基本概念">基本概念</h1>
<p><strong>SQL</strong>（<strong>Structured Query Language</strong>，发音为 sequal）是一种专门用来与数据库沟通的语言。通过 SQL，用户可以对数据库进行各种操作。</p>
<blockquote>
<p>标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSISQL。</p>
</blockquote>
<hr>
<h2 id="数据库">数据库</h2>
<p><strong>数据库</strong>（<strong>database</strong>）是一个用于保存有组织的数据的容器或数据集合。</p>
<p>每个数据库都有唯一的标识符。</p>
<hr>
<h3 id="表">表</h3>
<p><strong>表</strong>（<strong>table</strong>）是某种特定类型数据的结构化清单，用于存储某种特定类型的数据。</p>
<p>在同一个数据库中的每个表都有一个唯一的标识符来标识自己。因此，在同个数据库中，不能拥有两个名称相同的表，但在不同的数据库中可以使用相同的表名。</p>
<hr>
<h3 id="模式">模式</h3>
<p><strong>模式</strong>（<strong>schema</strong>）是一种关于数据库和表的布局及特性的信息。它是用来描述数据库中表的特性（如，存储的数据类型、数据的分解方式、各部分的信息的命名），或描述整个数据库（和其中表的关系）。</p>
<hr>
<h3 id="行和列">行和列</h3>
<h4 id="列">列</h4>
<p><strong>列</strong>（<strong>column</strong>）是表中的一个字段（即，表的组成部分）。所有的表都是由一个或多个列组成的。列存储表中的某部分信息，且这部分信息必须是同一种数据类型（<strong>datatype</strong>）。</p>
<p>数据类型限制（或允许）该列中存储的数据的种类。它还能帮助正确地分类数据，并在优化磁盘使用方面起重要的作用。</p>
<p>利用特定的列，可以对数据进行分类和过滤。所以，数据分解十分重要。</p>
<p>数据类型及其名称是 SQL 不兼容的重要原因之一。对于不同的 DBMS，大多数基本数据类型都得到了一致的支持，但许多高级数据类型却没有。</p>
<hr>
<h4 id="行">行</h4>
<p>表中每一条记录的数据都是按<strong>行</strong>（<strong>row</strong>）存储的。</p>
<hr>
<h4 id="主键">主键</h4>
<p><strong>主键</strong>（<strong>primary key</strong>）是用来唯一标识表中每一行的列（如国际标准书号 ISBN 就可作为主键），可以是一列或多列。</p>
<p>满足以下条件的列即可作为主键：</p>
<ol>
<li>
<p>任意两行都不具有相同的主键值。</p>
</li>
<li>
<p>每一行都必须具有一个主键值（主键列不允许空值 NULL）。</p>
</li>
<li>
<p>主键列中的值不允许修改或更新。</p>
</li>
<li>
<p>主键值不能重用（即使某行从表中删除，它的主键依然不能赋给以后的新行）。</p>
</li>
</ol>
<p>在使用多列作为主键时，上述条件必须应用到所有列，即所有列值的组合必须是唯一的（但不同列中可以存在相同的值）。</p>
<hr>
<h2 id="关系数据库">关系数据库</h2>
<p>关系数据库由关系表组成，而关系表的设计就是要把信息分解成多个表，一类数据一个表。各表通过某些共同的值互相关联。</p>
<p>常见的两个关系表都会有至少一个相同类型且表示相同的列，对于其中一个表，该列是这个表的主键，从而能使另一个表甚至关系数据库中的其他表通过这个主键对应到这个表中的行。</p>
<p>一个优秀的关系数据库通常具有以下优点：</p>
<ul>
<li>
<p>关系库中的每个表中的每个行的信息重复很少，减少了时间和空间的浪费。</p>
</li>
<li>
<p>如果信息有更新，仅需更新对应的表中的数据。</p>
</li>
<li>
<p>数据是一致的（没有重复的数据），使得处理数据和生成报表更简单。</p>
</li>
</ul>
<p>总结：关系数据库的<strong>可伸缩性</strong>（<strong>scale</strong>）远比非关系数据库要好。</p>
<blockquote>
<p>可伸缩是指，能够适应不断增加的工作量而不失败。</p>
</blockquote>
<hr>
<h2 id="数据库管理系统">数据库管理系统</h2>
<p><strong>数据库管理系统</strong>（<strong>DataBase Management System</strong>，<strong>DBMS</strong>）是一种用于创建和操纵数据库的软件。</p>
<p>绝大多数 DBMS 都支持 ANSI SQL，但一些 DBMS 有自己的扩展。不同的 SQL 实现有自己的名称（如 Oracle 的 PL/SQL、微软 SQL Server 的 Transact-SQL 等）。</p>
<p>DBMS 可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体的数据。</p>
<p>数据库管理系统、数据库和表的关系：</p>
<hr>
<h2 id="sql-语句分类">SQL 语句分类</h2>
<ol>
<li>
<p><strong>DDL</strong>（<strong>Data Definition Language</strong>，<strong>数据定义语言</strong>）：用来定义数据库对象：数据库，表，列等。<br>
关键字：<code>create</code>、<code>drop</code>、<code>alter</code> 等。</p>
</li>
<li>
<p><strong>DML</strong>（<strong>Data Manipulation Language</strong>，<strong>数据操作语言</strong>）：用来对数据库中表的数据进行增删改。<br>
关键字：<code>insert</code>、<code>delete</code>、<code>update</code> 等。</p>
</li>
<li>
<p><strong>DQL</strong>（<strong>Data Query Language</strong>，<strong>数据查询语言</strong>）：用来查询数据库中表的记录。<br>
关键字：<code>select</code>、<code>where</code> 等。</p>
</li>
<li>
<p><strong>DCL</strong>（<strong>Data Control Language</strong>，<strong>数据控制语言</strong>）：用来定义数据库的访问权限和安全级别，及创建用户。<br>
关键字：<code>GRANT</code>、<code>REVOKE</code> 等。</p>
</li>
</ol>
<hr>
<h2 id="sql-语法">SQL 语法</h2>
<ul>
<li>
<p>SQL语句可以单行或多行书写，以分号结尾。</p>
</li>
<li>
<p>可使用空格和缩进来增强语句的可读性。</p>
</li>
<li>
<p>大多数数据库的 SQL 语句不区分大小写，关键字建议使用大写（可以提高运行速度）。</p>
</li>
</ul>
<hr>
<h2 id="字段">字段</h2>
<p><strong>字段</strong>（<strong>filed</strong>）基本上与列的意思相同，但字段这个术语通常在计算字段这种场合下使用。</p>
<hr>
<h1 id="select-语句">SELECT 语句</h1>
<p>任何 SQL 语句都是<strong>查询</strong>（<strong>query</strong>）。但此术语一般指 SELECT 语句。</p>
<hr>
<ul>
<li>
<p>检索列：</p>
<pre><code class="language-sql">-- 从 tab_name 中检索出filed1, filed2 等列（字段）
-- 可以检索单个列或多个列
SELECT filed1, filed2, ...
FROM tab_name;
</code></pre>
<p>列的顺序是按照指令中指出的列名的顺序显示。行的顺序是按照存储在物理内存中的顺序显示。</p>
<hr>
</li>
<li>
<p>使用<strong>通配符</strong> <code>*</code> 检索表中的所有列：</p>
<pre><code class="language-sql">-- 检索出 tab_name 中所有的列
SELECT *
FROM tab_name;
</code></pre>
<p>一般情况下，返回的列是按照存储在物理内存中的顺序显示的，并没有特定顺序。可能是按照数据被添加到表中的顺序显示（在没有增删数据的情况下），也可能不是（在有数据进行过更新或删除，这个顺序将会受到 DBMS 重用回收存储空间的方式的影响）。</p>
<p>使用通配符可以很方便地显示表中所有的列（包括名字未知的列），但这么做可能会降低检索速度和应用程序的性能（因为程序会检索所有表中的所有列）。</p>
</li>
</ul>
<hr>
<h2 id="all-和-distinct">ALL 和 DISTINCT</h2>
<p>可以在列名前指定 <code>ALL</code>（默认）和 <code>DISTINCT</code> 关键字，它们表示：</p>
<ul>
<li>
<p><code>ALL</code> —— 列出当前指定的列的所有行。</p>
</li>
<li>
<p><code>DISTINCT</code> —— 列出由当前所有列组合的不重复的行。</p>
</li>
</ul>
<p>可以对聚集函数使用 <code>ALL</code> 和 <code>DISTINCT</code> 关键字指定。</p>
<ul>
<li>
<p><code>ALL</code> —— 默认选项，包含所有的行，对聚集函数指定 <code>ALL</code>（可忽略）表示对所有的行执行计算。</p>
</li>
<li>
<p><code>DISTINCT</code> —— 指定 <code>DISTINCT</code>，包含不重复的行。</p>
<ul>
<li>
<p>对聚集函数指定 <code>DISTINCT</code> 表示只对不重复的行进行计算。</p>
</li>
<li>
<p>使用 <code>DISTINCT</code> 必须明确指出列名，而不能使用 <code>*</code>。</p>
</li>
</ul>
</li>
</ul>
<p>列出不重复的行：</p>
<pre><code class="language-sql">-- filed1, filed2, ... 不重复
SELECT DISTINCT filed1, filed2, ...
FROM tab_name;
</code></pre>
<p><code>DISTINCT</code> 作用于所有指定的列，该 SELECT 语句会返回所有不重复的 <code>filed1, filed2, ...</code> 组合的行。使用 <code>DISTINCT *</code> 可以返回由所有列组合的不重复的行。</p>
<hr>
<h2 id="限制返回的行">限制返回的行</h2>
<p>各 DBMS 实现并不相同：</p>
<ul>
<li>
<p>SQL Server：使用 <code>TOP</code> 关键字。</p>
<pre><code class="language-sql">-- 返回前 n 行
-- n 是任一正整数
SELECT TOP n filed1, filed2, ...
FROM tab_name;
</code></pre>
<hr>
</li>
<li>
<p>DB2：<code>FETCH FIRST n ROWS ONLY</code>。</p>
<pre><code class="language-sql">-- 返回前 n 行
-- n 是任一正整数
SELECT filed1, filed2, ...
FROM tab_name
FETCH FIRST n ROWS ONLY;
</code></pre>
<hr>
</li>
<li>
<p>Oracle：基于 <code>ROWNUM</code>（行计数器）。</p>
<pre><code class="language-sql">-- 返回前 n 行
-- n 是任一正整数
SELECT filed1, filed2, ...
FROM tab_name
WHERE ROWNUM &lt;= n;
</code></pre>
<hr>
</li>
<li>
<p>MySQL、MariaDB、PostgreSQL and SQLite：使用 <code>LIMIT</code> 子句。</p>
<pre><code class="language-sql">-- 返回前 n 行
-- n 是任一正整数
SELECT filed1, filed2, ...
FROM tab_name
LIMIT n;

</code></pre>
<pre><code class="language-sql">-- 返回从第 m 行开始的前 n 行
-- n 是任一正整数，m 是任一非负整数
SELECT filed1, filed2, ...
FROM tab_name
LIMIT n OFFSET m;
</code></pre>
<p>在 MySQL、MariaDB 和 SQLite 中，上条指令可简化为：</p>
<pre><code class="language-sql">-- 返回从第 m 行开始的前 n 行
-- n 是任一正整数，m 是任一非负整数
-- m 指定开始的行数，n 指定返回的行数
SELECT filed1, filed2, ...
FROM tab_name
LIMIT m, n;
</code></pre>
<p>行是从 0 开始计数。</p>
</li>
</ul>
<hr>
<h2 id="order-by-排序数据">ORDER BY 排序数据</h2>
<ol>
<li>
<p>使用 <code>ORDER BY</code> 子句取一个或多个列的名字，据此对数据进行排序：</p>
<pre><code class="language-sql">-- order1, order2, ... 是排序的依据
-- 该语句会先对 order1 进行排序
-- 仅在具有多行相同 order1 值时，才按照 order2 排序
SELECT filed1, filed2, ...
FROM tab_name
ORDER BY order1, order2, ...;
</code></pre>
<p><code>ORDER BY</code> 子句必须是 SELECT 语句中的最后一条子句。默认是升序排序（从 A 到 Z）。</p>
<hr>
</li>
<li>
<p>按相对列位置进行排序：</p>
<pre><code class="language-sql">-- n1、n2 …… 是小于或等于指定的列的总数的正整数
-- n1、n2 …… 这组数中的每两个数都不相等
SELECT filed1, filed2, ...
FROM tab_name
ORDER BY n1, n2, ...;
</code></pre>
<p>按相对位置排序的好处是不用输入列名，但有可能会造成错用列进行排序（特别是在对 SELECT 清单进行更改时）。</p>
</li>
</ol>
<p>实际列名排序和相对列位置排序可混合使用。</p>
<blockquote>
<p>📌最好的排序方式是，对冗长的列名重命名，然后使用列名进行排序。这样可以减少错误的出现。</p>
</blockquote>
<hr>
<h3 id="指定排序方向">指定排序方向</h3>
<p>指定排序的关键字：<code>ASC</code> —— 升序排序、<code>DESC</code> —— 降序排序。<code>ASC</code> 和 <code>DESC</code> 必须对每一列进行指定，因为它们只会对直接位于其前面的列名指定排序方式。可以对某一列指定 <code>ASC</code>（或 <code>DESC</code>）后对其它列指定 <code>DESC</code>（或 <code>ASC</code>）。</p>
<pre><code class="language-sql">-- order1, order2, ... 是排序的依据，且都被指定了升序排序
SELECT filed1, filed2, ...
FROM tab_name
ORDER BY order1 ASC, order2, ...
</code></pre>
<ol>
<li>
<p><code>DESC</code> 关键字指定降序排序。</p>
<pre><code class="language-sql">-- order1, order2, ... 是排序的依据，且都被指定了降序排序
SELECT filed1, filed2, ...
FROM tab_name
ORDER BY order1 DESC, order2 DESC, ...;
</code></pre>
</li>
<li>
<p>对某些列指定升序排序，对另外某些列指定升序排序。</p>
<pre><code class="language-sql">-- asc_order1, asc_order2, ... 都是指定升序排序
-- desc_order1, desc_order2, ... 都是指定降序排序
SELECT filed1, filed2, ...
FROM tab_name
ORDER BY asc_order1 ASC, asc_order2, ..., desc_order1 DESC, desc_order2 DESC, ...;
</code></pre>
</li>
</ol>
<p>大多数 DBMS 默认使用字典（dictionary）排序（即大小写字母被视为相同），但许多 DBMS 允许改变这种方式。</p>
<hr>
<h2 id="where-过滤数据">WHERE 过滤数据</h2>
<p>使用 <code>WHERE</code> 子句能够根据指定的<strong>搜索条件</strong>（<strong>search criteria</strong>），检索用户需要的数据。搜索条件也被称为<strong>过滤条件</strong>（<strong>filter condition1</strong>）。</p>
<ul>
<li>
<p>检索单一条件：</p>
<pre><code class="language-sql">-- condition1 是表中任一列名
-- condition1 的类型和 n 的类型要一致
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition11 = n;
</code></pre>
<p>数据也可以在应用层进行过滤，但当 DBMS 返回的数据超出实际所需的数据时，会影响应用的性能，并且降低应用的可伸缩性，这还会造成网络宽带的浪费（服务器不得不通过网络发送多余的数据）。</p>
<hr>
</li>
<li>
<p><strong>WHERE 子句操作符</strong>（条件操作符）：</p>
<p>并非所有 DBMS 都支持所有的操作符，某些 DBMS 可能不支持个别操作符。</p>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>说明</strong></th>
<th><strong>操作符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>等于</td>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code> or <code>!=</code></td>
<td>不等于</td>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>!&gt;</code></td>
<td>不大于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>BETWEEN</code></td>
<td>范围在指定的两个值之间</td>
</tr>
<tr>
<td><code>!&lt;</code></td>
<td>不小于</td>
<td><code>IS NULL</code></td>
<td>为 NULL 的值</td>
</tr>
</tbody>
</table>
<hr>
</li>
<li>
<p>使用 <code>BETWEEN</code> 在指定范围内检索：</p>
<pre><code class="language-sql">-- condition1 是表中任一列名
-- condition1 的类型和 n 、m 的类型要一致
-- n 和 m 为低端值和高端值
-- 检索时匹配的值包括 n 和 m
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition11 BETWEEN n AND m;
</code></pre>
<hr>
</li>
<li>
<p>使用 <code>IS NULL</code> 检索空值：</p>
<pre><code class="language-mysql">-- condition1 是表中任一列名
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition11 IS NULL;
</code></pre>
</li>
<li>
<p><code>IS NOT NULL</code> 检索不为空值的行：</p>
<pre><code class="language-sql">-- condition1 是表中任一列名
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition11 IS NOT NULL;
</code></pre>
</li>
</ul>
<hr>
<h3 id="逻辑操作符">逻辑操作符</h3>
<p>可以在一条 <code>WHERE</code> 子句中包含任意数量的<strong>逻辑操作符</strong>（<strong>logical operator</strong>），且允许两者结合以进行复杂、高级的过滤。</p>
<ol>
<li>
<p><code>AND</code> 操作符检索满足所有给定条件的行：</p>
<pre><code class="language-sql">-- condition11，condition12 …… 是包含条件操作符的子句
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition11 AND condition12
    AND ...;
</code></pre>
<hr>
</li>
<li>
<p><code>OR</code> 操作符检索满足任一条件的行：</p>
<pre><code class="language-sql">-- condition11，condition12 …… 是包含条件操作符的子句
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition11 OR condition12
    OR ...;
</code></pre>
<p>许多 DBMS 在使用 <code>OR</code> 操作符时，当第 1 个条件满足的情况下，就不再计算第 2 个条件。</p>
<hr>
</li>
<li>
<p><code>NOT</code> 操作符是否定操作符，否定跟随在其后的条件。</p>
<pre><code class="language-sql">-- condition1 是任意条件子句
SELECT filed1, filed2, ...
FROM tab_name
WHERE NOT condition11;
</code></pre>
<p>大多数 DBMS 允许使用 NOT 否定任何条件。</p>
</li>
</ol>
<hr>
<h3 id="in-指定条件范围">IN 指定条件范围</h3>
<p><code>IN</code> 操作符用来指定条件范围，匹配范围中指定的每个条件。<code>IN</code> 操作符后的括号中的合法值用逗号分隔。</p>
<pre><code class="language-sql">-- condition1 是表中任一列
-- val1, val2, ... 是与 condition1 类型相同的一组合法值
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition1 IN (val1, val2, ...);
</code></pre>
<p><code>IN</code> 操作符和 <code>OR</code> 操作符的功能类似，但在某些方面，<code>IN</code> 操作符有其优点。</p>
<ul>
<li>
<p>在有很多合法选项时，<code>IN</code> 操作符可读性更强。</p>
</li>
<li>
<p>与其他 <code>AND</code> 和 <code>OR</code> 操作符组合使用 <code>IN</code> 时，求值顺序更容易管理。</p>
</li>
<li>
<p><code>IN</code> 操作符一般比一组 <code>OR</code> 操作符执行得更快。</p>
</li>
<li>
<p><code>IN</code> 操作符可包含其他 SELECT 语句，能更动态地建立 WHERE 子句。</p>
</li>
</ul>
<hr>
<h3 id="通配符">通配符</h3>
<p><strong>通配符</strong>（<strong>wildcard</strong>）是用于匹配值的一部分的特殊字符。</p>
<p><strong>搜索模式</strong>（<strong>search pattern</strong>）由字面值、通配符或两者组合构成的搜索条件。</p>
<p>利用通配符，可以创建比较特定数据的搜索模式。要使用通配符，必须在搜索子句中使用 <code>LIKE</code> 操作符。且通配符只能用于字符串。</p>
<ul>
<li>
<p>使用通配符搜索一般比其他简单搜索耗费更长的处理时间。</p>
</li>
<li>
<p>不要过度使用通配符。</p>
</li>
<li>
<p>尽量不要把通配符用在搜索模式的开始处（通配符置于开始处是最慢的）。</p>
</li>
<li>
<p>不同类型的通配符可以混合使用。</p>
</li>
</ul>
<hr>
<ol>
<li>
<p><code>%</code> 通配符：表示任何字符出现任意次数。</p>
<pre><code class="language-sql">-- condition1 是表中任一字符类型的列
-- 该语句表示在 condition1 列中搜索以 ABC 开头的字符串
SELECT filed1, filed2, ...
FROM tab_name
WHRER condition1 LIKE 'ABC%';
</code></pre>
<ul>
<li>
<p>包含 <code>ABC</code> 的字符串：<code>'%ABC%'</code>；</p>
</li>
<li>
<p>以 <code>ABC</code> 结尾的字符串：<code>'ABC%'</code>；</p>
</li>
<li>
<p>以 <code>A</code> 为开头，以 <code>B</code> 为结尾的字符：<code>'A%B'</code>；</p>
</li>
<li>
<p>某些 DBMS 会用空格来填补字段内容，可能会对该搜索模式造成影响。</p>
</li>
<li>
<p>包含 <code>AB</code> 和 <code>CD</code> 的字符串：<code>'%AB%CD%'</code>；</p>
</li>
<li>
<p>……</p>
</li>
</ul>
<hr>
</li>
<li>
<p><code>_</code> 通配符：表示匹配单个任意字符。</p>
<pre><code class="language-sql">-- condition1 是表中任一字符类型的列
-- 该语句表示匹配以 ABC 结尾，开头为任意一个字符的字符串
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition1 LIKE '_ABC';
</code></pre>
<hr>
</li>
<li>
<p><code>[]</code> 通配符：用来指定一个字符集，它必须匹配指定位置的一个字符。</p>
<p>Example:</p>
<pre><code class="language-sql">-- condition1 是表中任一字符类型的列
-- 该语句匹配以 A 或 B 其中之一与 C 的组合的字符串（仅有两个字符）
SELECT filed1, filed2, ...
FROM tab_name
WHERE condition1 LIKE '[AB]C';
</code></pre>
<p>使用 <code>^</code> 可以来否定 <code>[]</code> 定义的字符集：<code>'[^AB]'</code> —— 该模式会匹配除了 <code>A</code> 和 <code>B</code> 之外的任何一个字符。</p>
</li>
</ol>
<hr>
<h1 id="拼接">拼接</h1>
<p><strong>拼接</strong>（<strong>concatenate</strong>）是指将值联结到一起（将一个值附加到另一个值）构成单个值。</p>
<ul>
<li>
<p>SQL Server 使用 <code>+</code> 号拼接：</p>
<pre><code class="language-sql">-- filed1, filed2, filed3, ... 可以是任意同类型的字段
SELECT filed1 + filed2 + filed3 + ...
FROM tab_name;
</code></pre>
</li>
<li>
<p>DB2、Oracle、PostgreSQL 和 SQLite 使用 <code>||</code>：<code>filed1 || filed2 || filed3 || ...</code>。</p>
</li>
<li>
<p>MySQL 和 MariaDB 使用 <code>Concat()</code> 函数：<code>Concat(filed1, filed2, filed3, ...)</code>。</p>
</li>
</ul>
<p>某些 DBMS 会用空格填充字段，可以使用 <code>RTRIM()</code> 函数来清除这些空格。</p>
<hr>
<h1 id="as-指定别名">AS 指定别名</h1>
<p>使用 <code>AS</code> 关键字赋予字段或值一个<strong>别名</strong>（<strong>alias</strong>）。别名既可以是一个单词，也可以是一个字符串，字符串需用引号括起。使用别名时不应使用表中实际的列名，虽然这样做也算合法，但可能会产生模糊的错误消息。</p>
<pre><code class="language-sql">-- filed 是一个字段或值
-- alias 是 filed 的别名
-- 赋予别名后可以在接下来的子句中使用别名来替代这个字段
SELECT filed AS alias
FROM tab_name
ORDER BY alias;
</code></pre>
<hr>
<h1 id="函数">函数</h1>
<h2 id="数值处理函数">数值处理函数</h2>
<p>数值处理函数仅处理数值数据，是最一致、最统一的函数。</p>
<p>常用的数值处理函数：</p>
<table>
<thead>
<tr>
<th><strong>Functions</strong></th>
<th><strong>Explain</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ABC()</code></td>
<td>返回一个数的绝对值。</td>
</tr>
<tr>
<td><code>COS()</code></td>
<td>返回一个角度的余弦。</td>
</tr>
<tr>
<td><code>EXP()</code></td>
<td>返回一个数的指数值。</td>
</tr>
<tr>
<td><code>PI()</code></td>
<td>返回圆周率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span> 值。</td>
</tr>
<tr>
<td><code>SIN()</code></td>
<td>返回一个角度的正弦。</td>
</tr>
<tr>
<td><code>SQRT()</code></td>
<td>返回一个数的平方根。</td>
</tr>
<tr>
<td><code>TAN()</code></td>
<td>返回一个角度的正切。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="文本处理函数">文本处理函数</h2>
<p>常用的文本处理函数：</p>
<table>
<thead>
<tr>
<th><strong>Functions</strong></th>
<th><strong>Explain</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LEFT(str, num)</code></td>
<td>返回字符串 <code>str</code> 左边前 <code>num</code> 个字符。</td>
</tr>
<tr>
<td><code>LENGTH(str)</code>、
<code>DATALENGTH(str)</code>
or
<code>LEN(str)</code></td>
<td>返回字符串的长度。</td>
</tr>
<tr>
<td><code>LOWER(str)</code></td>
<td>将字符串转换为小写。</td>
</tr>
<tr>
<td><code>LTRIM(str)</code></td>
<td>去掉字符串左边的空格。</td>
</tr>
<tr>
<td><code>RIGHT(str, num)</code></td>
<td>返回字符串 <code>str</code> 右边前 <code>num</code> 个字符。</td>
</tr>
<tr>
<td><code>RTRIM(str)</code></td>
<td>去掉字符串右边的空格。</td>
</tr>
<tr>
<td><code>SUBSTR(str, n, size)</code> or <code>SUBSTRING(str, n, size)</code></td>
<td>提取字符串的组成部分。
DB2、Oracle、PostgreSQL 和 SQLite 使用 <code>SUBSTR()</code>；
MariaDB、MySQL 和 SQL Server 使用 <code>SUBSTRING()</code>。
<code>n</code> 是指字符串中第 <code>n</code> 个字符（从 1 开始计数），
<code>size</code> 是指截取的字符串长度，截取出的字符串包括第 <code>n</code> 个字符。</td>
</tr>
<tr>
<td><code>SOUNDEX(str)</code></td>
<td>返回字符串的 SOUNDEX 值（描述 <code>str</code> 语音表示的字母数字模式）。
PostgreSQL 不支持。SQLite 要开启 SQLITE_SOUNDEX 编译选项。
使用 <code>SOUNDEX()</code> 函数对两个字符串进行比较，
使得能对字符串进行发音比较而不是字母比较。
如 <code>WHERE SOUNDEX(str1) = SOUNDEX(str2)</code>。</td>
</tr>
<tr>
<td><code>UPPER(str)</code></td>
<td>将字符串转换为大写。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="日期和时间处理函数">日期和时间处理函数</h2>
<p>日期和时间函数在 SQL 中可移植性最差。</p>
<ul>
<li>
<p>SQL Server 使用 <code>DATEPART(part, date)</code> 返回日期中的一部分，<code>part</code>（不是字符型的参数）指定要返回的成分，<code>date</code> 是要从中国年返回成分的日期。</p>
</li>
<li>
<p>PostgreSQL 使用 <code>DATE_PART(part_str, date)</code> 返回日期中的一部分，<code>part_str</code> 指定要返回的成分，<code>date</code> 是要从中国年返回成分的日期。</p>
</li>
<li>
<p>Oracle 和 PostgreSQL 都支持 <code>EXTRACT(part FROM date)</code> 返回日期中的一部分。<code>part</code>（不是字符型）指定要返回的成分，<code>date</code> 是要从中国年返回成分的日期。</p>
</li>
<li>
<p>Oracle 还支持 <code>to_date(date_str, form_str)</code> 将字符串转化成日期，<code>date_str</code> 是某个带有日期格式的字符串，<code>form_str</code> 指定日期的形式。一般这样使用：<code>WHERE date_column BETWEEN to_date('2020-01-01', 'yyyy-mm-dd') AND todate('2020-12-31', 'yyyy-mm-dd')</code>。</p>
</li>
<li>
<p>DB2、MySQL 和 MariaDB 中有 <code>YEAR(date)</code> 和 <code>MONTH(date)</code> 等函数用于提取年份和月份等信息。</p>
</li>
<li>
<p>在 SQLite 可以使用 <code>strftime('%Y', date)</code> 提取年份，也可以提取月份等。</p>
</li>
</ul>
<hr>
<p>MySQL Date 函数：</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NOW()</code></td>
<td>返回当前的日期和时间。</td>
</tr>
<tr>
<td><code>CURDATE()</code></td>
<td>返回当前的日期。</td>
</tr>
<tr>
<td><code>CURTIME()</code></td>
<td>返回当前的时间。</td>
</tr>
<tr>
<td><code>DATE()</code></td>
<td>提取日期或日期/时间表达式的日期部分。</td>
</tr>
<tr>
<td><code>EXTRACT()</code></td>
<td>返回日期/时间的单独部分。</td>
</tr>
<tr>
<td><code>DATE_ADD()</code></td>
<td>向日期添加指定的时间间隔。</td>
</tr>
<tr>
<td><code>DATE_SUB()</code></td>
<td>从日期减去指定的时间间隔。</td>
</tr>
<tr>
<td><code>DATEDIFF()</code></td>
<td>返回两个日期之间的天数。</td>
</tr>
<tr>
<td><code>DATE_FORMAT()</code></td>
<td>用不同的格式显示日期/时间。</td>
</tr>
</tbody>
</table>
<hr>
<p>SQL Server Date 函数：</p>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GETDATE()</code></td>
<td>返回当前的日期和时间</td>
</tr>
<tr>
<td><code>DATEPART()</code></td>
<td>返回日期/时间的单独部分</td>
</tr>
<tr>
<td><code>DATEADD()</code></td>
<td>在日期中添加或减去指定的时间间隔</td>
</tr>
<tr>
<td><code>DATEDIFF()</code></td>
<td>返回两个日期之间的时间</td>
</tr>
<tr>
<td><code>CONVERT()</code></td>
<td>用不同的格式显示日期/时间</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="汇总数据">汇总数据</h2>
<p>使用<strong>聚集函数</strong>（<strong>aggregate function</strong>）可以对某些行进行计算并返回一个值。</p>
<p>SQL 聚集函数：</p>
<table>
<thead>
<tr>
<th><strong>Functions</strong></th>
<th>Explain</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AGE(filed)</code></td>
<td>返回某字段的平均数，类型必须是数值类型，<code>AVG()</code> 会忽略值为 <code>NULL</code> 的行。</td>
</tr>
<tr>
<td><code>COUNT(filed)</code></td>
<td>返回某字段的行数</td>
</tr>
<tr>
<td><code>MAX(filed)</code></td>
<td>返回某字段的最大值，允许 <code>filed</code> 是日期值，许多 DBMS 还允许 <code>filed</code> 是字符串，如果 <code>filed</code> 是字符串，那么 <code>MAX()</code> 会返回按该列排序后的最后一行。<code>MAX()</code> 忽略值为 <code>NULL</code> 的行。</td>
</tr>
<tr>
<td><code>MIN(filed)</code></td>
<td>返回某字段的最小值，与 <code>MAX()</code> 类似，如果 <code>filed</code> 是字符串，那么 <code>MAX()</code> 会返回按该列排序后的最前面一行。</td>
</tr>
<tr>
<td><code>SUM(filed)</code></td>
<td>返回某列值之和，类型必须是数值类型，<code>SUM()</code> 会忽略值为 <code>NULL</code> 的行。</td>
</tr>
</tbody>
</table>
<p>Usage for Example:</p>
<pre><code class="language-sql">SELECT AVG(filed) AS average
FROM tab_name
WHERE condition1;
</code></pre>
<p>SELECT 语句可以根据需要包含多个聚集函数。</p>
<hr>
<h1 id="group-by-数据分组">GROUP BY 数据分组</h1>
<p><strong>分组</strong>是使用 SELECT 语句的 <code>GROUP BY</code> 子句，将数据分为多个逻辑组，对每个组进行操作。</p>
<pre><code class="language-sql">-- 显示 filed1, filed2, ... 并根据它们进行分组
-- COUNT(*) 表示计算分组中的所有行
-- 该语句是先按照 filed1 进行分组，然后再按照 filed2 进行分组
-- 使用分组后输出的结果可能是根据 filed1, filed2, ... 排序好的
SELECT filed1, filed2, ..., COUNT(*);
FROM tab_name
GROUP BY filed1, filed2, ...;
</code></pre>
<p><code>GROUP BY</code> 子句指示 DBMS 分组数据，然后对每个组（不是整个结果集）进行聚集。</p>
<p>使用 <code>GROUP BY</code> 的规定：</p>
<ul>
<li>
<p><code>GROUP BY</code> 子句可以包含任意数目的列。所以可以对分组进行嵌套，更细致地进行数据分组。</p>
</li>
<li>
<p>在建立分组后，操作的最小单位只能是分组，而无法再对个别列进行操作。</p>
</li>
<li>
<p><code>GROUP BY</code> 子句中列出的每一列都必须是检索列或有效表达式列（但不能是聚集函数）。在 SELECT 中使用表达式，则必须在 <code>GROUP BY</code> 子句中指定相同的表达式，而不能使用别名。</p>
</li>
<li>
<p>大多数 SQL 实现不允许 <code>GROUP BY</code> 列带有长度可变的数据类型（如文本或备注型字段）。</p>
</li>
<li>
<p>除聚集计算语句外，SELECT 语句中的每一列都必须在 <code>GROUP BY</code> 子句中给出。</p>
</li>
<li>
<p>分组列中所有包含具有 <code>NULL</code> 值的行，都将 <code>NULL</code> 作为一个分组返回。</p>
</li>
<li>
<p><code>GROUP BY</code> 子句必须出现在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前。</p>
</li>
</ul>
<blockquote>
<p>📌并非所有 SQL 实现都支持在使用 <code>GROUP BY</code> 子句时，使用相对位置指定列，并且使用它容易在编辑 SQL 语句时出错。</p>
</blockquote>
<hr>
<h2 id="having-过滤分组">HAVING 过滤分组</h2>
<p>使用 <code>HAVING</code> 子句来过滤分组。<code>HAVING</code> 支持所有 <code>WHERE</code> 子句支持的操作符，两者的区别是 <code>WHERE</code> 仅对行进行过滤，而 <code>HAVING</code> 可以对分组进行过滤（在没有指定 <code>GROUP BY</code> 时，大多数 DBMS 会同等对待 <code>WHERE</code> 和 <code>HAVING</code>，即 <code>HAVING</code> 也可以对行进行过滤）。</p>
<pre><code class="language-sql">-- filed_1, filed_2, ... 是聚集操作
-- condition1 是相对于每行的条件，condition1_ 是相对于每个分组的条件
SELECT filed1, filed2, ... filed_1, filed_2, ...;
FROM tab_name
WHERE condition1
GROUP BY filed1, filed2, ...
HAVING condition1_;
</code></pre>
<p>在同时使用 <code>WHERE</code> 和 <code>GROUP BY</code> 时，被 <code>WHERE</code> 过滤掉的行并不会包括在分组中。</p>
<hr>
<h2 id="分组和排序">分组和排序</h2>
<p><code>ORDER BY</code> 与 <code>GROUP BY</code> 的区别</p>
<table>
<thead>
<tr>
<th><strong>ORDER BY</strong></th>
<th><strong>GROUP BY</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>对产生的输出排序</td>
<td>对行分组，但输出可能不是分组的顺序</td>
</tr>
<tr>
<td>任意列都可以使用（甚至非选择的列也可以使用，即 SELECT 没有给出的列也能使用）</td>
<td>只可能使用选择列或表达式列（SELECT 中给出的列），而且必须使用每个选择列表达式（不能使用别名）</td>
</tr>
<tr>
<td>是可选的，任何情况下都能根据需要选择是否使用</td>
<td>在使用聚集函数的情况下，
还要显示列（或表达式），则必须使用</td>
</tr>
</tbody>
</table>
<p><code>GROUP BY</code> 分组不一定是按照分组顺序输出的，所以应该提供明确的 <code>ORDER BY</code> 子句指定排序方式，以确保在任何情况下输出都能正确地排序。</p>
<hr>
<h1 id="子查询">子查询</h1>
<p><strong>子查询</strong>（<strong>subquery</strong>）是指嵌套在其他查询中的查询。</p>
<pre><code class="language-sql">-- 每个子查询中的 SELECT 语句有且仅有一个字段
-- 在子查询中企图检索多个列将返回错误
-- 理论上可以无限嵌套，但实际使用时由于性能的限制，不能嵌套太多的子查询
SELECT filed1, filed2, ...
FROM table1
WHERE condition11 IN (SELECT filed_1
                     FROM table2
                     WHERE condition12 IN (SELECT filed_2
                                          FROM table3
                                          WHERE condition13 IN (...));
</code></pre>
<p>在 SELECT 语句中，子查询总是从内向外处理（类似递归的处理方式）。</p>
<hr>
<h2 id="使用计算字段进行子查询">使用计算字段进行子查询</h2>
<pre><code class="language-sql">-- filed_1, filed_2, ... 是计算字段，是由其 AS 前的圆括号中的子查询建立的
-- table1._filed1 是 table1 中名为 _filed1 的列或列表达式
-- table2._filed1 是 table2 中名为 _filed2 的列或列表达式
-- table1._filed1 和 table2._filed1 是两个不同表格中同名同类型的列，并不是同一个列
-- table1._filed2 和 table3._filed2 的关系与 table1._filed1 和 table2._filed1 类似
-- 第 1 条子查询的解释是，对所有 table2 中符合 table1._filed1 = table2._filed1 的行进行计数
SELECT filed1, filed2, ...
       (SELECT COUNT(*)
        FROM table2
        WHERE table1._filed1 = table2._filed1) AS filed_1
       (SELECT COUNT(*)
        FROM table3
        WHERE table1._filed2 = table3._filed2) AS filed_2
       ...
FROM table1;
</code></pre>
<p>计算字段用一个句点分隔表名和列名，句点前是表名，句点后是列名，即 <code>tab_name.column</code>，这种写法也叫完全限定列名。在有可能混淆列名时（如使用子查询时）必须使用这种语法。</p>
<hr>
<h1 id="join-联结表">JOIN 联结表</h1>
<p><strong>联结</strong>（<strong>join</strong>）是一种机制，用来在一条 SELECT 语句中关联表，可以联结多个表返回一组输出。</p>
<blockquote>
<p>联结不是物理实体，它在实际的数据库表总并不存在，它仅在数据查询的执行期间存在。<br>
对于联结，需要考虑性能，如果联结过多的表，可能会非常耗费资源，使性能下降。<br>
SQL 本身不限制每个联结约束中表的数目，但实际上许多 DBMS 都有限制。</p>
</blockquote>
<p>联结类型：</p>
<ul>
<li>
<p>内联结（inner join）</p>
</li>
<li>
<p>外联结（outer join）</p>
</li>
<li>
<p>自联结（self-join）</p>
</li>
<li>
<p>自然联结（natural join）</p>
</li>
</ul>
<p>可以在一个 SELECT 语句中使用联结多个表，而且每个表的联结类型可以不相同。</p>
<hr>
<h2 id="inner-join-内联结">INNER JOIN 内联结</h2>
<p><strong>内联结</strong>（<strong>inner join</strong>）又称为<strong>等值联结</strong>（<strong>equijoin</strong>），是基于两个表之间的项等测试。</p>
<p>许多子查询都可以使用内联结来替代，但是子查询与联结同样需要耗费一定的资源，所以在一个语句中，不应使用过多的子查询和联结。</p>
<hr>
<ol>
<li>
<p>在 <code>FROM</code> 中指定多个列（等值联结）。<br>
对于联结，需要保证所有联结都有 <code>WHERE</code> 子句，并且要保证 <code>WHERE</code> 子句的正确性。</p>
<pre><code class="language-sql">-- filed1, filed2, ... 是存在于 table1, table2, ... 中的任意列或列表达式
-- 如果在不同表中出现名称相同的列，就需要使用完全限定名来指定
-- 完全限定名：tab_name.column_name
-- condition1s 中必须给出联结条件
SELECT filed1, filed2, ...
FROM table1, table2, ...
WHERE condition1s;
</code></pre>
<p>如果上述语句没有在 <code>WHERE</code> 中指出配对方式，那么 <code>table1</code> 中的每一行会与 <code>table2</code> 中的每一行进行配对，然后 <code>table1</code> 和 <code>table2</code> 已经配对完成的行会再次与 <code>table3</code> 中的每一行配对，以此类推，直到所有的表都完成了配对。这种由没有联结条件的表联结后返回的结果为<strong>笛卡尔积</strong>（<strong>cartesian product</strong>）。</p>
</li>
<li>
<p>使用 <code>INNER JOIN</code>（内联结）指定要联结的表，联结条件用特定的 <code>ON</code> 子句给出。<br>
同样地，对于这种方式的联结，需要保证所有联结都有有效的 <code>ON</code> 子句。如果没有 <code>ON</code> 子句，也会出现笛卡尔积。</p>
<pre><code class="language-sql">-- filed1, filed2, ... 是存在于 table1, table2, ... 中的任意列或列表达式
-- 如果在不同表中出现名称相同的列，就需要使用完全限定名来指定
-- condition1 中必须给出联结条件
SELECT filed1, filed2, ...  
FROM table1
INNER JOIN table2 ON condition11
INNER JOIN table3 ON condition12
INNER JOIN ...
-- 如果有其他条件的话 WHERE 子句在 INNER JOIN 之后给出
</code></pre>
</li>
</ol>
<p>ANSI SQL 规范首选 <code>INNER JOIN</code> 语法。</p>
<hr>
<h2 id="自联结">自联结</h2>
<p><strong>自联结</strong>（<strong>self-join</strong>）是指在同一个 SELECT 语句中，多次联结同一个表。</p>
<p>对于自联结来说，由于多次引用同一个表，如果不对表起别名的话，会造成系统混乱（同一个表，表名自然相同，所以系统无法区分究竟指的是哪个表，虽然本质上都是同一个表）。</p>
<pre><code class="language-sql">SELECT T1.filed1, T1.filed2, ...
FROM tab_name AS T1, tab_name AS T2
WHERE T1.filed_1 = T2.filed_1
    AND T2.filed_2 = value;
</code></pre>
<p>虽然自联结也可以用子查询替换，但对于大多数 DBMS 来说，处理联结远比处理子查询快。</p>
<pre><code class="language-sql">SELECT filed1, filed2, ...
FROM tab_name
WHERE filed_1 = (SELECT filed_1
                 FROM tab_name
                 WHERE filed_2 = value);
</code></pre>
<hr>
<h2 id="自然联结">自然联结</h2>
<p><strong>自然联结</strong>（<strong>natural join</strong>）指每个含义相同的列仅出现一次的联结。自然联结一般是通过对一个表使用通配符，而对其他表的列使用明确的子集来完成。</p>
<pre><code class="language-sql">SELECT T1.*, T2.filed1, T2.filed2, ...
FROM table1 AS T1, table2 AS T2
WHERE T1.filed_1 = T2.filed_1
    AND ...;
</code></pre>
<hr>
<h2 id="outer-join-外联结">OUTER JOIN 外联结</h2>
<p><strong>外联结</strong>（<strong>outer join</strong>）是指包含无关联行的联结。通常，内联结都是将一个表格中的行与另一个表格中的行通过联结条件进行关联，此时两个表格中没有被联结条件关联起来的行将会被忽略。而外联结则会包含这些没有被联结条件所关联起来的行，并根据需要给某些列赋予 <code>NULL</code> 值。</p>
<p>外联结有三种类型：</p>
<ul>
<li>
<p><code>LEFT OUTER JOIN</code> —— 左外联结，包含左表的所有行（即 <code>FROM</code> 后面紧跟的表，示例中为 <code>T1</code>），即使在右表（示例中为 <code>T2</code>）中没有被匹配（结果为 <code>NULL</code>）。<br>
基本上所有的 DBMS 都支持。</p>
<pre><code class="language-sql">SELECT T1.filed1, T1,filed2, ...
       T2.filed_1, T2.filed_2, ...
FROM table1 AS T1
LEFT OUTER JOIN table2 AS T2
ON T1.filed = T2.filed;
</code></pre>
</li>
<li>
<p><code>RIGHT OUTER JOIN</code> —— 右外联结，包含左表的所有行（即 <code>JOIN</code> 关键字后紧跟的表，示例中为 <code>T2</code>），即使在右表（示例中为 <code>T1</code>）中没有被匹配（结果为 <code>NULL</code>）。<br>
SQLite 不支持。</p>
<pre><code class="language-sql">SELECT T1.filed1, T1,filed2, ...
       T2.filed_1, T2.filed_2, ...
FROM table1 AS T1
RIGHT OUTER JOIN table2 AS T2
ON T1.filed = T2.filed;
</code></pre>
</li>
<li>
<p><code>FULL OUTER JOIN</code> —— 全外联结，只要左表和右表其中一个表中存在匹配，就返回。<br>
MariaDB、MySQL 和 SQLite 都不支持。</p>
</li>
</ul>
<p>左外联结和右外联结可以相互转换。</p>
<hr>
<h2 id="联结-聚合函数与分组">联结、聚合函数与分组</h2>
<p>联结的一种用法是使用聚合函数从另一个表格中汇总数据。</p>
<pre><code class="language-sql">-- condition1 是联结条件
SELECT T1.filed1, T2.filed2, ...
       COUNT(T2.filed_1) AS name_filed
FROM table1 AS T1
INNER JOIN table2 AS T2 ON condition1
GROUP BY T1.filed1, T1,filed2, ...;
</code></pre>
<p>对于上述语句也可以指定外联结，仅需将 <code>INNER JOIN</code> 替换成外联结的关键字。</p>
<p>使用外联结从另一个表中汇总数据，那些没有被关联的行经过 <code>COUNT()</code> 函数计算后的返回值将会为 0。</p>
<hr>
<h1 id="union-组合查询">UNION 组合查询</h1>
<p><strong>组合查询</strong>通常称为<strong>并</strong>（<strong>union</strong>）或<strong>符合查询</strong>（<strong>compound query</strong>）。通过组合查询可以同时执行多条 SELECT 语句，并将结果作为一个查询结果集返回。</p>
<p>需要使用组合查询的情况：</p>
<ul>
<li>
<p>在一个查询中从不同的表返回结构数据；</p>
</li>
<li>
<p>对一个表执行多个查询，按一个查询返回数据。</p>
</li>
</ul>
<blockquote>
<p>📌</p>
<ul>
<li>
<p>组合相同表的查询所完成的工作一般可以用 <code>WHERE</code> 子句替代。<br>
理论上使用 <code>WHERE</code> 子句和组合查询从性能上看并没有太大差别，但各实现之间任有差别。</p>
</li>
<li>
<p>第一条 SELECT 中的列名或指定的别名作为整个组合查询的结果集的列名。因此组合查询所返回的结果集的列名是第一条 SELECT 中的列名，且在组合查询中的 <code>ORDER BY</code> 子句中指出的列名应是第一条 SELECT 中第列名。</p>
</li>
<li>
<p>每一个组合查询最多仅能有一条 <code>ORDER BY</code> 子句，且必须位于整个组合查询语句的最后（即最后一条 SELECT 语句）。<br>
即，无法对某条 SELECT 指定一种排序方式，而对另一条 SELECT 指定另一种排序方式，所有的 SELECT 只能用同一种方式排序。</p>
</li>
</ul>
</blockquote>
<p>使用组合查询的规则：</p>
<ul>
<li>
<p>必须由两条或两条以上的 SELECT 语句组成，语句之间用关键字 <code>UNION</code> 分隔。</p>
</li>
<li>
<p>每个查询必须包含相同的列、表达式或聚集函数（数量必须要相同，类型必须要兼容）。</p>
</li>
</ul>
<hr>
<p>使用 <code>UNION</code> 关键字，会自动去除重复的行：</p>
<pre><code class="language-sql">-- filed1, filed2, ... 和 filed_1, filed_2, ... 数量必须相同，类型要兼容
-- table1 和 table2 可以是同个表格，也可以是不同的表格
-- ORDER BY 必须位于语句的最后
SELECT filed1, filed2, ...
FROM table1
WHERE condition11
UNION
SELECT filed_1, filed_2, ...
FROM table2
WHERE condition12
UNION
...
ORDER BY filed;
</code></pre>
<p>在上述语句中，将 <code>UNION</code> 替换成 <code>UNION ALL</code>，返回的结果集将包含重复的行。</p>
<hr>
<h1 id="insert-语句">INSERT 语句</h1>
<p>INSERT 语句用来将行插入（或添加）到数据库表。</p>
<hr>
<h2 id="插入完整的行">插入完整的行</h2>
<ol>
<li>
<p>简单但不保险的方法：</p>
<pre><code class="language-sql">INSERT INTO tab_name
VALUES(value1,
       value2,
       value3,
       ...,
       NULL,
       ...);
</code></pre>
<p><code>VALUES</code> 后面的括号中，按照表中列的定义次序，指出了要存储到表中的数据，且必须给每一列提供一个值（在没有指定列名的情况下）。如果某列没有值，则该列应该使用 <code>NULL</code>（在允许对该列指定空值的情况下）。各列必须以它们在表定义中出现的次序填充。</p>
<p>这种语法虽然简单但并不安全，因为这种 SQL 语句高度依赖于表中列的定义次序。如果表结构发生变动，那么这样的语句并不能按照预期的情况执行。</p>
<blockquote>
<p>📌在某些 SQL 实现中，<code>INTO</code> 关键字是可选的。但为了确保可移植，还是要提供 <code>INTO</code> 关键字。</p>
</blockquote>
</li>
<li>
<p>保险但比较繁琐的方法：</p>
<pre><code class="language-sql">-- filed1 与 value1 对应，filed2 与 value2 对应，以此类推
INSERT INTO tab_name(filed1,
                       filed2,
                       filed3,
                       ...)
VALUES(value1,
       value2,
       value3,
       ...);
</code></pre>
<p>这种方法需要在表名后面，使用括号将表中的所有列名指出（不用按照表中列的定义顺序）。在插入行时，VALUES 必须以其指定的次序匹配指定的列名，这样即使表结构改变，该 INSERT 语句仍能正确工作。不要使用没有明确给出列的 INSERT 语句。</p>
</li>
</ol>
<p>主键的值必须有唯一性，DBMS 不允许插入主键值重复的行。如果确实需要插入，应先删除原有的记录。</p>
<hr>
<h2 id="插入行的一部分">插入行的一部分</h2>
<pre><code class="language-sql">-- filed1 与 value1 对应，filed2 与 value2 对应，以此类推
INSERT INTO tab_name(filed1,
                       filed2,
                       ...)
VALUES(value1,
       value2,
       ...);
</code></pre>
<p>同样使用表名后面的括号指定列，只不过仅需指出需要插入的部分列，并且只需给这些列提供值。</p>
<p>无论是插入完整的行还是插入行的一部分，都必须确保 <code>VALUES</code> 的数目正确。如果不提供列名，则必须给每个表列提供一个值；如果提供列名，则必须给列出的每一个列一个值。否则，就会产生错误。</p>
<p>在 <code>VALUES</code> 中没有指出的列，DBMS 将赋予它们默认值或空值。这些列必须满足：</p>
<ul>
<li>
<p>列定义为允许 <code>NULL</code> 值。</p>
</li>
<li>
<p>在表定义中给出了默认值。</p>
</li>
</ul>
<hr>
<h2 id="insert-select">INSERT SELECT</h2>
<p>INSERT 还允许利用 SELECT 语句将检索到的结果插入表中。</p>
<pre><code class="language-sql">-- 将 table2 中满足条件的 filed_1, filed_2, ... 列按照对应顺序插入到 table1 中
-- table1 和 table2 可以是同一个表
INSERT INTO table1(filed1,
                   filed2,
                   ...)
SELECT filed_1,
       filed_2,
       ...
FROM table2
WHERE condition1s;
</code></pre>
<p>一般 INSERT 只插入一行。而 INSERT SELECT 可以用一条语句插入多行。</p>
<hr>
<h2 id="select-into">SELECT INTO</h2>
<p><code>SELECT ... INTO</code> 用于从一个表中复制数据，然后把数据插入到另一个新表中（<code>INTO</code> 子句后指定的表，该语句执行后会自动创建）。</p>
<blockquote>
<p>📌MySQL 不支持 <code>SELECT ... INTO</code> 语句。</p>
</blockquote>
<pre><code class="language-sql">-- INTO 后面的 IN 子句代表插入到其他数据库
-- IN 子句可省略，默认代表当前数据库
-- new_table 的表结构与 old_table 指定列 filed1, filed2, ... 的结构相同
SELECT filed1, filed2, ...
INTO new_table [IN external_db]
FROM old_table;
</code></pre>
<p><code>SELECT INTO</code> 语句可以通过使用促使查询没有数据返回的 <code>WHERE</code> 子句创建一个新的空表：</p>
<pre><code class="language-sql">SELECT filed1, filed2, ...
INTO new_table
FROM old_table
WHERE 1 = 0;
</code></pre>
<hr>
<h1 id="更新和删除数据">更新和删除数据</h1>
<blockquote>
<p>在客户端或服务器的 DBMS 中，使用 UPDATE 和 DELETE 语句可能需要特殊的安全权限。</p>
</blockquote>
<hr>
<h2 id="update-语句">UPDATE 语句</h2>
<p>UPDATE 语句用于更新（修改）表中的数据。</p>
<p>有两种使用 UPDATE 语句的方式：</p>
<ol>
<li>
<p>更新表中的特定行 —— 使用 <code>WHERE</code> 子句过滤：</p>
<p>基本的 UPDATE子句由三部分组成：</p>
<ul>
<li>
<p>要更新的表 —— 使用 <code>UPDATE</code> 关键字指定；</p>
</li>
<li>
<p>列名和它们的新值 —— 使用 <code>SET</code> 关键字指定更新的内容（即使用 “列=值” 对将新值赋给被更新的列）；</p>
</li>
<li>
<p>确定要更新哪些行的过滤 —— 使用 <code>WHERE</code> 子句指定过滤条件。<br>
在 UPDATE 中，<code>WHERE</code> 可以使用 SELECT 子查询。</p>
</li>
</ul>
<pre><code class="language-sql">-- filed1, filed2, ... 是 tab_name 中的列
-- value1, value2, ... 是与 filed1, filed2, ... 相对应类型的数据
-- filed1 = value1, filed2 = value2, ... 是 “列=值” 对
-- condition1s 是过滤的条件，指定了要更新的行
UPDATE tab_name
SET filed1 = value1,
    filed2 = value2,
    ...
WHERE condition1s;
</code></pre>
</li>
<li>
<p>更新表中的所有行 —— 不使用 <code>WHERE</code> 子句。</p>
<p>一般的 UPDATE 字句都要使用 <code>WHERE</code> 字句指定过滤条件，否则 <code>SET</code> 子句指定的更新内容将应用到所有的列。</p>
</li>
</ol>
<blockquote>
<p>📌有的 SQL 实现支持在 UPDATE 语句中使用 FROM 子句，用一个表的数据更新另一个表的行。</p>
</blockquote>
<p>使用 UPDATE 删除某个列的值：将要删除的列置为 <code>NULL</code>（假设表定义允许 <code>NULL</code>）。如：</p>
<pre><code class="language-sql">UPDATE tab_name
SET del_filed = NULL
WHERE condition1s;
</code></pre>
<hr>
<h2 id="delete-语句">DELETE 语句</h2>
<p>使用 DELETE 语句可以从一个表中删除（去掉）数据。</p>
<p>有两种使用 DELETE 语句的方式：</p>
<ul>
<li>从表中删除特定的行 —— 使用 <code>WHERE</code> 子句过滤：</li>
</ul>
<pre><code class="language-sql">-- condition1s 是过滤条件，指定了要删除的行
DELETE FROM tab_name
WHERE condition1s;
</code></pre>
<ul>
<li>从表中删除所有行 —— 不使用 <code>WHERE</code> 子句：<br>
使用 DELETE 语句时应该指定 <code>WHERE</code> 子句，否则它将会删除表中所有的行。<br>
如果确实想删除表中所有行，应该使用速度更快的 <code>TRUNCATE TABLE</code> 语句。</li>
</ul>
<p>DELETE 语句删除的是表中的行，即它的操作对象是行而不是列，如果想要删除列，则要使用 UPDATE 语句将该列置为 <code>NULL</code>。</p>
<hr>
<h2 id="update-和-delete-的使用准则">UPDATE 和 DELETE 的使用准则</h2>
<ul>
<li>
<p><strong>绝对不要使用不带  子句的 UPDATE 或 DELETE 子句</strong>，除非确实打算更新和删除每一行。</p>
</li>
<li>
<p><strong>应保证每个表都有主键</strong>。</p>
</li>
<li>
<p>在使用 UPDATE 或 DELETE 之前，应先用 SELETE 进行测试，确保 <code>WHERE</code> 子句过滤的是正确的记录。:</p>
</li>
<li>
<p>使用强制实施引用完整性的数据库，这样 DBMS 将不允许删除其数据与其他表相关的行。</p>
</li>
<li>
<p>如果 DBMS 允许数据库管理员施加约束，防止执行不带 <code>WHERE</code> 子句的 UPDATE 或 DELETE 子句，那么应该使用它。</p>
</li>
</ul>
<blockquote>
<p>📌如果 SQL 没有撤销（undo）按钮，应该更小心地使用 UPDATE 和 DELETE 语句。</p>
</blockquote>
<hr>
<h1 id="创建和删除数据库">创建和删除数据库</h1>
<p>创建数据库使用 <code>CREATE DATABASE</code> 语句。</p>
<pre><code class="language-sql">CREATE DATABASE db_name;
</code></pre>
<p>删除数据库使用 <code>DROP DATABASE</code> 语句。</p>
<pre><code class="language-sql">DROP DATABASE db_name;
</code></pre>
<p>注意：删除数据库后，数据库中的所有数据（表、视图、索引等数据都将会被删除）。</p>
<hr>
<h1 id="sql-通用数据类型">SQL 通用数据类型</h1>
<p>数据类型定义列中存放的值的种类。数据库表中的每个列都要求有名称和数据类型。SQL 开发人员必须在创建 SQL 表时决定表中的每个列将要存储的数据的类型。</p>
<p>不同的 DBMS 数据类型有些不同。有的 DBMS 允许自定义数据类型，有的不允许。</p>
<p>以下是 SQL 通用数据类型：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CHARACTER(n)</code> 或 <code>CHAR(n)</code></td>
<td>字符/字符串。固定长度 <code>n</code>。</td>
</tr>
<tr>
<td><code>VARCHAR(n)</code> 或  <code>CHARACTER VARYING(n)</code></td>
<td>字符/字符串。可变长度。最大长度 <code>n</code>。</td>
</tr>
<tr>
<td><code>BINARY(n)</code></td>
<td>二进制串。固定长度 <code>n</code>。</td>
</tr>
<tr>
<td><code>BOOLEAN</code></td>
<td>存储 <code>TRUE</code> 或 <code>FALSE</code> 值</td>
</tr>
<tr>
<td><code>VARBINARY(n) </code> 或 <code>BINARY VARYING(n)</code></td>
<td>二进制串。可变长度。最大长度 <code>n</code>。</td>
</tr>
<tr>
<td><code>INTEGER(p)</code></td>
<td>整数值（没有小数点）。精度 <code>p</code>。</td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td>整数值（没有小数点）。精度 5。</td>
</tr>
<tr>
<td><code>INTEGER</code></td>
<td>整数值（没有小数点）。精度 10。</td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td>整数值（没有小数点）。精度 19。</td>
</tr>
<tr>
<td><code>DECIMAL(p,s)</code></td>
<td>精确数值，精度 <code>p</code>，小数点后位数 <code>s</code>。
例如：<code>DECIAML(5,2)</code> 是一个小数点前有 3 位数，小数点后有 2 位数的数字。</td>
</tr>
<tr>
<td><code>NUMERIC(p,s)</code></td>
<td>精确数值，精度 <code>p</code>，小数点后位数 <code>s</code>。（与  DECIMAL 相同）.</td>
</tr>
<tr>
<td><code>FLOAT(p)</code></td>
<td>近似数值，尾数精度 <code>p</code>。一个采用以 10 为基数的指数计数法的浮点数。该类型的 <code>size</code> 参数由一个指定最小精度的单一数字组成。</td>
</tr>
<tr>
<td><code>REAL</code></td>
<td>近似数值，尾数精度 7。</td>
</tr>
<tr>
<td><code>FLOAT</code></td>
<td>近似数值，尾数精度 16。</td>
</tr>
<tr>
<td><code>DOUBLE PRECISION</code></td>
<td>近似数值，尾数精度 16。</td>
</tr>
<tr>
<td><code>DATE</code></td>
<td>存储年、月、日的值。</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>存储小时、分、秒的值。</td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td>存储年、月、日、小时、分、秒的值。</td>
</tr>
<tr>
<td><code>INTERVAL</code></td>
<td>由一些整数字段组成，代表一段时间，取决于区间的类型。</td>
</tr>
<tr>
<td><code>ARRAY</code></td>
<td>元素的固定长度的有序集合。</td>
</tr>
<tr>
<td><code>MULTISET</code></td>
<td>元素的可变长度的无序集合。</td>
</tr>
<tr>
<td><code>XML</code></td>
<td>存储 XML 数据。</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>SQL 数据类型快速参考手册</strong>：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>Access</strong></th>
<th><strong>SQL Server</strong></th>
<th><strong>Oracle</strong></th>
<th><strong>MySQL</strong></th>
<th><strong>PostgreSQL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>boolean</strong></td>
<td><code>Yes/No</code></td>
<td><code>Bit</code></td>
<td><code>Byte</code></td>
<td>N/A</td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><strong>integer</strong></td>
<td><code>Number (integer)</code></td>
<td><code>Int</code></td>
<td><code>Number</code></td>
<td><code>Int</code>、 <code>Integer</code></td>
<td><code>Int</code>、 <code>Integer</code></td>
</tr>
<tr>
<td><strong>float</strong></td>
<td><code>Number (single)</code></td>
<td><code>Float Real</code></td>
<td><code>Number</code></td>
<td><code>Float</code></td>
<td><code>Numeric</code></td>
</tr>
<tr>
<td><strong>currency</strong></td>
<td><code>Currency</code></td>
<td><code>Money</code></td>
<td>N/A</td>
<td>N/A</td>
<td><code>Money</code></td>
</tr>
<tr>
<td><strong>string (fixed)</strong></td>
<td>N/A</td>
<td><code>Char</code></td>
<td><code>Char</code></td>
<td><code>Char</code></td>
<td><code>Char</code></td>
</tr>
<tr>
<td><strong>string (variable)</strong></td>
<td>Text (&lt;256) Memo (65k+)</td>
<td><code>Varchar</code></td>
<td><code>Varchar</code>、<code>Varchar2</code></td>
<td><code>Varchar</code></td>
<td><code>Varchar</code></td>
</tr>
<tr>
<td><strong>binary object</strong></td>
<td>OLE Object Memo</td>
<td>Binary (fixed up to 8K) Varbinary (&lt;8K) Image (&lt;2GB)</td>
<td>Long Raw</td>
<td>Blob Text</td>
<td>Binary Varbinary</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="时间数据格式">时间数据格式</h2>
<p>MySQL 使用下列数据类型在数据库中存储日期或日期/时间值：</p>
<ul>
<li>
<p>DATE - 格式：<code>YYYY-MM-DD</code></p>
</li>
<li>
<p>DATETIME - 格式：<code>YYYY-MM-DD HH:MM:SS</code></p>
</li>
<li>
<p>TIMESTAMP - 格式：<code>YYYY-MM-DD HH:MM:SS</code></p>
</li>
<li>
<p>YEAR - 格式：<code>YYYY</code> 或 <code>YY</code></p>
</li>
</ul>
<p>SQL Server 使用下列数据类型在数据库中存储日期或日期/时间值：</p>
<ul>
<li>
<p>DATE - 格式：<code>YYYY-MM-DD</code></p>
</li>
<li>
<p>DATETIME - 格式：<code>YYYY-MM-DD HH:MM:SS</code></p>
</li>
<li>
<p>SMALLDATETIME - 格式：<code>YYYY-MM-DD HH:MM:SS</code></p>
</li>
<li>
<p>TIMESTAMP - 格式：唯一的数字</p>
</li>
</ul>
<hr>
<h1 id="创建和操纵表格">创建和操纵表格</h1>
<h2 id="create-table-创建表">CREATE TABLE 创建表</h2>
<p>一般有两种创建表格的方法：</p>
<ol>
<li>
<p>使用 SQL 语句 <code>CTEATE TABLE</code> 创建表格；</p>
</li>
<li>
<p>多数 DBMS 都具有交互式创建和管理数据库表的工具。</p>
<ul>
<li>其本质是交互工具根据用户操作自动生成并执行相应的 SQL 语句。</li>
</ul>
</li>
</ol>
<blockquote>
<p>不同的 SQL 实现中，CREATE TABLE 语句的语法会有所不同（主要区别是在列定义上）。</p>
</blockquote>
<p>使用 <code>CREATE TABLE</code> 创建表，必须给出以下信息：</p>
<ul>
<li>
<p>新表的名字，在关键字 <code>CREATE TABLE</code> 之后给出；</p>
</li>
<li>
<p>表列的名字和定义，在列名后的括号中指出，用逗号分隔；</p>
</li>
<li>
<p>有的 DBMS 还要求指定表的位置。</p>
</li>
</ul>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    column_name1    DataType1,
    column_name2    DataType2,
    column_name3    DataType3,
    cluumn_name4    DataType4,
    ...
);
</code></pre>
<p>创建新表时只能指定不存在的表名，SQL 无法通过 <code>CREATE</code> 语句覆盖已有的表。</p>
<h2 id="alter-table-更新表定义">ALTER TABLE 更新表定义</h2>
<p>使用 ALTER TABLE 时需要考虑的事情：</p>
<ul>
<li>
<p>理想情况下，不要在表中包含数据时对表结构进行更新（特别是不要删除已有的列）。<br>
应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。</p>
</li>
<li>
<p>所有的 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型（以及 NULL 和 DEFAULT 的使用）有所限制。</p>
</li>
<li>
<p>许多 DBMS 不允许删除或更改表中的列。</p>
</li>
<li>
<p>多数 DBMS 允许重新命名表中的列。</p>
</li>
<li>
<p>许多 DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。</p>
</li>
</ul>
<p>使用 ALTER TABLE 必须给出的信息：</p>
<ul>
<li>
<p>在 ALTER TABLE 之后给出表名；</p>
</li>
<li>
<p>列出要更改表的操作。</p>
</li>
</ul>
<hr>
<ol>
<li>
<p>增加表列：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ADD filed DataType;
</code></pre>
</li>
<li>
<p>删除列：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP COLUMN filed;
</code></pre>
</li>
</ol>
<hr>
<p>复杂的表结构更改一般需要执行以下步骤：</p>
<ol>
<li>
<p>用新的列布局创建一个新表；</p>
</li>
<li>
<p>使用 INSERT SELECT 语句从旧表复制数据到新表；</p>
</li>
<li>
<p>检验包含所需数据的新表；</p>
</li>
<li>
<p>重命名旧表（在确定无误的情况下可删除）；</p>
</li>
<li>
<p>用旧表原来的名字重命名新表；</p>
</li>
<li>
<p>根据需要，重新创建触发器、存储过程、索引和外键。</p>
</li>
</ol>
<hr>
<p>使用 ALTER TABLE 的注意事项：</p>
<ul>
<li>
<p>SQLite 对使用 ALTER TABLE 的最重要的限制是：不支持使用 ALTER TABLE 定义主键和外键，必须在最初创建表时指定。</p>
</li>
<li>
<p>在使用 ALTER TABLE 之前应先做好完整的备份（表结构和数据的备份）。</p>
</li>
<li>
<p>表结构的更改不能撤销。</p>
<ul>
<li>
<p>如果增加了不需要的列，也许无法删除它们。</p>
</li>
<li>
<p>如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="drop-table-删除表">DROP TABLE 删除表</h2>
<p><code>DROP TABLE</code> 语句用于删除表本身（包括表数据）。</p>
<pre><code class="language-sql">DROP TABLE tab_name;
</code></pre>
<blockquote>
<p>📌删除表时，没有确认步骤，且不能撤销。</p>
</blockquote>
<blockquote>
<p>📌<strong>使用关系规则防止意外删除</strong>：</p>
<p>许多 DBMS 允许强制实施有关规则，防止删除与其他表相关联的表。在实施这些规则时，如果对某个表发布一条 <code>DORP TABLE</code> 语句，且该表是某个关系的组成部分，则 DBMS 将阻止这条语句执行，直到该关系被删除为止。</p>
</blockquote>
<hr>
<h2 id="truncate-table-删除表数据">TRUNCATE TABLE 删除表数据</h2>
<p><code>TRUNCATE TABLE</code> 语句用于删除表内的数据（但并不包括表本身）。</p>
<pre><code class="language-sql">TRUNCATE TABLE tab_name;
</code></pre>
<hr>
<h2 id="重命名表">重命名表</h2>
<p>对于重命名表，每个 DBMS 的支持都有所不同：</p>
<ul>
<li>
<p>DB2、MariaDB、MySQL、Oracle 和 PostgreSQL 使用 <code>RENAME</code> 语句。</p>
</li>
<li>
<p>SQL Server 使用 <code>sp_rename</code> 存储过程。</p>
</li>
<li>
<p>SQLite 使用 <code>ALTER TABLE</code> 语句。</p>
</li>
</ul>
<hr>
<h1 id="sql-约束">SQL 约束</h1>
<p>SQL <strong>约束</strong>（Constraints）用于规定表中如何插入或处理数据的规则。如果存在违反约束的数据行为，行为会被约束终止。</p>
<p>约束可以在创建表时规定（通过 <code>CREATE TABLE</code> 语句），或者在表创建之后规定（通过 <code>ALTER TABLE</code> 语句）。</p>
<p>SQL 有如下几种约束：</p>
<table>
<thead>
<tr>
<th><strong>关键字</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NULL</code></td>
<td>允许存储 NULL 值。
如果不指定 NOT NULL 或 PRIMARY KEY，则默认为 NULL。
在插入行时允许不给出该列的值。此时，会给该项指定为值 NULL。
对于 DB2，在定义允许 NULL 的列中不能指定 NULL。</td>
</tr>
<tr>
<td><code>NOT NULL</code></td>
<td>指示某列不能存储 NULL 值。
如果不向字段添加值，就无法插入新记录或者更新记录。</td>
</tr>
<tr>
<td><code>UNIQUE </code></td>
<td>唯一约束。保证某列的每行必须有唯一的值。
唯一约束可包含 NULL 值，可重复使用，但是不能用来定义外键。</td>
</tr>
<tr>
<td><code>PRIMARY KEY</code></td>
<td>主键约束。NOT NULL 和 UNIQUE 的结合。
确保某列（或多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</td>
</tr>
<tr>
<td><code>FOREIGN KEY</code></td>
<td>外键约束。保证一个表中的数据匹配另一个表中的值的参照完整性。</td>
</tr>
<tr>
<td><code>CHECK</code></td>
<td>保证列中的值符合指定的条件。</td>
</tr>
<tr>
<td><code>DEFAULT</code></td>
<td>规定没有给列赋值时的默认值。
在插入行时如果不给出值，则用默认值赋值。</td>
</tr>
</tbody>
</table>
<p>Example：</p>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    # 主键约束
    column1  Type1  PRIMARY KEY,
    # 默认为允许 NULL，可以不用指出
    column2  Type2  [NULL], 
    # 不允许 NULL 的列，必须用 NOT NULL 指出
    column3  Type3  NOT NULL,
    # 用 DEFAULT 指定默认值
    # default_val 是 Type4 类型的值
    column4  Type4  NOT NULL  DEFAULT default_val,
    ...
);
</code></pre>
<hr>
<h2 id="not-null-非空约束">NOT NULL 非空约束</h2>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    column1 Type1 NOT NULL,
    ...
);
</code></pre>
<p>添加 NOT NULL 约束：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
MODIFY column_name Type1 NOT NULL;
</code></pre>
<hr>
<h2 id="unique-唯一约束">UNIQUE 唯一约束</h2>
<p>每个表可以有多个 UNIQUE 约束。</p>
<p>创建表时：</p>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    column1 Type1 NOT NULL,
    # 方法一：直接在列定义中用 UNIQUE 关键字指出
    column2 Type2 NOT NULL UNIQUE,
    ...
    # 方法二：定义列后使用 UNIQUE()
    UNIQUE (column1)
);
</code></pre>
<pre><code class="language-sql">-- 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束
CREATE TABLE tab_name
(
    column1 Type1 NOT NULL,
    column2 Type2 NOT NULL,
    ...
    # 可以不用定义 u_name
    CONSTRAINT [u_name] UNIQUE (column1, column2, ...)
);
</code></pre>
<hr>
<p>更新表定义时：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ADD UNIQUE (column_name);
</code></pre>
<pre><code class="language-sql">-- 命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束
ALTER TABLE tab_name
# name 可以省略
ADD CONSTRAINT u_name UNIQUE (column1, column2, ...);
</code></pre>
<hr>
<p>撤销 UNIQUE 约束：</p>
<p>MySQL：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP INDEX u_name;
</code></pre>
<p>SQL Server / Oracle / MS Access：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP CONSTRAINT u_name;
</code></pre>
<hr>
<h2 id="primary-key-主键约束">PRIMARY KEY 主键约束</h2>
<p>只要满足以下条件，就可以被用作主键：</p>
<ul>
<li>
<p>任意两行的主键值都不相同（主键必须包含唯一值）。</p>
</li>
<li>
<p>每行都具有一个主键值（主键列不能包含 NULL 值）。</p>
</li>
<li>
<p>包含主键值的列从不修改或更新。</p>
</li>
<li>
<p>主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。</p>
</li>
</ul>
<hr>
<p>创建表时：</p>
<pre><code class="language-sql">-- 在列定义中直接指出主键
CREATE TABLE tab_name
(
    column1 Type1 NOT NULL PRIMARY KEY,
    ...
);
</code></pre>
<pre><code class="language-sql">-- 通过 PRIMARY KEY () 定义
CREATE TABLE tab_name
(
    column1 Type1 NOT NULL,
    ...
    PRIMARY KEY (column1)
);
</code></pre>
<pre><code class="language-sql">-- 命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束
CREATE TABLE tab_name
(
    column1 Type1 NOT NULL,
    column1 Type1 NOT NULL,
    ...
    # 可以不用定义 pk_name
    CONSTRAINT [pk_name] PRIMARY KEY (column1, column2, ...)
);
</code></pre>
<hr>
<p>更新表定义时：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ADD PRIMARY KEY (column_name);
</code></pre>
<pre><code class="language-sql">-- 命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束
ALTER TABLE tab_name
# name 可以省略
ADD CONSTRAINT pk_name UNIQUE (column1, column2, ...);
</code></pre>
<hr>
<p>撤销 PRIMARY KEY 约束：</p>
<p>MySQL：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP PRIMARY KEY;
</code></pre>
<p>SQL Server / Oracle / MS Access：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP CONSTRAINT pk_name;
</code></pre>
<hr>
<h2 id="foreign-key-外键约束">FOREIGN KEY 外键约束</h2>
<p>创建表时：</p>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    # 方法一：使用 REFERENCES 关键字
    column1 Type1 NOT NULL REFERENCES table1(column_1),
    column2 Type2 NOT NULL,
    column2 Type2 NOT NULL,
    ...
    # 方法二：使用 FOREIGN KEY ()
    FOREIGN KEY (column2) REFERENCES table2(column_2),
    # 命名 FOREIGN KEY 约束
    CONSTRAINT [fk_name] FOREIGN KEY (column3)
    REFERENCES table3(column_3)
);
</code></pre>
<hr>
<p>更新表定义时：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ADD FOREIGN KEY (column1)
REFERENCES table1(column_1);
</code></pre>
<pre><code class="language-sql">-- 命名 FOREIGN KEY 约束
ALTER TABLE tab_name
ADD CONSTRAINT fk_name
FOREIGN KEY (column1)
REFERENCES table1(column_1);
</code></pre>
<hr>
<p>撤销 FOREIGN KEY 约束：</p>
<p>MySQL：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP FOREIGN KEY fk_name;
</code></pre>
<p>SQL Server / Oracle / MS Access：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP CONSTRAINT fk_name;
</code></pre>
<hr>
<h2 id="check-检查约束">CHECK 检查约束</h2>
<p>CHECK 约束常见用途：</p>
<ul>
<li>
<p>检查最小或最大值。</p>
</li>
<li>
<p>指定范围。</p>
</li>
<li>
<p>只允许特定值。</p>
</li>
</ul>
<hr>
<p>创建表时：</p>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    # 限制 column1 的值大于 0
    column1 Type1 NOT NULL CHECK (column1 &gt; 0),
    column2 Type2 NOT NULL,
    ...
    # 限制 column2 只能取 'Y' 或 'N'
    CHECK (column2 LIKE '[YN]')
);
</code></pre>
<pre><code class="language-sql">-- 命名 CHECK 约束，并定义多个列的 CHECK 约束
CREATE TABLE tab_name
(
    column1 Type1 NOT NULL,
    column2 Type2 NOT NULL,
    ...
    CONSTRAINT chk_name CHECK (column1 &gt; 0 AND column2 LIKE '[YN]')
);
</code></pre>
<hr>
<p>修改表定义时：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ADD CHECK (column1 &gt; 0);
</code></pre>
<pre><code class="language-sql">-- 命名 CHECK 约束，并定义多个列的 CHECK 约束
ALTER TABLE tab_name
ADD CONSTRAINT chk_name CHECK (column1 &gt; 0 AND column2 LIKE '[YN]');
</code></pre>
<hr>
<p>撤销 CHECK 约束：</p>
<p>MySQL：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP CHECK chk_name;
</code></pre>
<p>SQL Server / Oracle / MS Access：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP CONSTRAINT chk_name;
</code></pre>
<hr>
<h2 id="default-默认约束">DEFAULT 默认约束</h2>
<p>创建表时：</p>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    # default_val 是 Type4 类型的值
    column1  Type1  NOT NULL  DEFAULT default_val,
    ...
)
</code></pre>
<pre><code class="language-sql">-- 可以使用类似 GETDATE() 的函数插入系统值
CREATE TABLE tab_name
(
    # 默认值为当前的日期
    birthday  DATE  NOT NULL  DEFAULT GETDATE(),
    ...
)
</code></pre>
<hr>
<p>更新表结构时：</p>
<p>MySQL：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ALTER column1 SET DEFAULT default_val;
</code></pre>
<p>SQL Server / MS Access：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ADD CONSTRAINT name DEFAULT default_val for column1;
</code></pre>
<p>Oracle：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
MODIFY column1 DEFAULT default_val;
</code></pre>
<hr>
<p>撤销 DEFAULT 约束：</p>
<p>MySQL：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ALTER column1 DROP DEFAULT;
</code></pre>
<p>SQL Server / Oracle / MS Access：</p>
<pre><code class="language-sql">ALTER TABLE tab_name
ALTER COLUMN column1 DROP DEFAULT;
</code></pre>
<hr>
<h1 id="auto-increment-字段">AUTO INCREMENT 字段</h1>
<p>在定义表时，在列中添加 auto-increment 字段可以在新纪录插入表时对该列生成一个唯一的数字。</p>
<p>定义为 auto-increment 字段的列必须是整数类型。</p>
<p>定义为 auto-increment 的列常常被定义为 <code>PRIMARY KEY</code>。</p>
<hr>
<p>MySQL 使用 <code>AUTO_INCREMENT</code> 关键字来执行 auto-increment 任务：</p>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    # 定义 column1 为 AUTO INCREMENT 主键字段
    column1 TYPE1 NOT NULL PRIMARY KEY AUTO_INCREMENT,
    column2 TYPE2,
    column3 TYPE3,
    ...
);
</code></pre>
<p>定义了 AUTO_INCREMENT 字段后，可以不用对该列指定值，或者对该列指定为 NULL 值（会自动添加一个唯一的值）。</p>
<p>MySQL 的 AUTO_INCREMENT 只能在 key 上被定义。PRIMARY KEY 和 UNIQUE 都是有效的定义。</p>
<pre><code class="language-sql">-- val2 和 val3 是分别与 column2 和 column3 同类型的值

-- 不对 auto-increment 列指定值
INSERT INTO tab_name ( column2, column3 )
VALUES ( val2, val3 );

-- 指定为 NULL 值
INSERT INTO tab_name ( column1, column2, column3)
VALUES ( NULL, val2, val3);
</code></pre>
<p>AUTO_INCREMENT 默认的开始值是 <code>1</code>，每新增一条记录都会递增 <code>1</code>。</p>
<p>让 AUTO_INCREMENT 序列以其他的值起始：</p>
<pre><code class="language-sql">-- number 是任意数字
ALTER TABLE tab_name AUTO_INCREMENT=number;
</code></pre>
<p>MySQL 设定起始值只能在建表后使用 <code>ALTER TABLE</code> 语句。也可以在建表后直接使用 <code>ALTER TABLE</code> 语句定义 AUTO_INCREMENT 以及它的起始值。</p>
<pre><code class="language-sql">CREATE TABLE tab_name
(
    column1 INT NOT NULL PRIMARY KEY,
    ...
);
ALTER TABLE tab_test AUTO_INCREMENT=number;
-- number 是任意数字
</code></pre>
<hr>
<p>MS SQL Server 使用 <code>IDENTITY()</code> 来执行 auto-increment 任务：</p>
<pre><code class="language-sql">-- IDENTITY(initial, incremental) 中，
-- initial 是初始值，incremental 是递增值
-- 即，以 initial 作为初始值，每新增一条记录递增 incremental
CREATE TABLE tab_name
(
    column1 INT IDENTITY(initial, incremental) PRIMARY KEY,
    ...
)
</code></pre>
<p>插入数据的方法同 MySQL。</p>
<hr>
<p>Oracle 通过创建 <code>sequence</code> 对象（该对象生成数字序列）创建 auto-increment 字段：</p>
<pre><code class="language-sql">CREATE SEQUENCE sp_name
MINVALUE 1    # 最小值为 1
START WITH 1  # 起始值为 1
INCREMENT BY 1  # 每次递增 1
CACHE 10    # 缓存 10 个值以提高性能
</code></pre>
<p>插入新记录时，必须使用 <code>sequence</code> 对象的 <code>nextval</code> 函数（该函数从 <code>sp_name</code> 序列中取回下一个值）：</p>
<pre><code class="language-sql">-- 假设 tab_name 已被创建，
-- 且要对 column1 使用 nextval() 函数
INSERT INTO tab_name ( column1, column2, column3)
VALUES ( sp_name.nextval, val2, val3);
</code></pre>
<hr>
<h1 id="视图">视图</h1>
<p>视图是虚拟的表。视图并不包含数据，它只包含使用时动态检索数据的查询。视图的 SELECT 用法与表的用法基本相同。</p>
<p>使用视图的原因：</p>
<ul>
<li>
<p>重用 SQL 语句。</p>
</li>
<li>
<p>简化复杂的 SQL 操作（无需知道视图的基本查询细节）。</p>
</li>
<li>
<p>使用表的一部分而不是整个表。</p>
</li>
<li>
<p>保护数据。<br>
可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。</p>
</li>
<li>
<p>更改数据格式和表示。<br>
视图可返回与底层表的表示和格式不同的数据。</p>
</li>
</ul>
<hr>
<p>视图的使用规则：</p>
<ul>
<li>
<p>视图名必须为一且不能与其他视图或表重名。</p>
</li>
<li>
<p>对于可创建的视图数目没有限制。</p>
</li>
<li>
<p>创建视图，必须具有足够的访问权限（通常由数据库管理人员授予）。</p>
</li>
<li>
<p>视图可以嵌套，但允许的嵌套层数在不同的 DBMS 中有所不同。<br>
嵌套视图、使用多个联结和过滤创建复杂的视图都会使性能下降。在产品环境中使用之前，应该对其进行全面测试。</p>
</li>
<li>
<p>许多 DBMS 禁止在视图查询中使用 <code>ORDER BY</code> 子句。</p>
</li>
<li>
<p>有些 DBMS 要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。</p>
</li>
<li>
<p>视图不能索引，也不能有关联的触发器或默认值。</p>
</li>
<li>
<p>有些 DBMS 把视图作为只读的查询（不能将数据写回底层表，如 SQLite）。</p>
</li>
<li>
<p>有些 DBMS 禁止对视图中的行进行插入或更新后，该行不再属于该视图的操作。<br>
默认情况下，如果删除视图中的某行的某列后，可能会导致该行不属于该视图。但是某些 DBMS 会防止这种情况发生。</p>
</li>
</ul>
<hr>
<h2 id="create-view-创建视图">CREATE VIEW 创建视图</h2>
<p>使用 <code>CREATE VIEW</code> 语句创建视图，通常包含两部分：</p>
<ul>
<li>
<p>视图名；</p>
</li>
<li>
<p><code>SELECT</code> 查询语句。</p>
</li>
</ul>
<p>视图的用途：</p>
<ol>
<li>
<p>利用视图简化复杂的联结：</p>
<pre><code class="language-sql">CREATE VIEW view_name AS
SELECT filed1, filed2, ...
FROM table1, table2, ...
WHERE condition1;
</code></pre>
</li>
<li>
<p>用视图重新格式话检索出的数据：</p>
<pre><code class="language-sql">-- filed1, filed2, ... 指需要重命名的字段
ALTER VIEW view_name AS
SELECT filed1 AS alias1, filed2 AS alias2, ...
FROM tab_name;
</code></pre>
</li>
<li>
<p>用视图过滤不想要的数据。</p>
</li>
</ol>
<p>一般创建的视图都不会绑定特定的数据，这会提高视图的可重用性。</p>
<p>从视图检索数据时如果使用了一条 <code>WHERE</code> 子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p>
<hr>
<h2 id="drop-view-删除视图">DROP VIEW 删除视图</h2>
<p>通过 <code>DROP VIEW</code> 删除视图（仅删除视图的定义，视图中并包含真实的数据）：</p>
<pre><code class="language-sql">DROP VIEW view_name;
</code></pre>
<hr>
<h1 id="索引">索引</h1>
<p>索引通过排序数据以加快搜索和排序操作的速度。</p>
<ul>
<li>
<p>索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。</p>
</li>
<li>
<p>索引数据可能要占用大量的存储空间。</p>
</li>
<li>
<p>用户无法看到索引。</p>
</li>
<li>
<p>并非所有数据都适合做索引。</p>
</li>
<li>
<p>索引用于数据过滤和数据排序。如果经常以某种特定的顺序排序数据，则该数据可能适合做索引。</p>
</li>
<li>
<p>可以在索引中定义多个列。这样的索引仅在以这个列组合排序时有用。</p>
</li>
</ul>
<hr>
<h2 id="create-index-创建索引">CREATE INDEX 创建索引</h2>
<p>索引使用 <code>CREATE INDEX</code> 语句创建（不同的 DBMS 创建索引的语句变化很大）。</p>
<p>创建一个允许使用重复值的索引：</p>
<pre><code class="language-sql">CREATE INDEX index_name
ON tab_name (column1, column2, ...);
</code></pre>
<p>创建唯一索引（不允许两个行拥有相同的索引值）：</p>
<pre><code class="language-sql">CREATE INDEX index_name
ON tab_name (column1, column2, ...);
</code></pre>
<p>索引必须唯一命名。</p>
<hr>
<h2 id="drop-index-删除索引">DROP INDEX 删除索引</h2>
<p>MySQL:</p>
<pre><code class="language-sql">ALTER TABLE tab_name
DROP INDEX index_name;
</code></pre>
<p>MS Access：</p>
<pre><code class="language-sql">DROP INDEX index_name ON tab_name;
</code></pre>
<p>MS SQL Server：</p>
<pre><code class="language-sql">DROP INDEX tab_name.index_name;
</code></pre>
<p>DB2 / Oracle：</p>
<pre><code class="language-sql">DROP INDEX index_name;
</code></pre>
<hr>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://linna-cy.github.io/old-blog/hello-gridea/" class="post-title gt-a-link">
                    Hello Gridea
                </a>
            </div>
        

        

        

        <!-- <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first"></div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://linna-cy.github.io/old-blog/atom.xml" target="_blank">RSS</a>
    </div>
</div>
 -->
    </div>
</div>
<script>
  hljs.highlightAll();
  // 开启代码高亮
  // hljs.initHighlightingOnLoad();
  // 行号显示
  // hljs.initLineNumbersOnLoad({ singleLine:true });
  // let tocDiv = document.getElementById('toc-div');
  // let toc = document.querySelector('#toc-div .markdownIt-TOC');
  // if (toc === null || toc === undefined) {
  //   tocDiv.style.display = 'none';
  // }

  setCodeAllNum();
</script>
</body>
</html>
